// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

package com.microsoft.typespec.http.client.generator.core.extension.plugin;

import com.azure.json.JsonProviders;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import org.slf4j.Logger;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;
import java.util.stream.Collectors;

/**
 * Settings that are used by the Java AutoRest Generator.
 */
public class JavaSettings {
    private static final String VERSION = "4.0.0";
    private static JavaSettings instance;
    private static NewPlugin host;
    private static String header;
    private static final Map<String, Object> SIMPLE_JAVA_SETTINGS = new HashMap<>();
    private static Logger logger;
    private final boolean useKeyCredential;
    private final String flavor;
    private final boolean noCustomHeaders;
    private final boolean disableTypedHeadersMethods;

    static void setHeader(String value) {
        if ("MICROSOFT_MIT".equals(value)) {
            header = MICROSOFT_MIT_LICENSE_HEADER + "\n" + String.format(DEFAULT_CODE_GENERATION_HEADER, VERSION);
        } else if ("MICROSOFT_APACHE".equals(value)) {
            header = MICROSOFT_APACHE_LICENSE_HEADER + "\n" + String.format(DEFAULT_CODE_GENERATION_HEADER, VERSION);
        } else if ("MICROSOFT_MIT_NO_VERSION".equals(value)) {
            header = MICROSOFT_MIT_LICENSE_HEADER + "\n" + DEFAULT_CODE_GENERATION_HEADER_WITHOUT_VERSION;
        } else if ("MICROSOFT_MIT_SMALL_NO_VERSION".equals(value)) {
            header = MICROSOFT_MIT_SMALL_LICENSE_HEADER + "\n" + DEFAULT_CODE_GENERATION_HEADER_WITHOUT_VERSION;
        } else if ("MICROSOFT_APACHE_NO_VERSION".equals(value)) {
            header = MICROSOFT_APACHE_LICENSE_HEADER + "\n" + DEFAULT_CODE_GENERATION_HEADER_WITHOUT_VERSION;
        } else if ("MICROSOFT_MIT_NO_CODEGEN".equals(value)) {
            header = MICROSOFT_MIT_LICENSE_HEADER + "\n" + "Code generated by Microsoft (R) AutoRest Code Generator.";
        } else if ("NONE".equals(value)) {
            header = "";
        } else if ("MICROSOFT_MIT_SMALL".equals(value)) {
            header = MICROSOFT_MIT_SMALL_LICENSE_HEADER + "Code generated by Microsoft (R) AutoRest Code Generator.";
        } else if ("MICROSOFT_MIT_SMALL_TYPESPEC".equals(value)) {
            header = MICROSOFT_MIT_SMALL_LICENSE_HEADER + "Code generated by Microsoft (R) TypeSpec Code Generator.";
        } else if ("SMALL_TYPESPEC".equals(value)) {
            header = "Code generated by Microsoft (R) TypeSpec Code Generator.";
        } else if ("MICROSOFT_MIT_SMALL_NO_CODEGEN".equals(value)) {
            header = MICROSOFT_MIT_SMALL_LICENSE_HEADER;
        } else {
            header = value;
        }
    }

    static void setHost(NewPlugin host) {
        JavaSettings.host = host;
        logger = new PluginLogger(host, JavaSettings.class);
    }

    /**
     * Clear the JavaSettings instance.
     */
    public static void clear() {
        instance = null;
    }

    /**
     * Get the JavaSettings instance.
     *
     * @return The JavaSettings instance.
     */
    public static JavaSettings getInstance() {
        if (instance == null) {
            AutorestSettings autorestSettings = new AutorestSettings();
            loadStringSetting("title", autorestSettings::setTitle);
            loadStringOrArraySettingAsArray("security", autorestSettings::setSecurity);
            loadStringOrArraySettingAsArray("security-scopes", autorestSettings::setSecurityScopes);
            loadStringSetting("security-header-name", autorestSettings::setSecurityHeaderName);

            loadStringSetting("tag", autorestSettings::setTag);
            loadStringSetting("base-folder", autorestSettings::setBaseFolder);
            loadStringSetting("output-folder", autorestSettings::setOutputFolder);
            loadStringSetting("java-sdks-folder", autorestSettings::setJavaSdksFolder);
            // input-file
            List<String> inputFiles = host.getValueWithJsonReader("input-file",
                jsonReader -> jsonReader.readArray(JsonReader::getString));
            if (inputFiles != null) {
                autorestSettings.getInputFiles().addAll(inputFiles);
                logger.debug("List of input files : {}", autorestSettings.getInputFiles());
            }
            // require (readme.md etc.)
            List<String> require = host.getValueWithJsonReader("require",
                jsonReader -> jsonReader.readArray(JsonReader::getString));
            if (require != null) {
                autorestSettings.getRequire().addAll(require);
                logger.debug("List of require : {}", autorestSettings.getRequire());
            }

            String fluent = getStringValue(host, "fluent");

            setHeader(getStringValue(host, "license-header"));
            instance = new JavaSettings(
                autorestSettings,
                host.getValueWithJsonReader("modelerfour", jsonReader -> jsonReader.readMap(JsonReader::readUntyped)),
                getBooleanValue(host, "azure-arm", false),
                getBooleanValue(host, "sdk-integration", false),
                fluent,
                getBooleanValue(host, "regenerate-pom", false),
                header,
                getStringValue(host, "service-name"),
                getStringValue(host, "namespace", "com.azure.app").toLowerCase(),
                getBooleanValue(host, "client-side-validations", false),
                getStringValue(host, "client-type-prefix"),
                getBooleanValue(host, "generate-client-interfaces", false),
                getBooleanValue(host, "generate-client-as-impl", false),
                getStringValue(host, "implementation-subpackage", "implementation"),
                getStringValue(host, "models-subpackage", "models"),
                getStringValue(host, "custom-types", ""),
                getStringValue(host, "custom-types-subpackage", ""),
                getStringValue(host, "fluent-subpackage", "fluent"),
                getBooleanValue(host, "required-parameter-client-methods", false),
                getBooleanValue(host, "generate-sync-async-clients", false),
                getBooleanValue(host, "generate-builder-per-client", false),
                getStringValue(host, "sync-methods", "essential"),
                getBooleanValue(host, "client-logger", false),
                getBooleanValue(host, "required-fields-as-ctor-args", false),
                getBooleanValue(host, "service-interface-as-public", true),
                getStringValue(host, "artifact-id", ""),
                getStringValue(host, "credential-types", "none"),
                getStringValue(host, "credential-scopes"),
                getStringValue(host, "customization-jar-path"),
                getStringValue(host, "customization-class"),
                getBooleanValue(host, "optional-constant-as-enum", false),
                getBooleanValue(host, "data-plane", false),
                getBooleanValue(host, "use-iterable", false),
                host.getValueWithJsonReader("service-versions", jsonReader -> jsonReader.readArray(JsonReader::getString)),
                getStringValue(host, "client-flattened-annotation-target", ""),
                getStringValue(host, "key-credential-header-name", ""),
                getBooleanValue(host, "disable-client-builder", false),
                host.getValueWithJsonReader("polling", jsonReader -> jsonReader.readMap(PollingDetails::fromJson)),
                getBooleanValue(host, "generate-samples", false),
                getBooleanValue(host, "generate-tests", false),
                false, //getBooleanValue(host, "generate-send-request-method", false),
                getBooleanValue(host, "annotate-getters-and-setters-for-serialization", false),
                getStringValue(host, "default-http-exception-type"),
                getBooleanValue(host, "use-default-http-status-code-to-exception-type-mapping", false),
                host.getValueWithJsonReader("http-status-code-to-exception-type-mapping", JavaSettings::parseStatusCodeMapping),
                getBooleanValue(host, "partial-update", false),
                // If fluent default to false, this is because the automated test generation ends up with invalid code.
                // Once that is fixed, this can be switched over to true.
                getBooleanValue(host, "generic-response-type", fluent == null),
                getBooleanValue(host, "stream-style-serialization", true),
                getBooleanValue(host, "enable-sync-stack", false),
                getBooleanValue(host, "output-model-immutable", false),
                getBooleanValue(host, "use-input-stream-for-binary", false),
                getBooleanValue(host, "no-custom-headers", true),
                getBooleanValue(host, "include-read-only-in-constructor-args", false),
                // setting the default as true as the Java design guideline recommends using String for URLs.
                getBooleanValue(host, "url-as-string", true),
                getBooleanValue(host, "uuid-as-string", false),

                // setting this to false by default as a lot of existing libraries still use swagger and
                // were generated with required = true set in JsonProperty annotation
                getBooleanValue(host, "disable-required-property-annotation", false),
                getBooleanValue(host, "enable-page-size", false),
                getBooleanValue(host, "use-key-credential", false),
                getBooleanValue(host, "null-byte-array-maps-to-empty-array", false),
                getBooleanValue(host, "graal-vm-config", false),
                getStringValue(host, "flavor", "Azure"),
                getBooleanValue(host, "disable-typed-headers-methods", false)
            );
        }
        return instance;
    }

    private static Map<Integer, String> parseStatusCodeMapping(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            Map<Integer, String> mapping = new HashMap<>();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                int key = Integer.parseInt(reader.getFieldName());
                reader.nextToken();
                mapping.put(key, reader.getString());
            }

            return mapping;
        });
    }

    /**
     * Create a new JavaSettings object with the provided properties.
     *
     * @param autorestSettings The autorest settings.
     * @param modelerSettings The modeler settings.
     * @param azure Whether to generate the Azure.
     * @param sdkIntegration Whether to generate the SDK integration.
     * @param fluent The fluent generation mode.
     * @param regeneratePom Whether to regenerate the POM.
     * @param fileHeaderText The file header text.
     * @param serviceName The service name.
     * @param packageKeyword The package keyword.
     * @param clientSideValidations Whether to add client-side validations to the generated clients.
     * @param clientTypePrefix The prefix that will be added to each generated client type.
     * @param generateClientInterfaces Whether interfaces will be generated for Service and Method Group clients.
     * @param generateClientAsImpl Whether Service and Method Group clients will be generated as implementation
     * @param implementationSubpackage The sub-package that the Service and Method Group client implementation classes
     * will be put into.
     * @param modelsSubpackage The sub-package that Enums, Exceptions, and Model types will be put into.
     * @param customTypes The custom types that will be generated.
     * @param customTypesSubpackage The sub-package that custom types will be put into.
     * @param fluentSubpackage The sub-package that Fluent interfaces will be put into.
     * @param requiredParameterClientMethods Whether Service and Method Group client method overloads that omit optional
     * parameters will be created.
     * @param generateSyncAsyncClients Whether Service and Method Group clients will be generated with both synchronous
     * and asynchronous methods.
     * @param generateBuilderPerClient Whether a builder will be generated for each Service and Method Group client.
     * @param syncMethods The sync methods generation mode.
     * @param clientLogger Whether to add a logger to the generated clients.
     * @param requiredFieldsAsConstructorArgs Whether required fields will be included in the constructor arguments for
     * generated models.
     * @param serviceInterfaceAsPublic If set to true, proxy method service interface will be marked as public.
     * @param artifactId The artifactId for the generated project.
     * @param credentialType The type of credential to generate.
     * @param credentialScopes The scopes for the generated credential.
     * @param customizationJarPath The path to the customization jar.
     * @param customizationClass The class to use for customization.
     * @param optionalConstantAsEnum Whether to generate optional constants as enums.
     * @param dataPlaneClient Whether to generate a data plane client.
     * @param useIterable Whether to use Iterable instead of List for collection types.
     * @param serviceVersions The versions of the service.
     * @param clientFlattenAnnotationTarget The target for the <code>@JsonFlatten</code> annotation for
     * x-ms-client-flatten.
     * @param keyCredentialHeaderName The header name for the key credential.
     * @param clientBuilderDisabled Whether to disable the client builder.
     * @param pollingConfig The polling configuration.
     * @param generateSamples Whether to generate samples.
     * @param generateTests Whether to generate tests.
     * @param generateSendRequestMethod Whether to generate the send request method.
     * @param annotateGettersAndSettersForSerialization If set to true, Jackson JsonGetter and JsonSetter will annotate
     * getters and setters in generated models to handle serialization and deserialization. For now, fields will
     * continue being annotated to ensure that there are no backwards compatibility breaks.
     * @param defaultHttpExceptionType The fully-qualified class that should be used as the default exception type. This
     * class must extend from HttpResponseException.
     * @param useDefaultHttpStatusCodeToExceptionTypeMapping Determines whether a well-known HTTP status code to
     * exception type mapping should be used if an HTTP status code-exception mapping isn't provided.
     * @param httpStatusCodeToExceptionTypeMapping A mapping of HTTP response status code to the exception type that
     * should be thrown if that status code is seen. All exception types must be fully-qualified and extend from
     * HttpResponseException.
     * @param handlePartialUpdate If set to true, the generated model will handle partial updates.
     * @param genericResponseTypes If set to true, responses will only use Response, ResponseBase, PagedResponse, and
     * PagedResponseBase types with generics instead of creating a specific named type that extends one of those types.
     * @param streamStyleSerialization If set to true, models will handle serialization themselves using stream-style
     * serialization instead of relying on Jackson Databind.
     * @param isSyncStackEnabled If set to true, sync methods are generated using sync stack. i.e these methods do
     * not use sync-over-async stack.
     * @param outputModelImmutable If set to true, the models that are determined as output only models will be made
     * immutable without any public constructors or setter methods.
     * @param streamResponseInputStream If set to true, sync methods will use {@code InputStream} for binary responses.
     * @param noCustomHeaders If set to true, methods that have custom header types will also have an equivalent
     * method that returns just the response with untyped headers.
     * @param includeReadOnlyInConstructorArgs If set to true, read-only required properties will be included in the
     * constructor if {@code requiredFieldsAsConstructorArgs} is true. This is a backwards compatibility flag as
     * previously read-only required were included in constructors.
     * @param urlAsString This generates all URLs as String type. This is enabled by default as required by the Java
     * design guidelines. For backward compatibility, this can be set to false.
     * @param disableRequiredPropertyAnnotation  If set to true, the required property annotation will be disabled.
     * @param pageSizeEnabled If set to true, the generated client will have support for page size.
     * @param useKeyCredential If set to true, the generated client will have support for key credential.
     * @param nullByteArrayMapsToEmptyArray If set to true, {@code ArrayType.BYTE_ARRAY} will return an empty array
     * instead of null when the default value expression is null.
     * @param generateGraalVmConfig If set to true, the generated client will have support for GraalVM.
     * @param flavor The brand name we use to generate SDK.
     * @param disableTypedHeadersMethods Prevents generating REST API methods that include typed headers. If set to
     * true, {@code noCustomHeaders} will be ignored as no REST APIs with typed headers will be generated.
     */
    private JavaSettings(AutorestSettings autorestSettings,
        Map<String, Object> modelerSettings,
        boolean azure,
        boolean sdkIntegration,
        String fluent,
        boolean regeneratePom,
        String fileHeaderText,
        String serviceName,
        String packageKeyword,
        boolean clientSideValidations,
        String clientTypePrefix,
        boolean generateClientInterfaces,
        boolean generateClientAsImpl,
        String implementationSubpackage,
        String modelsSubpackage,
        String customTypes,
        String customTypesSubpackage,
        String fluentSubpackage,
        boolean requiredParameterClientMethods,
        boolean generateSyncAsyncClients,
        boolean generateBuilderPerClient,
        String syncMethods,
        boolean clientLogger,
        boolean requiredFieldsAsConstructorArgs,
        boolean serviceInterfaceAsPublic,
        String artifactId,
        String credentialType,
        String credentialScopes,
        String customizationJarPath,
        String customizationClass,
        boolean optionalConstantAsEnum,
        boolean dataPlaneClient,
        boolean useIterable,
        List<String> serviceVersions,
        String clientFlattenAnnotationTarget,
        String keyCredentialHeaderName,
        boolean clientBuilderDisabled,
        Map<String, PollingDetails> pollingConfig,
        boolean generateSamples,
        boolean generateTests,
        boolean generateSendRequestMethod,
        boolean annotateGettersAndSettersForSerialization,
        String defaultHttpExceptionType,
        boolean useDefaultHttpStatusCodeToExceptionTypeMapping,
        Map<Integer, String> httpStatusCodeToExceptionTypeMapping,
        boolean handlePartialUpdate,
        boolean genericResponseTypes,
        boolean streamStyleSerialization,
        boolean isSyncStackEnabled,
        boolean outputModelImmutable,
        boolean streamResponseInputStream,
        boolean noCustomHeaders,
        boolean includeReadOnlyInConstructorArgs,
        boolean urlAsString,
        boolean uuidAsString,
        boolean disableRequiredPropertyAnnotation,
        boolean pageSizeEnabled,
        boolean useKeyCredential,
        boolean nullByteArrayMapsToEmptyArray,
        boolean generateGraalVmConfig,
        String flavor,
        boolean disableTypedHeadersMethods) {

        this.autorestSettings = autorestSettings;
        this.modelerSettings = new ModelerSettings(modelerSettings);
        this.azure = azure;
        this.sdkIntegration = sdkIntegration;
        this.fluent = fluent == null ? Fluent.NONE : (fluent.isEmpty() || fluent.equalsIgnoreCase("true")
            ? Fluent.PREMIUM : Fluent.valueOf(fluent.toUpperCase(Locale.ROOT)));
        this.regeneratePom = regeneratePom;
        this.fileHeaderText = fileHeaderText;
        this.serviceName = serviceName;
        this.packageName = packageKeyword;
        this.clientSideValidations = clientSideValidations;
        this.clientTypePrefix = clientTypePrefix;
        this.generateClientInterfaces = generateClientInterfaces;
        this.generateClientAsImpl = generateClientAsImpl || generateSyncAsyncClients || generateClientInterfaces;
        this.implementationSubpackage = implementationSubpackage;
        this.modelsSubpackage = modelsSubpackage;
        this.customTypes = (customTypes == null || customTypes.isEmpty())
            ? new ArrayList<>() : Arrays.asList(customTypes.split(","));
        this.customTypesSubpackage = customTypesSubpackage;
        this.fluentSubpackage = fluentSubpackage;
        this.requiredParameterClientMethods = requiredParameterClientMethods;
        this.generateSyncAsyncClients = generateSyncAsyncClients;
        this.generateBuilderPerClient = generateBuilderPerClient;
        this.syncMethods = SyncMethodsGeneration.fromValue(syncMethods);
        this.clientLogger = clientLogger;
        this.requiredFieldsAsConstructorArgs = requiredFieldsAsConstructorArgs;
        this.serviceInterfaceAsPublic = serviceInterfaceAsPublic;
        this.artifactId = artifactId;
        this.optionalConstantAsEnum = optionalConstantAsEnum;
        this.dataPlaneClient = dataPlaneClient;
        this.useIterable = useIterable;
        this.serviceVersions = serviceVersions;
        this.clientFlattenAnnotationTarget =
            (clientFlattenAnnotationTarget == null || clientFlattenAnnotationTarget.isEmpty())
                ? ClientFlattenAnnotationTarget.TYPE
                : ClientFlattenAnnotationTarget.valueOf(clientFlattenAnnotationTarget.toUpperCase(Locale.ROOT));

        if (credentialType != null) {
            String[] splits = credentialType.split(",");
            this.credentialTypes = Arrays.stream(splits)
                .map(String::trim)
                .map(CredentialType::fromValue)
                .collect(Collectors.toSet());
        }
        if (credentialScopes != null) {
            String[] splits = credentialScopes.split(",");
            this.credentialScopes = Arrays.stream(splits)
                .map(String::trim)
                .map(split -> {
                    if (!split.startsWith("\"")) {
                        split = "\"" + split + "\"";
                    }
                    return split;
                })
                .collect(Collectors.toSet());
        }
        this.customizationJarPath = customizationJarPath;
        this.customizationClass = customizationClass;
        this.keyCredentialHeaderName = keyCredentialHeaderName;
        this.clientBuilderDisabled = clientBuilderDisabled;
        if (pollingConfig != null) {
            if (!pollingConfig.containsKey("default")) {
                pollingConfig.put("default", new PollingDetails());
            }
        }
        this.pollingConfig = pollingConfig;
        this.generateSamples = generateSamples;
        this.generateTests = generateTests;
        this.generateSendRequestMethod = generateSendRequestMethod;
        this.annotateGettersAndSettersForSerialization = annotateGettersAndSettersForSerialization;

        // Error HTTP status code exception type handling.
        this.defaultHttpExceptionType = defaultHttpExceptionType;
        this.useDefaultHttpStatusCodeToExceptionTypeMapping = useDefaultHttpStatusCodeToExceptionTypeMapping;
        this.httpStatusCodeToExceptionTypeMapping = httpStatusCodeToExceptionTypeMapping;

        this.handlePartialUpdate = handlePartialUpdate;

        this.genericResponseTypes = genericResponseTypes;

        this.streamStyleSerialization = streamStyleSerialization;
        this.syncStackEnabled = isSyncStackEnabled;

        this.outputModelImmutable = outputModelImmutable;

        this.isInputStreamForBinary = streamResponseInputStream;
        this.noCustomHeaders = noCustomHeaders;
        this.includeReadOnlyInConstructorArgs = includeReadOnlyInConstructorArgs;
        this.urlAsString = urlAsString;
        this.uuidAsString = uuidAsString;
        this.disableRequiredJsonAnnotation = disableRequiredPropertyAnnotation;
        this.pageSizeEnabled = pageSizeEnabled;
        this.useKeyCredential = useKeyCredential;
        this.nullByteArrayMapsToEmptyArray = nullByteArrayMapsToEmptyArray;
        this.generateGraalVmConfig = generateGraalVmConfig;
        this.flavor = flavor;
        this.disableTypedHeadersMethods = disableTypedHeadersMethods;
    }

    /**
     * Whether to generate with Azure branding.
     *
     * @return Whether to generate with Azure branding.
     */
    public boolean isBranded() {
        return "azure".equalsIgnoreCase(this.flavor);
    }

    private final String keyCredentialHeaderName;

    /**
     * The header name for the key credential.
     *
     * @return The header name for the key credential.
     */
    public String getKeyCredentialHeaderName() {
        return this.keyCredentialHeaderName;
    }


    private Set<CredentialType> credentialTypes;

    /**
     * The types of credentials to generate.
     *
     * @return The types of credentials to generate.
     */
    public Set<CredentialType> getCredentialTypes() {
        return credentialTypes;
    }


    private Set<String> credentialScopes;

    /**
     * The scopes for the generated credential.
     *
     * @return The scopes for the generated credential.
     */
    public Set<String> getCredentialScopes() {
        return credentialScopes;
    }


    private final boolean azure;

    /**
     * Whether to generate the Azure.
     *
     * @return Whether to generate the Azure.
     */
    public final boolean isAzure() {
        return azure;
    }


    private final String artifactId;

    /**
     * The artifactId for the generated project.
     *
     * @return The artifactId for the generated project.
     */
    public String getArtifactId() {
        return artifactId;
    }

    /**
     * Whether to disable custom headers type generation.
     *
     * @return Whether to disable custom headers type generation.
     */
    public boolean isNoCustomHeaders() {
        return noCustomHeaders;
    }


    private final boolean urlAsString;

    /**
     * Whether to generate all URLs as String type. This is enabled by default as required by the Java design
     * guidelines. For backward compatibility, this can be set to false.
     *
     * @return Whether to generate all URLs as String type.
     */
    public boolean urlAsString() {
        return urlAsString;
    }

    private final boolean uuidAsString;

    /**
     * Whether to use string for uuid.
     *
     * @return Whether to use string for uuid.
     */
    public boolean uuidAsString() {
        return uuidAsString;
    }

    private final boolean disableRequiredJsonAnnotation;

    /**
     * Whether to disable the required property annotation.
     *
     * @return Whether to disable the required property annotation.
     */
    public boolean isDisableRequiredJsonAnnotation() {
        return disableRequiredJsonAnnotation;
    }

    /**
     * Represents Fluent generation mode.
     */
    public enum Fluent {
        /**
         * No Fluent generation.
         */
        NONE,
        /**
         * Fluent Lite generation.
         */
        LITE,
        /**
         * Fluent Premium generation.
         */
        PREMIUM;

        /**
         * Gets a {@link Fluent} value for the give {@code value} string.
         *
         * @param value The value to parse.
         * @return The {@link Fluent} value.
         */
        public static Fluent fromString(String value) {
            if (value == null || value.isEmpty()) {
                return null;
            }

            if ("none".equalsIgnoreCase(value)) {
                return NONE;
            } else if ("lite".equalsIgnoreCase(value)) {
                return LITE;
            } else if ("premium".equalsIgnoreCase(value)) {
                return PREMIUM;
            } else {
                return null;
            }
        }
    }

    private final Fluent fluent;

    /**
     * Whether to generate the Fluent.
     *
     * @return Whether to generate the Fluent.
     */
    public final boolean isFluent() {
        return fluent != Fluent.NONE;
    }

    /**
     * Whether to generate Fluent Lite.
     *
     * @return Whether to generate Fluent Lite.
     */
    public final boolean isFluentLite() {
        return fluent == Fluent.LITE;
    }

    /**
     * Whether to generate Fluent Premium.
     *
     * @return Whether to generate Fluent Premium.
     */
    public final boolean isFluentPremium() {
        return fluent == Fluent.PREMIUM;
    }

    /**
     * Whether to generate the Azure or Fluent.
     *
     * @return Whether to generate the Azure or Fluent.
     */
    public final boolean isAzureOrFluent() {
        return isAzure() || isFluent();
    }

    // configure for model flatten in client

    /**
     * Represents the target for the <code>@JsonFlatten</code> annotation for x-ms-client-flatten.
     */
    public enum ClientFlattenAnnotationTarget {
        /**
         * JsonFlatten on class
         */
        TYPE,
        /**
         * JsonFlatten on class variable
         */
        FIELD,
        /**
         * Do not use @JsonFlatten. The model flatten is implemented as class variable getter/setter access the
         * flattened properties.
         */
        NONE,
        /**
         * Disable the model flatten
         */
        DISABLED
    }

    // target for @JsonFlatten annotation for x-ms-client-flatten
    private final ClientFlattenAnnotationTarget clientFlattenAnnotationTarget;

    /**
     * When flatten client mode, where to put the <code>@JsonFlatten</code> annotation. If NONE, flatten at
     * getter/setter methods via codegen.
     *
     * @return When flatten client mode, where to put the <code>@JsonFlatten</code> annotation. If NONE, flatten at
     * getter/setter methods via codegen.
     */
    public ClientFlattenAnnotationTarget getClientFlattenAnnotationTarget() {
        return this.clientFlattenAnnotationTarget;
    }

    /**
     * Represents the settings that are used by the modeler.
     */
    public static class ModelerSettings {
        private final Map<String, Object> settings;

        /**
         * Create a new ModelerSettings object with the provided settings.
         *
         * @param settings The settings that are used by the modeler.
         */
        public ModelerSettings(Map<String, Object> settings) {
            this.settings = settings == null ? Collections.emptyMap() : settings;
        }

        /**
         * Get the settings that are used by the modeler.
         *
         * @return The settings that are used by the modeler.
         */
        public Map<String, Object> getSettings() {
            return settings;
        }

        /**
         * If false, use client-flattened-annotation-target = TYPE for no flatten; client-flattened-annotation-target =
         * NONE for flatten at getter/setter methods via codegen.
         * <p>
         * If true, use client-flattened-annotation-target = TYPE for <code>@JsonFlatten</code> on type (i.e. on class);
         * client-flattened-annotation-target = FIELD for <code>@JsonFlatten</code> on field.
         * <p>
         * modelerfour.flatten-models = false and client-flattened-annotation-target = NONE would require
         * modelerfour.flatten-payloads = false.
         *
         * @return value of modelerfour.flatten-models
         */
        public boolean isFlattenModel() {
            return settings.containsKey("flatten-models") && (boolean) settings.get("flatten-models");
        }
    }

    private final ModelerSettings modelerSettings;

    /**
     * The settings that are used by the modeler.
     *
     * @return The settings that are used by the modeler.
     */
    public ModelerSettings getModelerSettings() {
        return modelerSettings;
    }

    private final AutorestSettings autorestSettings;

    /**
     * The settings that are used by the AutoRest generator.
     *
     * @return The settings that are used by the AutoRest generator.
     */
    public AutorestSettings getAutorestSettings() {
        return autorestSettings;
    }

    /**
     * The settings that are used by the AutoRest generator.
     *
     * @return The settings that are used by the AutoRest generator.
     */
    public Map<String, Object> getSimpleJavaSettings() {
        return SIMPLE_JAVA_SETTINGS;
    }

    private final boolean sdkIntegration;

    /**
     * Whether to generate the SDK integration.
     *
     * @return Whether to generate the SDK integration.
     */
    public boolean isSdkIntegration() {
        return sdkIntegration;
    }

    private final boolean regeneratePom;

    /**
     * Whether to regenerate the pom file.
     *
     * @return Whether to regenerate the pom file.
     */
    public final boolean isRegeneratePom() {
        return regeneratePom;
    }

    private final String fileHeaderText;

    /**
     * Get the file header text.
     *
     * @return The file header text.
     */
    public final String getFileHeaderText() {
        return fileHeaderText;
    }
    
    private final String serviceName;

    /**
     * Get the service name.
     *
     * @return The service name.
     */
    public final String getServiceName() {
        return serviceName;
    }

    private final String packageName;

    /**
     * Get the package name.
     *
     * @return The package name.
     */
    public final String getPackage() {
        return packageName;
    }

    /**
     * Get the package name with the provided package suffixes appended.
     *
     * @param packageSuffixes The package suffixes to append to the package name.
     * @return The package name with the provided package suffixes appended.
     */
    public final String getPackage(String... packageSuffixes) {
        StringBuilder packageBuilder = new StringBuilder(packageName);
        if (packageSuffixes != null) {
            for (String packageSuffix : packageSuffixes) {
                if (packageSuffix != null && !packageSuffix.isEmpty()) {
                    // Cleanse the package suffix to remove leading and trailing periods.
                    boolean startsWithPeriod = packageSuffix.startsWith(".");
                    boolean endsWithPeriod = packageSuffix.endsWith(".");

                    String cleansedPackageSuffix;
                    if (startsWithPeriod && endsWithPeriod) {
                        cleansedPackageSuffix = packageSuffix.substring(1, packageSuffix.length() - 1);
                    } else if (startsWithPeriod) {
                        cleansedPackageSuffix = packageSuffix.substring(1);
                    } else if (endsWithPeriod) {
                        cleansedPackageSuffix = packageSuffix.substring(0, packageSuffix.length() - 1);
                    } else {
                        cleansedPackageSuffix = packageSuffix;
                    }

                    packageBuilder.append(".").append(cleansedPackageSuffix);
                }
            }
        }
        return packageBuilder.toString();
    }

    private final boolean clientSideValidations;

    /**
     * Whether to add client side validations to the generated clients.
     *
     * @return Whether to add client side validations to the generated clients.
     */
    public final boolean isClientSideValidations() {
        return clientSideValidations;
    }

    /**
     * The prefix that will be added to each generated client type.
     */
    private final String clientTypePrefix;

    /**
     * The prefix that will be added to each generated client type.
     *
     * @return The prefix that will be added to each generated client type.
     */
    public final String getClientTypePrefix() {
        return clientTypePrefix;
    }

    /**
     * Whether interfaces will be generated for Service and Method Group clients.
     */
    private final boolean generateClientInterfaces;

    /**
     * Whether interfaces will be generated for Service and Method Group clients.
     *
     * @return Whether interfaces will be generated for Service and Method Group clients.
     */
    public final boolean isGenerateClientInterfaces() {
        return generateClientInterfaces;
    }

    /**
     * Whether interfaces will be generated for Service and Method Group clients.
     */
    private final boolean generateClientAsImpl;

    /**
     * Whether interfaces will be generated for Service and Method Group clients.
     *
     * @return Whether interfaces will be generated for Service and Method Group clients.
     */
    public final boolean isGenerateClientAsImpl() {
        return generateClientAsImpl;
    }

    /**
     * The sub-package that the Service and Method Group client implementation classes will be put into.
     */
    private final String implementationSubpackage;

    /**
     * The sub-package that the Service and Method Group client implementation classes will be put into.
     *
     * @return The sub-package that the Service and Method Group client implementation classes will be put into.
     */
    public final String getImplementationSubpackage() {
        return implementationSubpackage;
    }

    /**
     * The sub-package that Enums, Exceptions, and Model types will be put into.
     */
    private final String modelsSubpackage;

    /**
     * The sub-package that Enums, Exceptions, and Model types will be put into.
     *
     * @return The sub-package that Enums, Exceptions, and Model types will be put into.
     */
    public final String getModelsSubpackage() {
        return modelsSubpackage;
    }

    private final String fluentSubpackage;

    /**
     * The sub-package for Fluent SDK, that contains Client and Builder types, which is not recommended to be used
     * directly.
     *
     * @return The sub-package for Fluent SDK, that contains Client and Builder types, which is not recommended to be
     * used directly.
     */
    public final String getFluentSubpackage() {
        return fluentSubpackage;
    }

    /**
     * The sub-package for Fluent SDK, that contains Enums, Exceptions, and Model types, which is not recommended being
     * used directly.
     *
     * @return The sub-package for Fluent SDK, that contains Enums, Exceptions, and Model types, which is not
     * recommended being used directly.
     */
    public final String getFluentModelsSubpackage() {
        if (modelsSubpackage.contains(".")) {
            return fluentSubpackage + "." + modelsSubpackage.substring(modelsSubpackage.lastIndexOf(".") + 1);
        } else {
            return fluentSubpackage + "." + modelsSubpackage;
        }
    }

    /**
     * Whether Service and Method Group client method overloads that omit optional parameters will be created.
     */
    private final boolean requiredParameterClientMethods;

    /**
     * Whether Service and Method Group client method overloads that omit optional parameters will be created.
     *
     * @return Whether Service and Method Group client method overloads that omit optional parameters will be created.
     */
    public final boolean isRequiredParameterClientMethods() {
        return requiredParameterClientMethods;
    }

    private final boolean generateSyncAsyncClients;

    /**
     * Whether sync methods are generated using sync stack. i.e these methods do not use sync-over-async stack.
     *
     * @return Whether sync methods are generated using sync stack.
     */
    public final boolean isGenerateSyncAsyncClients() {
        return generateSyncAsyncClients;
    }

    /**
     * Whether sync methods are generated using sync stack. i.e these methods do not use sync-over-async stack.
     *
     * @return Whether sync methods are generated using sync stack.
     */
    public final boolean isSyncClientWrapAsyncClient() {
        return !syncStackEnabled;
    }

    private final SyncMethodsGeneration syncMethods;

    /**
     * Get the sync methods generation.
     *
     * @return The sync methods generation.
     */
    public final SyncMethodsGeneration getSyncMethods() {
        return syncMethods;
    }

    /**
     * Whether to generate async methods.
     *
     * @return Whether to generate async methods.
     */
    public final boolean isGenerateAsyncMethods() {
        SyncMethodsGeneration syncMethodsGeneration = getSyncMethods();
        return syncMethodsGeneration == SyncMethodsGeneration.ALL
            || syncMethodsGeneration == SyncMethodsGeneration.ESSENTIAL;
    }

    /**
     * Whether to generate sync methods.
     *
     * @return Whether to generate sync methods.
     */
    public final boolean isGenerateSyncMethods() {
        SyncMethodsGeneration syncMethodsGeneration = getSyncMethods();
        return syncMethodsGeneration == SyncMethodsGeneration.ALL
            || syncMethodsGeneration == SyncMethodsGeneration.SYNC_ONLY;
    }

    private final boolean requiredFieldsAsConstructorArgs;

    /**
     * Whether required fields will be included as constructor arguments.
     *
     * @return Whether required fields will be included as constructor arguments.
     */
    public boolean isRequiredFieldsAsConstructorArgs() {
        return requiredFieldsAsConstructorArgs;
    }

    private final boolean serviceInterfaceAsPublic;

    /**
     * Whether proxy method service interface will be marked as public.
     *
     * @return Whether proxy method service interface will be marked as public.
     */
    public boolean isServiceInterfaceAsPublic() {
        return serviceInterfaceAsPublic;
    }

    /**
     * Represents sync methods generation.
     */
    public enum SyncMethodsGeneration {
        /**
         * Generate all methods.
         */
        ALL,

        /**
         * Generate only essential methods.
         */
        ESSENTIAL,

        /**
         * Generate only sync methods.
         */
        SYNC_ONLY,  // SYNC_ONLY requires "enable-sync-stack"

        /**
         * Generate no methods.
         */
        NONE;

        /**
         * Convert the string value to the enum value.
         *
         * @param value The string value.
         * @return The enum value.
         */
        public static SyncMethodsGeneration fromValue(String value) {
            if (value == null) {
                return null;
            } else if (value.equals("all")) {
                return ALL;
            } else if (value.equals("essential")) {
                return ESSENTIAL;
            } else if (value.equals("none")) {
                return NONE;
            } else if (value.equals("sync-only")) {
                return SYNC_ONLY;
            }
            return null;
        }
    }

    private final List<String> customTypes;

    /**
     * The list of custom types.
     *
     * @return The list of custom types.
     */
    public List<String> getCustomTypes() {
        return customTypes;
    }

    /**
     * Whether the given type name is a custom type.
     *
     * @param typeName The type name.
     * @return Whether the given type name is a custom type.
     */
    public boolean isCustomType(String typeName) {
        return customTypes.contains(typeName);
    }

    private final String customTypesSubpackage;

    /**
     * The sub-package that custom types will be put into.
     *
     * @return The sub-package that custom types will be put into.
     */
    public final String getCustomTypesSubpackage() {
        return customTypesSubpackage;
    }

    /**
     * Represents the type of credential.
     */
    public enum CredentialType {
        /**
         * Token credential.
         */
        TOKEN_CREDENTIAL,

        /**
         * Azure key credential.
         */
        AZURE_KEY_CREDENTIAL,

        /**
         * No credential.
         */
        NONE;

        /**
         * Convert the string value to the enum value.
         *
         * @param value The string value.
         * @return The enum value.
         */
        public static CredentialType fromValue(String value) {
            if (value == null) {
                return null;
            } else if (value.equals("tokencredential")) {
                return TOKEN_CREDENTIAL;
            } else if (value.equals("azurekeycredential")) {
                return AZURE_KEY_CREDENTIAL;
            } else if (value.equals("none")) {
                return NONE;
            }
            return NONE;
        }
    }

    private final boolean clientLogger;

    /**
     * Whether to use client logger.
     *
     * @return Whether to use client logger.
     */
    public final boolean isUseClientLogger() {
        return clientLogger;
    }

    private final String customizationJarPath;

    /**
     * The path to the customization jar.
     *
     * @return The path to the customization jar.
     */
    public final String getCustomizationJarPath() {
        return customizationJarPath;
    }

    private final String customizationClass;

    /**
     * The fully qualified class name of the customization class.
     *
     * @return The fully qualified class name of the customization class.
     */
    public final String getCustomizationClass() {
        return customizationClass;
    }

    private final boolean optionalConstantAsEnum;

    /**
     * Whether to generate optional constants as enum.
     *
     * @return Whether to generate optional constants as enum.
     */
    public boolean isOptionalConstantAsEnum() {
        return optionalConstantAsEnum;
    }

    private final boolean dataPlaneClient;

    /**
     * Whether the client is a data plane client.
     *
     * @return Whether the client is a data plane client.
     */

    public boolean isDataPlaneClient() {
        return dataPlaneClient;
    }

    private final boolean useIterable;

    /**
     * Whether to use Iterable for list type properties.
     *
     * @return whether to use Iterable for list type properties.
     */
    public boolean isUseIterable() {
        return useIterable;
    }

    /**
     * Service version list. It maps to api-version parameter in swagger. Last one is the latest version, also default
     * version
     */
    private final List<String> serviceVersions;

    /**
     * Service version list. It maps to api-version parameter in swagger. Last one is the latest version, also
     * default version
     *
     * @return Service version list. It maps to api-version parameter in swagger. Last one is the latest version, also
     * default version
     */
    public List<String> getServiceVersions() {
        return serviceVersions;
    }

    private final boolean generateSamples;

    /**
     * Whether to generate samples.
     *
     * @return Whether to generate samples.
     */
    public boolean isGenerateSamples() {
        return generateSamples;
    }

    private final boolean generateTests;

    /**
     * Whether to generate tests.
     *
     * @return Whether to generate tests.
     */
    public boolean isGenerateTests() {
        return generateTests;
    }

    private final boolean generateSendRequestMethod;

    /**
     * Whether to generate the send request method.
     *
     * @return Whether to generate the send request method.
     */
    public boolean isGenerateSendRequestMethod() {
        return generateSendRequestMethod;
    }

    private final boolean syncStackEnabled;

    /**
     * Whether to enable sync stack.
     *
     * @return Whether to enable sync stack.
     */
    public boolean isSyncStackEnabled() {
        return syncStackEnabled;
    }

    private final boolean clientBuilderDisabled;

    /**
     * Whether to disable the client builder.
     *
     * @return Whether to disable the client builder.
     */
    public boolean clientBuilderDisabled() {
        return clientBuilderDisabled;
    }

    private final boolean outputModelImmutable;

    /**
     * Whether the models that are determined as output only models will be made immutable without any public
     * constructors or setter methods.
     *
     * @return Whether the models that are determined as output only models will be made immutable without any public
     * constructors or setter methods.
     */
    public boolean isOutputModelImmutable() {
        return outputModelImmutable;
    }

    private final boolean pageSizeEnabled;

    /**
     * Whether to enable page size.
     *
     * @return Whether to enable page size.
     */
    public boolean isPageSizeEnabled() {
        return pageSizeEnabled;
    }

    private final boolean generateGraalVmConfig;

    /**
     * Whether to generate a GraalVM configuration file.
     *
     * @return Whether to generate a GraalVM configuration file.
     */
    public boolean isGenerateGraalVmConfig() {
        return generateGraalVmConfig;
    }

    /**
     * Represents the details of polling for a long-running operation.
     */
    public static class PollingDetails implements JsonSerializable<PollingDetails> {
        private String strategy;
        private String syncStrategy;
        private String intermediateType;
        private String finalType;
        private String pollInterval;

        /**
         * Creates a new PollingDetails object.
         */
        public PollingDetails() {
        }

        /**
         * The default polling strategy format.
         */
        public static final String DEFAULT_POLLING_STRATEGY_FORMAT = String.join("\n",
                "new %s<>(new PollingStrategyOptions({httpPipeline})",
                "    .setEndpoint({endpoint})",
                "    .setContext({context})",
                "    .setServiceVersion({serviceVersion}))");

        private static final String DEFAULT_POLLING_CODE
            = String.format(DEFAULT_POLLING_STRATEGY_FORMAT, "DefaultPollingStrategy");

        private static final String DEFAULT_SYNC_POLLING_CODE
            = String.format(DEFAULT_POLLING_STRATEGY_FORMAT, "SyncDefaultPollingStrategy");

        /**
         * Gets the strategy for polling.
         *
         * @return The strategy for polling.
         */
        public String getStrategy() {
            if (strategy == null || "default".equalsIgnoreCase(strategy)) {
                return DEFAULT_POLLING_CODE;
            } else {
                return strategy;
            }
        }

        /**
         * Gets the sync strategy for polling.
         *
         * @return The sync strategy for polling.
         */
        public String getSyncStrategy() {
            if (syncStrategy == null || "default".equalsIgnoreCase(syncStrategy)) {
                return DEFAULT_SYNC_POLLING_CODE;
            } else {
                return syncStrategy;
            }
        }

        /**
         * Gets the intermediate type for polling.
         *
         * @return The intermediate type for polling.
         */
        public String getIntermediateType() {
            return intermediateType;
        }

        /**
         * Gets the final type for polling.
         *
         * @return The final type for polling.
         */
        public String getFinalType() {
            return finalType;
        }

        /**
         * Gets the polling interval in seconds.
         *
         * @return The polling interval in seconds.
         */
        public int getPollIntervalInSeconds() {
            return pollInterval != null ? Integer.parseInt(pollInterval) : 1;
        }

        @Override
        public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
            return jsonWriter.writeStartObject()
                .writeStringField("strategy", strategy)
                .writeStringField("sync-strategy", syncStrategy)
                .writeStringField("intermediate-type", intermediateType)
                .writeStringField("final-type", finalType)
                .writeStringField("poll-interval", pollInterval)
                .writeEndObject();
        }

        /**
         * Deserializes a PollingDetails instance from the JSON data.
         *
         * @param jsonReader The JSON reader to deserialize from.
         * @return A PollingDetails instance deserialized from the JSON data.
         * @throws IOException If an error occurs during deserialization.
         */
        public static PollingDetails fromJson(JsonReader jsonReader) throws IOException {
            return jsonReader.readObject(reader -> {
                PollingDetails pollingDetails = new PollingDetails();

                while (reader.nextToken() != JsonToken.END_OBJECT) {
                    String fieldName = reader.getFieldName();
                    reader.nextToken();

                    if ("strategy".equals(fieldName)) {
                        pollingDetails.strategy = reader.getString();
                    } else if ("sync-strategy".equals(fieldName)) {
                        pollingDetails.syncStrategy = reader.getString();
                    } else if ("intermediate-type".equals(fieldName)) {
                        pollingDetails.intermediateType = reader.getString();
                    } else if ("final-type".equals(fieldName)) {
                        pollingDetails.finalType = reader.getString();
                    } else if ("poll-interval".equals(fieldName)) {
                        pollingDetails.pollInterval = reader.getString();
                    } else {
                        reader.skipChildren();
                    }
                }

                return pollingDetails;
            });
        }
    }

    private final Map<String, PollingDetails> pollingConfig;

    /**
     * Gets the polling configuration for the specified operation.
     *
     * @param operation The operation name.
     * @return The polling configuration for the specified operation, or the default polling configuration if no
     * configuration is specified for the operation.
     */
    public PollingDetails getPollingConfig(String operation) {
        if (pollingConfig == null) {
            return null;
        }
        for (String key : pollingConfig.keySet()) {
            if (key.equalsIgnoreCase(operation)) {
                return pollingConfig.get(key);
            }
        }
        return pollingConfig.get("default");
    }

    private final boolean annotateGettersAndSettersForSerialization;

    /**
     * Whether model getters and setters should be annotated with Jackson JsonGetter and JsonSetter to handle
     * serialization.
     * <p>
     * For now, Fields will continue to be annotated with JsonProperty to ensure there are no backwards compatibility
     * breaking changes.
     *
     * @return Whether model getters and setters should be annotated to handle serialization.
     */
    public boolean isGettersAndSettersAnnotatedForSerialization() {
        return annotateGettersAndSettersForSerialization;
    }

    private final String defaultHttpExceptionType;

    /**
     * Gets the fully-qualified exception type that is used for error HTTP status codes.
     *
     * @return The fully-qualified exception type.
     */
    public String getDefaultHttpExceptionType() {
        return defaultHttpExceptionType;
    }

    private final boolean useDefaultHttpStatusCodeToExceptionTypeMapping;

    /**
     * Whether to use the default error HTTP status code to exception type mapping.
     *
     * @return Whether to use the default error HTTP status code to exception type mapping.
     */
    public boolean isUseDefaultHttpStatusCodeToExceptionTypeMapping() {
        return useDefaultHttpStatusCodeToExceptionTypeMapping;
    }

    private final Map<Integer, String> httpStatusCodeToExceptionTypeMapping;

    /**
     * Gets a read-only view of the custom error HTTP status code to exception type mapping.
     *
     * @return A read-only view of the custom error HTTP status code to exception type mapping.
     */
    public Map<Integer, String> getHttpStatusCodeToExceptionTypeMapping() {
        return httpStatusCodeToExceptionTypeMapping == null
            ? null : Collections.unmodifiableMap(httpStatusCodeToExceptionTypeMapping);
    }

    private final boolean generateBuilderPerClient;

    /**
     * Whether a builder will be generated for each client.
     *
     * @return Whether a builder will be generated for each client.
     */
    public boolean isGenerateBuilderPerClient() {
        return generateBuilderPerClient;
    }

    private final boolean handlePartialUpdate;

    /**
     * Whether partial updates are handled.
     *
     * @return Whether partial updates are handled.
     */
    public boolean isHandlePartialUpdate() {
        return handlePartialUpdate;
    }

    private final boolean genericResponseTypes;

    /**
     * Whether Response, ResponseBase, PagedResponse, or PagedResponseBase will be used directly with generics instead
     * of creating a named type that extends one of those type.
     *
     * @return Whether generic response types are used instead of named types that extend the generic type.
     */
    public boolean isGenericResponseTypes() {
        return genericResponseTypes;
    }

    private final boolean streamStyleSerialization;

    /**
     * Whether models will handle serialization themselves using stream-style serialization instead of relying on
     * Jackson Databind.
     *
     * @return Whether models will handle serialization themselves.
     */
    public boolean isStreamStyleSerialization() {
        return streamStyleSerialization;
    }

    private final boolean isInputStreamForBinary;

    /**
     * Whether to use <code>InputStream</code> for binary in response body.
     *
     * @return If true, return <code>InputStream</code> for binary in response body. If false, return
     * <code>BinaryData</code>.
     */
    public boolean isInputStreamForBinary() {
        return isInputStreamForBinary;
    }

    private final boolean includeReadOnlyInConstructorArgs;

    /**
     * Whether required read-only properties will be included in constructor arguments.
     * <p>
     * In the past, required read-only properties were included in constructor arguments when
     * {@link #isRequiredFieldsAsConstructorArgs()} was true. This flag re-enables that capability when the property is
     * required and read-only and {@link #isRequiredFieldsAsConstructorArgs()} is true.
     * <p>
     * If this returns true but {@link #isRequiredFieldsAsConstructorArgs()} returns false this configuration does
     * nothing.
     *
     * @return Whether required read-only properties will be included in constructor arguments.
     */
    public boolean isIncludeReadOnlyInConstructorArgs() {
        return includeReadOnlyInConstructorArgs;
    }

    /**
     * Whether to use key credential for authentication.
     *
     * @return Whether to use key credential for authentication.
     */
    public boolean isUseKeyCredential() {
        return this.useKeyCredential;
    }

    private final boolean nullByteArrayMapsToEmptyArray;

    /**
     * Whether {@code ArrayType.BYTE_ARRAY} will return an empty array instead of null when the default value expression
     * is null.
     * <p>
     * Set this to true to ensure backwards compatibility with previous versions of the Java generator.
     *
     * @return Whether {@code ArrayType.BYTE_ARRAY} will return an empty array instead of null when the default value
     * expression is null.
     */
    public boolean isNullByteArrayMapsToEmptyArray() {
        return nullByteArrayMapsToEmptyArray;
    }

    /**
     * Determines whether REST API methods returning typed headers will be generated.
     * <p>
     * If set to true, {@link #isNoCustomHeaders()} and {@link #isGenericResponseTypes()} will be ignored as no REST
     * APIs returning typed headers will be generated. Meaning overloads without typed headers won't be generated and
     * since no methods with typed headers will exist there won't be usage of {@code ResponseBase}, or named subtypes of
     * it.
     * <p>
     * No matter the value, typed header classes will be generated. This can be useful if a majority of API calls don't
     * returned the typed headers at all but there are still cases where it would be useful to have them. Typed header
     * classes are simply created with {@code HttpHeaders} from {@code azure-core}.
     *
     * @return Whether REST APIs including typed headers should be generated.
     */
    public boolean isDisableTypedHeadersMethods() {
        return disableTypedHeadersMethods;
    }

    private static final String DEFAULT_CODE_GENERATION_HEADER = String.join("\n",
        "Code generated by Microsoft (R) AutoRest Code Generator %s",
        "Changes may cause incorrect behavior and will be lost if the code is regenerated.");

    private static final String DEFAULT_CODE_GENERATION_HEADER_WITHOUT_VERSION = String.join("\n",
        "Code generated by Microsoft (R) AutoRest Code Generator.",
        "Changes may cause incorrect behavior and will be lost if the code is regenerated.");

    private static final String MICROSOFT_APACHE_LICENSE_HEADER = String.join("\n",
        "Copyright (c) Microsoft and contributors.  All rights reserved.\n",
        "Licensed under the Apache License, Version 2.0 (the \"License\");",
        "you may not use this file except in compliance with the License.",
        "You may obtain a copy of the License at",
        "  https://www.apache.org/licenses/LICENSE-2.0\n",
        "Unless required by applicable law or agreed to in writing, software",
        "distributed under the License is distributed on an \"AS IS\" BASIS,",
        "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
        "See the License for the specific language governing permissions and",
        "limitations under the License.",
        "");

    private static final String MICROSOFT_MIT_LICENSE_HEADER = String.join("\n",
        "Copyright (c) Microsoft Corporation. All rights reserved.",
        "Licensed under the MIT License. See License.txt in the project root for license information.",
        "");

    private static final String MICROSOFT_MIT_SMALL_LICENSE_HEADER = String.join("\n",
        "Copyright (c) Microsoft Corporation. All rights reserved.",
        "Licensed under the MIT License.",
        "");

    private static void loadStringSetting(String settingName, Consumer<String> action) {
        String settingValue = host.getStringValue(settingName);
        if (settingValue != null) {
            logger.debug("Option, string, {} : {}", settingName, settingValue);
            action.accept(settingValue);
        }
    }

    private static String getStringValue(NewPlugin host, String settingName) {
        return getStringValue(host, settingName, null);
    }

    private static String getStringValue(NewPlugin host, String settingName, String defaultValue) {
        String ret = host.getStringValue(settingName);
        if (ret == null) {
            return defaultValue;
        } else {
            logger.debug("Option, string, {} : {}", settingName, ret);
            SIMPLE_JAVA_SETTINGS.put(settingName, ret);
            return ret;
        }
    }

    private static boolean getBooleanValue(NewPlugin host, String settingName, boolean defaultValue) {
        Boolean ret = host.getBooleanValue(settingName);
        if (ret == null) {
            return defaultValue;
        } else {
            logger.debug("Option, boolean, {} : {}", settingName, ret);
            SIMPLE_JAVA_SETTINGS.put(settingName, ret);
            return ret;
        }
    }

    private static void loadStringOrArraySettingAsArray(String settingName, Consumer<List<String>> action) {
        host.getValue(settingName, jsonString -> {
            if (jsonString == null) {
                return null;
            } else if (jsonString.startsWith("[")) {
                // Array values will need to be parsed.
                try (JsonReader jsonReader = JsonProviders.createReader(jsonString)) {
                    List<String> settingValueList = jsonReader.readArray(JsonReader::getString);
                    logger.debug("Option, array, {} : {}", settingName, settingValueList);
                    action.accept(settingValueList);
                }
            } else {
                // Single values will be returned as the string representation.
                logger.debug("Option, string, {} : {}", settingName, jsonString);
                action.accept(Collections.singletonList(jsonString));
            }

            return null;
        });
    }
}
