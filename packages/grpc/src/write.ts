import {
  matchType,
  ProtoDeclaration,
  ProtoEnumDeclaration,
  ProtoFieldDeclaration,
  ProtoFile,
  ProtoMessageDeclaration,
  ProtoMethodDeclaration,
  ProtoOneOfDeclaration,
  ProtoServiceDeclaration,
  ProtoType,
} from "./proto.js";

// This module defines how to emit the text representation of a ProtoFile AST.

export const PROTO_HEADER =
  '/* Generated by Microsoft CADL - Canonical API Definition Language */\n\nsyntax = "proto3";\n';

export function writeProtoFile(file: ProtoFile): string {
  let result = PROTO_HEADER;

  if (file.package) result += `\npackage ${file.package};\n`;

  const opts = Object.entries(file.options);
  for (const [name, valueData] of opts) {
    const value = typeof valueData === "string" ? `"${valueData}"` : valueData.toString();
    result += `\noption (${name}) = ${value}`;
  }

  // Give the declarations a little breathing room if options were provided
  if (opts.length > 0) result += "\n";

  for (const decl of file.declarations) {
    result += "\n" + collect(writeDeclaration(decl)).join("\n") + "\n";
  }

  return result;
}

function* writeDeclaration(decl: ProtoDeclaration): Iterable<string> {
  switch (decl.kind) {
    case "message":
      yield* writeMessage(decl);
      return;
    case "service":
      yield* writeService(decl);
      return;
    case "field":
      yield writeField(decl);
      return;
    case "oneof":
      yield* writeOneOf(decl);
      return;
    case "enum":
      yield* writeEnum(decl);
      return;
    case "method":
      yield writeMethod(decl);
      return;
    default:
      const __exhaust: never = decl;
      throw __exhaust;
  }
}

function* writeMessage(decl: ProtoMessageDeclaration): Iterable<string> {
  const head = `message ${decl.name} {`;
  const tail = "}";

  if (decl.declarations.length > 0 || decl.reservations?.length) {
    const { reservedNumbers, reservedNames } = selectMap(
      decl.reservations ?? [],
      (v) => (typeof v === "number" || Array.isArray(v) ? "reservedNumbers" : "reservedNames"),
      {
        reservedNumbers: (v) => (Array.isArray(v) ? v[0] + " to " + v[1] : v.toString()),
        reservedNames: (v) => `"${v.toString()}"`,
      }
    );
    yield head;
    if (reservedNumbers.length + reservedNames.length > 0) {
      if (reservedNumbers.length > 0) yield `  reserved ${reservedNumbers.join(", ")};`;
      if (reservedNames.length > 0) yield `  reserved ${reservedNames.join(", ")};`;
      yield "";
    }
    yield* indent(flatMap(decl.declarations, writeDeclaration));
    yield tail;
  } else yield head + tail;
}

function* writeService(decl: ProtoServiceDeclaration): Iterable<string> {
  const head = `service ${decl.name} {`;
  const tail = "}";

  if (decl.operations.length > 0) {
    yield head;
    yield* indent(flatMap(decl.operations, writeMethod));
    yield tail;
  } else yield head + tail;
}

function writeMethod(decl: ProtoMethodDeclaration): string {
  return `rpc ${decl.name} (${writeType(decl.input)}) returns (${writeType(decl.returns)});`;
}

function* writeOneOf(decl: ProtoOneOfDeclaration): Iterable<string> {
  // OneOf declarations must have at least one element, so no need to check for declarations
  yield `oneof ${decl.name} {`;
  yield* indent(flatMap(decl.declarations, writeDeclaration));
  yield "}";
}

function* writeEnum(decl: ProtoEnumDeclaration): Iterable<string> {
  yield `enum ${decl.name} {`;
  yield* indent(flatMap(decl.variants, ([name, idx]) => `${name} = ${idx};`));
  yield "}";
}

function writeField(decl: ProtoFieldDeclaration): string {
  const prefix = decl.repeated ? "repeated " : "";
  return prefix + `${writeType(decl.type)} ${decl.name} = ${decl.index};`;
}

function writeType(type: ProtoType): string {
  return matchType(type, {
    map: (k, v) => `map<${k}, ${writeType(v)}>`,
    ref: (r) => r,
    scalar: (s) => s,
  });
}

// #region utils

function* indent(it: Iterable<string>, depth: number = 2): Iterable<string> {
  for (const value of it) {
    yield " ".repeat(depth) + value;
  }
}

function* flatMap<T1, T2>(it: Iterable<T1>, f: (v: T1) => T2 | Iterable<T2>): Iterable<T2> {
  for (const value of it) {
    const result = f(value);
    if (typeof result === "object" && result !== null && Symbol.iterator in result) {
      yield* result as Iterable<T2>;
    } else {
      yield result as T2;
    }
  }
}

function collect<T>(it: Iterable<T>): T[] {
  const result = [];

  for (const value of it) result.push(value);

  return result;
}

function selectMap<TIn, Delegates extends { [k: string]: (input: TIn) => unknown }>(
  source: Iterable<TIn>,
  select: (v: TIn) => keyof Delegates,
  delegates: Delegates
) {
  const result = Object.fromEntries(Object.keys(delegates).map((k) => [k, []])) as unknown as {
    [K in keyof Delegates]: ReturnType<Delegates[K]>[];
  };
  for (const value of source) {
    const k = select(value);
    result[k].push(delegates[k](value) as any);
  }

  return result;
}

// #endregion
