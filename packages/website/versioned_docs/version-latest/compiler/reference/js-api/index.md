JS Api

# JS Api

## Table of contents

### Namespaces

- [decorators](modules/decorators.md)

### Enumerations

- [IdentifierKind](enums/IdentifierKind.md)
- [KeywordLimit](enums/KeywordLimit.md)
- [ListenerFlow](enums/ListenerFlow.md)
- [ModifierFlags](enums/ModifierFlags.md)
- [NodeFlags](enums/NodeFlags.md)
- [SemanticTokenKind](enums/SemanticTokenKind.md)
- [SymbolFlags](enums/SymbolFlags.md)
- [SyntaxKind](enums/SyntaxKind.md)
- [Token](enums/Token.md)
- [TokenFlags](enums/TokenFlags.md)
- [UsageFlags](enums/UsageFlags.md)

### Classes

- [DuplicateTracker](classes/DuplicateTracker.md)
- [EventEmitter](classes/EventEmitter.md)
- [ProjectionError](classes/ProjectionError.md)
- [Queue](classes/Queue.md)
- [ResolveModuleError](classes/ResolveModuleError.md)
- [TwoLevelMap](classes/TwoLevelMap.md)

### Interfaces

- [AliasStatementNode](interfaces/AliasStatementNode.md)
- [AnyKeywordNode](interfaces/AnyKeywordNode.md)
- [ArrayExpressionNode](interfaces/ArrayExpressionNode.md)
- [ArrayModelType](interfaces/ArrayModelType.md)
- [AugmentDecoratorStatementNode](interfaces/AugmentDecoratorStatementNode.md)
- [BaseNode](interfaces/BaseNode.md)
- [BaseType](interfaces/BaseType.md)
- [BlockComment](interfaces/BlockComment.md)
- [BooleanLiteral](interfaces/BooleanLiteral.md)
- [BooleanLiteralNode](interfaces/BooleanLiteralNode.md)
- [CallableMessage](interfaces/CallableMessage.md)
- [Checker](interfaces/Checker.md)
- [CompilerHost](interfaces/CompilerHost.md)
- [DeclarationNode](interfaces/DeclarationNode.md)
- [DecoratedType](interfaces/DecoratedType.md)
- [Decorator](interfaces/Decorator.md)
- [DecoratorApplication](interfaces/DecoratorApplication.md)
- [DecoratorArgument](interfaces/DecoratorArgument.md)
- [DecoratorContext](interfaces/DecoratorContext.md)
- [DecoratorDeclarationStatementNode](interfaces/DecoratorDeclarationStatementNode.md)
- [DecoratorDefinition](interfaces/DecoratorDefinition.md)
- [DecoratorExpressionNode](interfaces/DecoratorExpressionNode.md)
- [DecoratorFunction](interfaces/DecoratorFunction.md)
- [DecoratorParamDefinition](interfaces/DecoratorParamDefinition.md)
- [DecoratorValidator](interfaces/DecoratorValidator.md)
- [Diagnostic](interfaces/Diagnostic.md)
- [DiagnosticCollector](interfaces/DiagnosticCollector.md)
- [DiagnosticCreator](interfaces/DiagnosticCreator.md)
- [DiagnosticDefinition](interfaces/DiagnosticDefinition.md)
- [DiagnosticMessages](interfaces/DiagnosticMessages.md)
- [DirectiveBase](interfaces/DirectiveBase.md)
- [DirectiveExpressionNode](interfaces/DirectiveExpressionNode.md)
- [Dirent](interfaces/Dirent.md)
- [DiscriminatedUnion](interfaces/DiscriminatedUnion.md)
- [Discriminator](interfaces/Discriminator.md)
- [DocNode](interfaces/DocNode.md)
- [DocParamTagNode](interfaces/DocParamTagNode.md)
- [DocReturnsTagNode](interfaces/DocReturnsTagNode.md)
- [DocTagBaseNode](interfaces/DocTagBaseNode.md)
- [DocTemplateTagNode](interfaces/DocTemplateTagNode.md)
- [DocTextNode](interfaces/DocTextNode.md)
- [DocUnknownTagNode](interfaces/DocUnknownTagNode.md)
- [EmitContext](interfaces/EmitContext.md)
- [EmitFileOptions](interfaces/EmitFileOptions.md)
- [EmptyStatementNode](interfaces/EmptyStatementNode.md)
- [Enum](interfaces/Enum.md)
- [EnumMember](interfaces/EnumMember.md)
- [EnumMemberNode](interfaces/EnumMemberNode.md)
- [EnumSpreadMemberNode](interfaces/EnumSpreadMemberNode.md)
- [EnumStatementNode](interfaces/EnumStatementNode.md)
- [ErrorType](interfaces/ErrorType.md)
- [ExternKeywordNode](interfaces/ExternKeywordNode.md)
- [FunctionDeclarationStatementNode](interfaces/FunctionDeclarationStatementNode.md)
- [FunctionParameter](interfaces/FunctionParameter.md)
- [FunctionParameterNode](interfaces/FunctionParameterNode.md)
- [FunctionType](interfaces/FunctionType.md)
- [IdentifierContext](interfaces/IdentifierContext.md)
- [IdentifierNode](interfaces/IdentifierNode.md)
- [ImportStatementNode](interfaces/ImportStatementNode.md)
- [Interface](interfaces/Interface.md)
- [InterfaceStatementNode](interfaces/InterfaceStatementNode.md)
- [IntersectionExpressionNode](interfaces/IntersectionExpressionNode.md)
- [IntrinsicType](interfaces/IntrinsicType.md)
- [InvalidStatementNode](interfaces/InvalidStatementNode.md)
- [JSONSchemaValidator](interfaces/JSONSchemaValidator.md)
- [JsSourceFileNode](interfaces/JsSourceFileNode.md)
- [LineAndCharacter](interfaces/LineAndCharacter.md)
- [LineComment](interfaces/LineComment.md)
- [ListOperationOptions](interfaces/ListOperationOptions.md)
- [LogInfo](interfaces/LogInfo.md)
- [LogSink](interfaces/LogSink.md)
- [Logger](interfaces/Logger.md)
- [MemberExpressionNode](interfaces/MemberExpressionNode.md)
- [Model](interfaces/Model.md)
- [ModelExpressionNode](interfaces/ModelExpressionNode.md)
- [ModelProperty](interfaces/ModelProperty.md)
- [ModelPropertyNode](interfaces/ModelPropertyNode.md)
- [ModelSpreadPropertyNode](interfaces/ModelSpreadPropertyNode.md)
- [ModelStatementNode](interfaces/ModelStatementNode.md)
- [Namespace](interfaces/Namespace.md)
- [NamespaceNavigationOptions](interfaces/NamespaceNavigationOptions.md)
- [NamespaceStatementNode](interfaces/NamespaceStatementNode.md)
- [NavigationOptions](interfaces/NavigationOptions.md)
- [NeverKeywordNode](interfaces/NeverKeywordNode.md)
- [NeverType](interfaces/NeverType.md)
- [NodePackage](interfaces/NodePackage.md)
- [NullType](interfaces/NullType.md)
- [NumericLiteral](interfaces/NumericLiteral.md)
- [NumericLiteralNode](interfaces/NumericLiteralNode.md)
- [ObjectType](interfaces/ObjectType.md)
- [Operation](interfaces/Operation.md)
- [OperationSignatureDeclarationNode](interfaces/OperationSignatureDeclarationNode.md)
- [OperationSignatureReferenceNode](interfaces/OperationSignatureReferenceNode.md)
- [OperationStatementNode](interfaces/OperationStatementNode.md)
- [ParseOptions](interfaces/ParseOptions.md)
- [ProcessedLog](interfaces/ProcessedLog.md)
- [Program](interfaces/Program.md)
- [ProjectedNameView](interfaces/ProjectedNameView.md)
- [ProjectedProgram](interfaces/ProjectedProgram.md)
- [Projection](interfaces/Projection.md)
- [ProjectionApplication](interfaces/ProjectionApplication.md)
- [ProjectionArithmeticExpressionNode](interfaces/ProjectionArithmeticExpressionNode.md)
- [ProjectionBlockExpressionNode](interfaces/ProjectionBlockExpressionNode.md)
- [ProjectionCallExpressionNode](interfaces/ProjectionCallExpressionNode.md)
- [ProjectionDecoratorReferenceExpressionNode](interfaces/ProjectionDecoratorReferenceExpressionNode.md)
- [ProjectionEnumSelectorNode](interfaces/ProjectionEnumSelectorNode.md)
- [ProjectionEqualityExpressionNode](interfaces/ProjectionEqualityExpressionNode.md)
- [ProjectionExpressionStatementNode](interfaces/ProjectionExpressionStatementNode.md)
- [ProjectionIfExpressionNode](interfaces/ProjectionIfExpressionNode.md)
- [ProjectionInterfaceSelectorNode](interfaces/ProjectionInterfaceSelectorNode.md)
- [ProjectionLambdaExpressionNode](interfaces/ProjectionLambdaExpressionNode.md)
- [ProjectionLambdaParameterDeclarationNode](interfaces/ProjectionLambdaParameterDeclarationNode.md)
- [ProjectionLogicalExpressionNode](interfaces/ProjectionLogicalExpressionNode.md)
- [ProjectionMemberExpressionNode](interfaces/ProjectionMemberExpressionNode.md)
- [ProjectionModelExpressionNode](interfaces/ProjectionModelExpressionNode.md)
- [ProjectionModelPropertyNode](interfaces/ProjectionModelPropertyNode.md)
- [ProjectionModelSelectorNode](interfaces/ProjectionModelSelectorNode.md)
- [ProjectionModelSpreadPropertyNode](interfaces/ProjectionModelSpreadPropertyNode.md)
- [ProjectionNode](interfaces/ProjectionNode.md)
- [ProjectionOperationSelectorNode](interfaces/ProjectionOperationSelectorNode.md)
- [ProjectionParameterDeclarationNode](interfaces/ProjectionParameterDeclarationNode.md)
- [ProjectionReferenceNode](interfaces/ProjectionReferenceNode.md)
- [ProjectionRelationalExpressionNode](interfaces/ProjectionRelationalExpressionNode.md)
- [ProjectionStatementNode](interfaces/ProjectionStatementNode.md)
- [ProjectionTupleExpressionNode](interfaces/ProjectionTupleExpressionNode.md)
- [ProjectionUnaryExpressionNode](interfaces/ProjectionUnaryExpressionNode.md)
- [ProjectionUnionSelectorNode](interfaces/ProjectionUnionSelectorNode.md)
- [Projector](interfaces/Projector.md)
- [RecordModelType](interfaces/RecordModelType.md)
- [ResolveModuleHost](interfaces/ResolveModuleHost.md)
- [ResolveModuleOptions](interfaces/ResolveModuleOptions.md)
- [ResolvedFile](interfaces/ResolvedFile.md)
- [ResolvedModule](interfaces/ResolvedModule.md)
- [ReturnExpressionNode](interfaces/ReturnExpressionNode.md)
- [ReturnRecord](interfaces/ReturnRecord.md)
- [RmOptions](interfaces/RmOptions.md)
- [Scalar](interfaces/Scalar.md)
- [ScalarStatementNode](interfaces/ScalarStatementNode.md)
- [Scanner](interfaces/Scanner.md)
- [SemanticToken](interfaces/SemanticToken.md)
- [Server](interfaces/Server.md)
- [ServerHost](interfaces/ServerHost.md)
- [ServerSourceFile](interfaces/ServerSourceFile.md)
- [ServerWorkspaceFolder](interfaces/ServerWorkspaceFolder.md)
- [Service](interfaces/Service.md)
- [ServiceDetails](interfaces/ServiceDetails.md)
- [SourceFile](interfaces/SourceFile.md)
- [SourceLocation](interfaces/SourceLocation.md)
- [StringLiteral](interfaces/StringLiteral.md)
- [StringLiteralNode](interfaces/StringLiteralNode.md)
- [SuppressDirective](interfaces/SuppressDirective.md)
- [Sym](interfaces/Sym.md)
- [SymbolLinks](interfaces/SymbolLinks.md)
- [SymbolTable](interfaces/SymbolTable.md)
- [TemplateDeclarationNode](interfaces/TemplateDeclarationNode.md)
- [TemplateParameter](interfaces/TemplateParameter.md)
- [TemplateParameterDeclarationNode](interfaces/TemplateParameterDeclarationNode.md)
- [TemplatedTypeBase](interfaces/TemplatedTypeBase.md)
- [TextRange](interfaces/TextRange.md)
- [Tracer](interfaces/Tracer.md)
- [TracerOptions](interfaces/TracerOptions.md)
- [Tuple](interfaces/Tuple.md)
- [TupleExpressionNode](interfaces/TupleExpressionNode.md)
- [TypeInstantiationMap](interfaces/TypeInstantiationMap.md)
- [TypeMapper](interfaces/TypeMapper.md)
- [TypeNameOptions](interfaces/TypeNameOptions.md)
- [TypeReferenceNode](interfaces/TypeReferenceNode.md)
- [TypeSpecCompletionItem](interfaces/TypeSpecCompletionItem.md)
- [TypeSpecLibrary](interfaces/TypeSpecLibrary.md)
- [TypeSpecLibraryDef](interfaces/TypeSpecLibraryDef.md)
- [TypeSpecManifest](interfaces/TypeSpecManifest.md)
- [TypeSpecScriptNode](interfaces/TypeSpecScriptNode.md)
- [Union](interfaces/Union.md)
- [UnionExpressionNode](interfaces/UnionExpressionNode.md)
- [UnionStatementNode](interfaces/UnionStatementNode.md)
- [UnionVariant](interfaces/UnionVariant.md)
- [UnionVariantNode](interfaces/UnionVariantNode.md)
- [UnknownType](interfaces/UnknownType.md)
- [UsageTracker](interfaces/UsageTracker.md)
- [UsingStatementNode](interfaces/UsingStatementNode.md)
- [VoidKeywordNode](interfaces/VoidKeywordNode.md)
- [VoidType](interfaces/VoidType.md)

### Type Aliases

- [CadlCompletionItem](index.md#cadlcompletionitem)
- [CadlLibrary](index.md#cadllibrary)
- [CadlLibraryDef](index.md#cadllibrarydef)
- [CadlManifest](index.md#cadlmanifest)
- [CadlScriptNode](index.md#cadlscriptnode)
- [CadlValue](index.md#cadlvalue)
- [Comment](index.md#comment)
- [Declaration](index.md#declaration)
- [DecoratorArgumentValue](index.md#decoratorargumentvalue)
- [DiagnosticFormat](index.md#diagnosticformat)
- [DiagnosticHandler](index.md#diagnostichandler)
- [DiagnosticMap](index.md#diagnosticmap)
- [DiagnosticReport](index.md#diagnosticreport)
- [DiagnosticReportWithoutTarget](index.md#diagnosticreportwithouttarget)
- [DiagnosticResult](index.md#diagnosticresult)
- [DiagnosticSeverity](index.md#diagnosticseverity)
- [DiagnosticTarget](index.md#diagnostictarget)
- [Directive](index.md#directive)
- [DirectiveArgument](index.md#directiveargument)
- [DocContent](index.md#doccontent)
- [DocTag](index.md#doctag)
- [DocToken](index.md#doctoken)
- [EmitOptionsFor](index.md#emitoptionsfor)
- [EmitterFunc](index.md#emitterfunc)
- [Expression](index.md#expression)
- [InferredCadlValue](index.md#inferredcadlvalue)
- [InferredTypeSpecValue](index.md#inferredtypespecvalue)
- [IntrinsicScalarName](index.md#intrinsicscalarname)
- [JSONSchemaType](index.md#jsonschematype)
- [LiteralNode](index.md#literalnode)
- [LiteralType](index.md#literaltype)
- [LogLevel](index.md#loglevel)
- [MarshalledValue](index.md#marshalledvalue)
- [MemberContainerNode](index.md#membercontainernode)
- [MemberContainerType](index.md#membercontainertype)
- [MemberNode](index.md#membernode)
- [MemberType](index.md#membertype)
- [ModelIndexer](index.md#modelindexer)
- [Modifier](index.md#modifier)
- [ModuleResolutionResult](index.md#moduleresolutionresult)
- [NeverIndexer](index.md#neverindexer)
- [NewLine](index.md#newline)
- [Node](index.md#node)
- [NodeCallback](index.md#nodecallback)
- [OperationContainer](index.md#operationcontainer)
- [OperationSignature](index.md#operationsignature)
- [ProjectionExpression](index.md#projectionexpression)
- [ProjectionStatementItem](index.md#projectionstatementitem)
- [ReferenceExpression](index.md#referenceexpression)
- [ScopeNode](index.md#scopenode)
- [SemanticNodeListener](index.md#semanticnodelistener)
- [SourceFileKind](index.md#sourcefilekind)
- [Statement](index.md#statement)
- [TemplateableNode](index.md#templateablenode)
- [TemplatedType](index.md#templatedtype)
- [TrackableType](index.md#trackabletype)
- [Type](index.md#type)
- [TypeKind](index.md#typekind)
- [TypeListeners](index.md#typelisteners)
- [TypeOfDiagnostics](index.md#typeofdiagnostics)
- [TypeOrReturnRecord](index.md#typeorreturnrecord)
- [TypeSpecValue](index.md#typespecvalue)
- [WriteLine](index.md#writeline)

### Variables

- [CadlLanguageConfiguration](index.md#cadllanguageconfiguration)
- [CadlPrettierPlugin](index.md#cadlprettierplugin)
- [Keywords](index.md#keywords)
- [MANIFEST](index.md#manifest)
- [NoTarget](index.md#notarget)
- [NodeHost](index.md#nodehost)
- [TokenDisplay](index.md#tokendisplay)
- [TypeSpecLanguageConfiguration](index.md#typespeclanguageconfiguration)
- [TypeSpecPrettierPlugin](index.md#typespecprettierplugin)
- [altDirectorySeparator](index.md#altdirectoryseparator)
- [cadlVersion](index.md#cadlversion)
- [directorySeparator](index.md#directoryseparator)
- [namespace](index.md#namespace)
- [typespecVersion](index.md#typespecversion)

### Functions

- [$deprecated](index.md#$deprecated)
- [$discriminator](index.md#$discriminator)
- [$doc](index.md#$doc)
- [$error](index.md#$error)
- [$format](index.md#$format)
- [$friendlyName](index.md#$friendlyname)
- [$indexer](index.md#$indexer)
- [$inspectType](index.md#$inspecttype)
- [$inspectTypeName](index.md#$inspecttypename)
- [$key](index.md#$key)
- [$knownValues](index.md#$knownvalues)
- [$list](index.md#$list)
- [$maxItems](index.md#$maxitems)
- [$maxLength](index.md#$maxlength)
- [$maxValue](index.md#$maxvalue)
- [$maxValueExclusive](index.md#$maxvalueexclusive)
- [$minItems](index.md#$minitems)
- [$minLength](index.md#$minlength)
- [$minValue](index.md#$minvalue)
- [$minValueExclusive](index.md#$minvalueexclusive)
- [$overload](index.md#$overload)
- [$pattern](index.md#$pattern)
- [$projectedName](index.md#$projectedname)
- [$secret](index.md#$secret)
- [$service](index.md#$service)
- [$summary](index.md#$summary)
- [$tag](index.md#$tag)
- [$visibility](index.md#$visibility)
- [$withDefaultKeyVisibility](index.md#$withdefaultkeyvisibility)
- [$withOptionalProperties](index.md#$withoptionalproperties)
- [$withUpdateableProperties](index.md#$withupdateableproperties)
- [$withVisibility](index.md#$withvisibility)
- [$withoutDefaultValues](index.md#$withoutdefaultvalues)
- [$withoutOmittedProperties](index.md#$withoutomittedproperties)
- [addService](index.md#addservice)
- [assertType](index.md#asserttype)
- [cadlTypeToJson](index.md#cadltypetojson)
- [checkFormatCadl](index.md#checkformatcadl)
- [checkFormatTypeSpec](index.md#checkformattypespec)
- [compile](index.md#compile)
- [compilerAssert](index.md#compilerassert)
- [createCadlLibrary](index.md#createcadllibrary)
- [createChecker](index.md#createchecker)
- [createDecoratorDefinition](index.md#createdecoratordefinition)
- [createDiagnosticCollector](index.md#creatediagnosticcollector)
- [createDiagnosticCreator](index.md#creatediagnosticcreator)
- [createProjectedNameProgram](index.md#createprojectednameprogram)
- [createScanner](index.md#createscanner)
- [createServer](index.md#createserver)
- [createSourceFile](index.md#createsourcefile)
- [createStateAccessors](index.md#createstateaccessors)
- [createTypeSpecLibrary](index.md#createtypespeclibrary)
- [emitFile](index.md#emitfile)
- [ensureTrailingDirectorySeparator](index.md#ensuretrailingdirectoryseparator)
- [filterModelProperties](index.md#filtermodelproperties)
- [finishTypeForProgram](index.md#finishtypeforprogram)
- [formatDiagnostic](index.md#formatdiagnostic)
- [formatIdentifier](index.md#formatidentifier)
- [formatTypeSpec](index.md#formattypespec)
- [getAllTags](index.md#getalltags)
- [getAnyExtensionFromPath](index.md#getanyextensionfrompath)
- [getBaseFileName](index.md#getbasefilename)
- [getCompletionNodeAtPosition](index.md#getcompletionnodeatposition)
- [getDeprecated](index.md#getdeprecated)
- [getDirectoryPath](index.md#getdirectorypath)
- [getDiscriminatedTypes](index.md#getdiscriminatedtypes)
- [getDiscriminatedUnion](index.md#getdiscriminatedunion)
- [getDiscriminator](index.md#getdiscriminator)
- [getDoc](index.md#getdoc)
- [getEffectiveModelType](index.md#geteffectivemodeltype)
- [getFirstAncestor](index.md#getfirstancestor)
- [getFormat](index.md#getformat)
- [getFriendlyName](index.md#getfriendlyname)
- [getIdentifierContext](index.md#getidentifiercontext)
- [getIndexer](index.md#getindexer)
- [getKeyName](index.md#getkeyname)
- [getKnownValues](index.md#getknownvalues)
- [getListOperationType](index.md#getlistoperationtype)
- [getMaxItems](index.md#getmaxitems)
- [getMaxLength](index.md#getmaxlength)
- [getMaxValue](index.md#getmaxvalue)
- [getMaxValueExclusive](index.md#getmaxvalueexclusive)
- [getMinItems](index.md#getminitems)
- [getMinLength](index.md#getminlength)
- [getMinValue](index.md#getminvalue)
- [getMinValueExclusive](index.md#getminvalueexclusive)
- [getNamespaceFullName](index.md#getnamespacefullname)
- [getNodeAtPosition](index.md#getnodeatposition)
- [getNormalizedAbsolutePath](index.md#getnormalizedabsolutepath)
- [getNormalizedAbsolutePathWithoutRoot](index.md#getnormalizedabsolutepathwithoutroot)
- [getNormalizedPathComponents](index.md#getnormalizedpathcomponents)
- [getOverloadedOperation](index.md#getoverloadedoperation)
- [getOverloads](index.md#getoverloads)
- [getOverriddenProperty](index.md#getoverriddenproperty)
- [getParentTemplateNode](index.md#getparenttemplatenode)
- [getPathComponents](index.md#getpathcomponents)
- [getPathFromPathComponents](index.md#getpathfrompathcomponents)
- [getPattern](index.md#getpattern)
- [getProjectedName](index.md#getprojectedname)
- [getProjectedNames](index.md#getprojectednames)
- [getProperty](index.md#getproperty)
- [getPropertyType](index.md#getpropertytype)
- [getRootLength](index.md#getrootlength)
- [getService](index.md#getservice)
- [getSourceFileKindFromExt](index.md#getsourcefilekindfromext)
- [getSourceLocation](index.md#getsourcelocation)
- [getSummary](index.md#getsummary)
- [getTags](index.md#gettags)
- [getTypeName](index.md#gettypename)
- [getVisibility](index.md#getvisibility)
- [hasParseError](index.md#hasparseerror)
- [hasProjectedName](index.md#hasprojectedname)
- [hasTrailingDirectorySeparator](index.md#hastrailingdirectoryseparator)
- [ignoreDiagnostics](index.md#ignorediagnostics)
- [isAnyDirectorySeparator](index.md#isanydirectoryseparator)
- [isArrayModelType](index.md#isarraymodeltype)
- [isCadlValueTypeOf](index.md#iscadlvaluetypeof)
- [isComment](index.md#iscomment)
- [isDeclaredInNamespace](index.md#isdeclaredinnamespace)
- [isDeprecated](index.md#isdeprecated)
- [isErrorModel](index.md#iserrormodel)
- [isErrorType](index.md#iserrortype)
- [isGlobalNamespace](index.md#isglobalnamespace)
- [isImportStatement](index.md#isimportstatement)
- [isKey](index.md#iskey)
- [isKeyword](index.md#iskeyword)
- [isListOperation](index.md#islistoperation)
- [isModifier](index.md#ismodifier)
- [isNeverType](index.md#isnevertype)
- [isNullType](index.md#isnulltype)
- [isNumericType](index.md#isnumerictype)
- [isPathAbsolute](index.md#ispathabsolute)
- [isProjectedProgram](index.md#isprojectedprogram)
- [isPunctuation](index.md#ispunctuation)
- [isRecordModelType](index.md#isrecordmodeltype)
- [isSecret](index.md#issecret)
- [isService](index.md#isservice)
- [isStatementKeyword](index.md#isstatementkeyword)
- [isStringType](index.md#isstringtype)
- [isTemplateDeclaration](index.md#istemplatedeclaration)
- [isTemplateDeclarationOrInstance](index.md#istemplatedeclarationorinstance)
- [isTemplateInstance](index.md#istemplateinstance)
- [isTrivia](index.md#istrivia)
- [isTypeSpecValueTypeOf](index.md#istypespecvaluetypeof)
- [isUnknownType](index.md#isunknowntype)
- [isUrl](index.md#isurl)
- [isVisible](index.md#isvisible)
- [isVoidType](index.md#isvoidtype)
- [joinPaths](index.md#joinpaths)
- [listOperationsIn](index.md#listoperationsin)
- [listServices](index.md#listservices)
- [logDiagnostics](index.md#logdiagnostics)
- [logVerboseTestOutput](index.md#logverbosetestoutput)
- [mapEventEmitterToNodeListener](index.md#mapeventemittertonodelistener)
- [navigateProgram](index.md#navigateprogram)
- [navigateType](index.md#navigatetype)
- [navigateTypesInNamespace](index.md#navigatetypesinnamespace)
- [normalizePath](index.md#normalizepath)
- [normalizeSlashes](index.md#normalizeslashes)
- [paramMessage](index.md#parammessage)
- [parse](index.md#parse)
- [parseStandaloneTypeReference](index.md#parsestandalonetypereference)
- [projectProgram](index.md#projectprogram)
- [reducePathComponents](index.md#reducepathcomponents)
- [removeTrailingDirectorySeparator](index.md#removetrailingdirectoryseparator)
- [reportDeprecated](index.md#reportdeprecated)
- [resolveModule](index.md#resolvemodule)
- [resolvePath](index.md#resolvepath)
- [resolveUsages](index.md#resolveusages)
- [scopeNavigationToNamespace](index.md#scopenavigationtonamespace)
- [setCadlNamespace](index.md#setcadlnamespace)
- [setTypeSpecNamespace](index.md#settypespecnamespace)
- [skipTrivia](index.md#skiptrivia)
- [skipWhiteSpace](index.md#skipwhitespace)
- [typespecTypeToJson](index.md#typespectypetojson)
- [validateDecoratorNotOnType](index.md#validatedecoratornotontype)
- [validateDecoratorParamCount](index.md#validatedecoratorparamcount)
- [validateDecoratorParamType](index.md#validatedecoratorparamtype)
- [validateDecoratorTarget](index.md#validatedecoratortarget)
- [validateDecoratorTargetIntrinsic](index.md#validatedecoratortargetintrinsic)
- [validateDecoratorUniqueOnNode](index.md#validatedecoratoruniqueonnode)
- [visitChildren](index.md#visitchildren)
- [walkPropertiesInherited](index.md#walkpropertiesinherited)

## Type Aliases

### CadlCompletionItem

Ƭ **CadlCompletionItem**: [`TypeSpecCompletionItem`](interfaces/TypeSpecCompletionItem.md)

**`Deprecated`**

Use TypeSpecCompletionItem

___

### CadlLibrary

Ƭ **CadlLibrary**<`T`, `E`\>: [`TypeSpecLibrary`](interfaces/TypeSpecLibrary.md)<`T`, `E`\>

**`Deprecated`**

Use TypeSpecLibrary

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends `Object` |
| `E` | extends `Record`<`string`, `any`\> = `Record`<`string`, `never`\> |

___

### CadlLibraryDef

Ƭ **CadlLibraryDef**<`T`, `E`\>: [`TypeSpecLibraryDef`](interfaces/TypeSpecLibraryDef.md)<`T`, `E`\>

**`Deprecated`**

Use TypeSpecLibraryDef

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends `Object` |
| `E` | extends `Record`<`string`, `any`\> = `Record`<`string`, `never`\> |

___

### CadlManifest

Ƭ **CadlManifest**: [`TypeSpecManifest`](interfaces/TypeSpecManifest.md)

**`Deprecated`**

Use TypeSpecManifest

___

### CadlScriptNode

Ƭ **CadlScriptNode**: [`TypeSpecScriptNode`](interfaces/TypeSpecScriptNode.md)

**`Deprecated`**

Use TypeSpecScriptNode

___

### CadlValue

Ƭ **CadlValue**: [`TypeSpecValue`](index.md#typespecvalue)

**`Deprecated`**

Use TypeSpecValue

___

### Comment

Ƭ **Comment**: [`LineComment`](interfaces/LineComment.md) \| [`BlockComment`](interfaces/BlockComment.md)

___

### Declaration

Ƭ **Declaration**: [`ModelStatementNode`](interfaces/ModelStatementNode.md) \| [`ScalarStatementNode`](interfaces/ScalarStatementNode.md) \| [`InterfaceStatementNode`](interfaces/InterfaceStatementNode.md) \| [`UnionStatementNode`](interfaces/UnionStatementNode.md) \| [`NamespaceStatementNode`](interfaces/NamespaceStatementNode.md) \| [`OperationStatementNode`](interfaces/OperationStatementNode.md) \| [`TemplateParameterDeclarationNode`](interfaces/TemplateParameterDeclarationNode.md) \| [`ProjectionStatementNode`](interfaces/ProjectionStatementNode.md) \| [`ProjectionParameterDeclarationNode`](interfaces/ProjectionParameterDeclarationNode.md) \| [`ProjectionLambdaParameterDeclarationNode`](interfaces/ProjectionLambdaParameterDeclarationNode.md) \| [`EnumStatementNode`](interfaces/EnumStatementNode.md) \| [`AliasStatementNode`](interfaces/AliasStatementNode.md) \| [`DecoratorDeclarationStatementNode`](interfaces/DecoratorDeclarationStatementNode.md) \| [`FunctionDeclarationStatementNode`](interfaces/FunctionDeclarationStatementNode.md)

___

### DecoratorArgumentValue

Ƭ **DecoratorArgumentValue**: [`Type`](index.md#type) \| `number` \| `string` \| `boolean`

Type System types

___

### DiagnosticFormat

Ƭ **DiagnosticFormat**<`T`, `C`, `M`\>: `T`[`C`][`M`] extends [`CallableMessage`](interfaces/CallableMessage.md)<infer A\> ? { `format`: `Record`<`A`[`number`], `string`\>  } : `Record`<`string`, `unknown`\>

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends `Object` |
| `C` | extends keyof `T` |
| `M` | extends keyof `T`[`C`] = ``"default"`` |

___

### DiagnosticHandler

Ƭ **DiagnosticHandler**: (`diagnostic`: [`Diagnostic`](interfaces/Diagnostic.md)) => `void`

#### Type declaration

▸ (`diagnostic`): `void`

##### Parameters

| Name | Type |
| :------ | :------ |
| `diagnostic` | [`Diagnostic`](interfaces/Diagnostic.md) |

##### Returns

`void`

___

### DiagnosticMap

Ƭ **DiagnosticMap**<`T`\>: { readonly [code in keyof T]: DiagnosticDefinition<T[code]\> }

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends `Object` |

___

### DiagnosticReport

Ƭ **DiagnosticReport**<`T`, `C`, `M`\>: [`DiagnosticReportWithoutTarget`](index.md#diagnosticreportwithouttarget)<`T`, `C`, `M`\> & { `target`: [`DiagnosticTarget`](index.md#diagnostictarget) \| typeof [`NoTarget`](index.md#notarget)  }

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends `Object` |
| `C` | extends keyof `T` |
| `M` | extends keyof `T`[`C`] = ``"default"`` |

___

### DiagnosticReportWithoutTarget

Ƭ **DiagnosticReportWithoutTarget**<`T`, `C`, `M`\>: { `code`: `C` ; `messageId?`: `M`  } & [`DiagnosticFormat`](index.md#diagnosticformat)<`T`, `C`, `M`\>

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends `Object` |
| `C` | extends keyof `T` |
| `M` | extends keyof `T`[`C`] = ``"default"`` |

___

### DiagnosticResult

Ƭ **DiagnosticResult**<`T`\>: [`T`, readonly [`Diagnostic`](interfaces/Diagnostic.md)[]]

Return type of accessor functions in TypeSpec.
Tuple composed of:
- 0: Actual result of an accessor function
- 1: List of diagnostics that were emitted while retrieving the data.

#### Type parameters

| Name |
| :------ |
| `T` |

___

### DiagnosticSeverity

Ƭ **DiagnosticSeverity**: ``"error"`` \| ``"warning"``

___

### DiagnosticTarget

Ƭ **DiagnosticTarget**: [`Node`](index.md#node) \| [`Type`](index.md#type) \| [`Sym`](interfaces/Sym.md) \| [`SourceLocation`](interfaces/SourceLocation.md)

___

### Directive

Ƭ **Directive**: [`SuppressDirective`](interfaces/SuppressDirective.md)

___

### DirectiveArgument

Ƭ **DirectiveArgument**: [`StringLiteralNode`](interfaces/StringLiteralNode.md) \| [`IdentifierNode`](interfaces/IdentifierNode.md)

___

### DocContent

Ƭ **DocContent**: [`DocTextNode`](interfaces/DocTextNode.md)

___

### DocTag

Ƭ **DocTag**: [`DocReturnsTagNode`](interfaces/DocReturnsTagNode.md) \| [`DocParamTagNode`](interfaces/DocParamTagNode.md) \| [`DocTemplateTagNode`](interfaces/DocTemplateTagNode.md) \| [`DocUnknownTagNode`](interfaces/DocUnknownTagNode.md)

___

### DocToken

Ƭ **DocToken**: [`NewLine`](enums/Token.md#newline) \| [`Whitespace`](enums/Token.md#whitespace) \| [`ConflictMarker`](enums/Token.md#conflictmarker) \| [`Star`](enums/Token.md#star) \| [`At`](enums/Token.md#at) \| [`CloseBrace`](enums/Token.md#closebrace) \| [`Identifier`](enums/Token.md#identifier) \| [`DocText`](enums/Token.md#doctext) \| [`DocCodeSpan`](enums/Token.md#doccodespan) \| [`DocCodeFenceDelimiter`](enums/Token.md#doccodefencedelimiter) \| [`EndOfFile`](enums/Token.md#endoffile)

___

### EmitOptionsFor

Ƭ **EmitOptionsFor**<`C`\>: `C` extends [`TypeSpecLibrary`](interfaces/TypeSpecLibrary.md)<infer \_T, infer E\> ? `E` : `never`

Get the options for the onEmit of this library.

#### Type parameters

| Name |
| :------ |
| `C` |

___

### EmitterFunc

Ƭ **EmitterFunc**: (`context`: [`EmitContext`](interfaces/EmitContext.md)) => `Promise`<`void`\> \| `void`

#### Type declaration

▸ (`context`): `Promise`<`void`\> \| `void`

##### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`EmitContext`](interfaces/EmitContext.md) |

##### Returns

`Promise`<`void`\> \| `void`

___

### Expression

Ƭ **Expression**: [`ArrayExpressionNode`](interfaces/ArrayExpressionNode.md) \| [`MemberExpressionNode`](interfaces/MemberExpressionNode.md) \| [`ModelExpressionNode`](interfaces/ModelExpressionNode.md) \| [`TupleExpressionNode`](interfaces/TupleExpressionNode.md) \| [`UnionExpressionNode`](interfaces/UnionExpressionNode.md) \| [`IntersectionExpressionNode`](interfaces/IntersectionExpressionNode.md) \| [`TypeReferenceNode`](interfaces/TypeReferenceNode.md) \| [`IdentifierNode`](interfaces/IdentifierNode.md) \| [`StringLiteralNode`](interfaces/StringLiteralNode.md) \| [`NumericLiteralNode`](interfaces/NumericLiteralNode.md) \| [`BooleanLiteralNode`](interfaces/BooleanLiteralNode.md) \| [`VoidKeywordNode`](interfaces/VoidKeywordNode.md) \| [`NeverKeywordNode`](interfaces/NeverKeywordNode.md) \| [`AnyKeywordNode`](interfaces/AnyKeywordNode.md)

___

### InferredCadlValue

Ƭ **InferredCadlValue**<`K`\>: [`InferredTypeSpecValue`](index.md#inferredtypespecvalue)<`K`\>

**`Deprecated`**

Use InferredTypeSpecValue

#### Type parameters

| Name | Type |
| :------ | :------ |
| `K` | extends [`TypeKind`](index.md#typekind) |

___

### InferredTypeSpecValue

Ƭ **InferredTypeSpecValue**<`K`\>: `K` extends ``"Any"`` ? [`TypeSpecValue`](index.md#typespecvalue) : `K` extends infer T[] ? [`InferredTypeSpecValue`](index.md#inferredtypespecvalue)<`T`\> : `K` extends ``"String"`` ? `string` : `K` extends ``"Number"`` ? `number` : `K` extends ``"Boolean"`` ? `boolean` : [`Type`](index.md#type) & { `kind`: `K`  }

#### Type parameters

| Name | Type |
| :------ | :------ |
| `K` | extends [`TypeKind`](index.md#typekind) |

___

### IntrinsicScalarName

Ƭ **IntrinsicScalarName**: ``"bytes"`` \| ``"numeric"`` \| ``"integer"`` \| ``"float"`` \| ``"int64"`` \| ``"int32"`` \| ``"int16"`` \| ``"int8"`` \| ``"uint64"`` \| ``"uint32"`` \| ``"uint16"`` \| ``"uint8"`` \| ``"safeint"`` \| ``"float32"`` \| ``"float64"`` \| ``"string"`` \| ``"plainDate"`` \| ``"plainTime"`` \| ``"zonedDateTime"`` \| ``"duration"`` \| ``"boolean"`` \| ``"url"``

___

### JSONSchemaType

Ƭ **JSONSchemaType**<`T`\>: `AjvJSONSchemaType`<`T`\>

#### Type parameters

| Name |
| :------ |
| `T` |

___

### LiteralNode

Ƭ **LiteralNode**: [`StringLiteralNode`](interfaces/StringLiteralNode.md) \| [`NumericLiteralNode`](interfaces/NumericLiteralNode.md) \| [`BooleanLiteralNode`](interfaces/BooleanLiteralNode.md)

___

### LiteralType

Ƭ **LiteralType**: [`StringLiteral`](interfaces/StringLiteral.md) \| [`NumericLiteral`](interfaces/NumericLiteral.md) \| [`BooleanLiteral`](interfaces/BooleanLiteral.md)

___

### LogLevel

Ƭ **LogLevel**: ``"trace"`` \| ``"warning"`` \| ``"error"``

___

### MarshalledValue

Ƭ **MarshalledValue**<`Type`\>: `Type` extends [`StringLiteral`](interfaces/StringLiteral.md) ? `string` : `Type` extends [`NumericLiteral`](interfaces/NumericLiteral.md) ? `number` : `Type` extends [`BooleanLiteral`](interfaces/BooleanLiteral.md) ? `boolean` : `Type`

#### Type parameters

| Name |
| :------ |
| `Type` |

___

### MemberContainerNode

Ƭ **MemberContainerNode**: [`ModelStatementNode`](interfaces/ModelStatementNode.md) \| [`ModelExpressionNode`](interfaces/ModelExpressionNode.md) \| [`InterfaceStatementNode`](interfaces/InterfaceStatementNode.md) \| [`EnumStatementNode`](interfaces/EnumStatementNode.md) \| [`UnionStatementNode`](interfaces/UnionStatementNode.md)

Node types that can have referencable members

___

### MemberContainerType

Ƭ **MemberContainerType**: [`Model`](interfaces/Model.md) \| [`Enum`](interfaces/Enum.md) \| [`Interface`](interfaces/Interface.md) \| [`Union`](interfaces/Union.md)

___

### MemberNode

Ƭ **MemberNode**: [`ModelPropertyNode`](interfaces/ModelPropertyNode.md) \| [`EnumMemberNode`](interfaces/EnumMemberNode.md) \| [`OperationStatementNode`](interfaces/OperationStatementNode.md) \| [`UnionVariantNode`](interfaces/UnionVariantNode.md)

___

### MemberType

Ƭ **MemberType**: [`ModelProperty`](interfaces/ModelProperty.md) \| [`EnumMember`](interfaces/EnumMember.md) \| [`Operation`](interfaces/Operation.md) \| [`UnionVariant`](interfaces/UnionVariant.md)

Type that can be used as members of a container type.

___

### ModelIndexer

Ƭ **ModelIndexer**: `Object`

#### Type declaration

| Name | Type |
| :------ | :------ |
| `key` | [`Scalar`](interfaces/Scalar.md) |
| `value` | [`Type`](index.md#type) |

___

### Modifier

Ƭ **Modifier**: [`ExternKeywordNode`](interfaces/ExternKeywordNode.md)

___

### ModuleResolutionResult

Ƭ **ModuleResolutionResult**: [`ResolvedFile`](interfaces/ResolvedFile.md) \| [`ResolvedModule`](interfaces/ResolvedModule.md)

___

### NeverIndexer

Ƭ **NeverIndexer**: `Object`

#### Type declaration

| Name | Type |
| :------ | :------ |
| `key` | [`NeverType`](interfaces/NeverType.md) |
| `value` | `undefined` |

___

### NewLine

Ƭ **NewLine**: ``"lf"`` \| ``"crlf"``

___

### Node

Ƭ **Node**: [`TypeSpecScriptNode`](interfaces/TypeSpecScriptNode.md) \| [`JsSourceFileNode`](interfaces/JsSourceFileNode.md) \| [`TemplateParameterDeclarationNode`](interfaces/TemplateParameterDeclarationNode.md) \| [`ProjectionParameterDeclarationNode`](interfaces/ProjectionParameterDeclarationNode.md) \| [`ProjectionLambdaParameterDeclarationNode`](interfaces/ProjectionLambdaParameterDeclarationNode.md) \| [`ModelPropertyNode`](interfaces/ModelPropertyNode.md) \| [`UnionVariantNode`](interfaces/UnionVariantNode.md) \| [`OperationStatementNode`](interfaces/OperationStatementNode.md) \| [`OperationSignatureDeclarationNode`](interfaces/OperationSignatureDeclarationNode.md) \| [`OperationSignatureReferenceNode`](interfaces/OperationSignatureReferenceNode.md) \| [`EnumMemberNode`](interfaces/EnumMemberNode.md) \| [`EnumSpreadMemberNode`](interfaces/EnumSpreadMemberNode.md) \| [`ModelSpreadPropertyNode`](interfaces/ModelSpreadPropertyNode.md) \| [`DecoratorExpressionNode`](interfaces/DecoratorExpressionNode.md) \| [`DirectiveExpressionNode`](interfaces/DirectiveExpressionNode.md) \| [`Statement`](index.md#statement) \| [`Expression`](index.md#expression) \| [`FunctionParameterNode`](interfaces/FunctionParameterNode.md) \| [`Modifier`](index.md#modifier) \| [`DocNode`](interfaces/DocNode.md) \| [`DocContent`](index.md#doccontent) \| [`DocTag`](index.md#doctag) \| [`ProjectionStatementItem`](index.md#projectionstatementitem) \| [`ProjectionExpression`](index.md#projectionexpression) \| [`ProjectionModelSelectorNode`](interfaces/ProjectionModelSelectorNode.md) \| [`ProjectionInterfaceSelectorNode`](interfaces/ProjectionInterfaceSelectorNode.md) \| [`ProjectionOperationSelectorNode`](interfaces/ProjectionOperationSelectorNode.md) \| [`ProjectionEnumSelectorNode`](interfaces/ProjectionEnumSelectorNode.md) \| [`ProjectionUnionSelectorNode`](interfaces/ProjectionUnionSelectorNode.md) \| [`ProjectionModelPropertyNode`](interfaces/ProjectionModelPropertyNode.md) \| [`ProjectionModelSpreadPropertyNode`](interfaces/ProjectionModelSpreadPropertyNode.md) \| [`ProjectionStatementNode`](interfaces/ProjectionStatementNode.md) \| [`ProjectionNode`](interfaces/ProjectionNode.md)

___

### NodeCallback

Ƭ **NodeCallback**<`T`\>: (`c`: [`Node`](index.md#node)) => `T`

#### Type parameters

| Name |
| :------ |
| `T` |

#### Type declaration

▸ (`c`): `T`

##### Parameters

| Name | Type |
| :------ | :------ |
| `c` | [`Node`](index.md#node) |

##### Returns

`T`

___

### OperationContainer

Ƭ **OperationContainer**: [`Namespace`](interfaces/Namespace.md) \| [`Interface`](interfaces/Interface.md) \| [`Operation`](interfaces/Operation.md)

___

### OperationSignature

Ƭ **OperationSignature**: [`OperationSignatureDeclarationNode`](interfaces/OperationSignatureDeclarationNode.md) \| [`OperationSignatureReferenceNode`](interfaces/OperationSignatureReferenceNode.md)

___

### ProjectionExpression

Ƭ **ProjectionExpression**: [`ProjectionLogicalExpressionNode`](interfaces/ProjectionLogicalExpressionNode.md) \| [`ProjectionRelationalExpressionNode`](interfaces/ProjectionRelationalExpressionNode.md) \| [`ProjectionEqualityExpressionNode`](interfaces/ProjectionEqualityExpressionNode.md) \| [`ProjectionUnaryExpressionNode`](interfaces/ProjectionUnaryExpressionNode.md) \| [`ProjectionArithmeticExpressionNode`](interfaces/ProjectionArithmeticExpressionNode.md) \| [`ProjectionCallExpressionNode`](interfaces/ProjectionCallExpressionNode.md) \| [`ProjectionMemberExpressionNode`](interfaces/ProjectionMemberExpressionNode.md) \| [`ProjectionDecoratorReferenceExpressionNode`](interfaces/ProjectionDecoratorReferenceExpressionNode.md) \| [`ProjectionTupleExpressionNode`](interfaces/ProjectionTupleExpressionNode.md) \| [`ProjectionModelExpressionNode`](interfaces/ProjectionModelExpressionNode.md) \| [`ProjectionIfExpressionNode`](interfaces/ProjectionIfExpressionNode.md) \| [`ProjectionBlockExpressionNode`](interfaces/ProjectionBlockExpressionNode.md) \| [`ProjectionLambdaExpressionNode`](interfaces/ProjectionLambdaExpressionNode.md) \| [`StringLiteralNode`](interfaces/StringLiteralNode.md) \| [`NumericLiteralNode`](interfaces/NumericLiteralNode.md) \| [`BooleanLiteralNode`](interfaces/BooleanLiteralNode.md) \| [`IdentifierNode`](interfaces/IdentifierNode.md) \| [`VoidKeywordNode`](interfaces/VoidKeywordNode.md) \| [`NeverKeywordNode`](interfaces/NeverKeywordNode.md) \| [`AnyKeywordNode`](interfaces/AnyKeywordNode.md) \| [`ReturnExpressionNode`](interfaces/ReturnExpressionNode.md)

___

### ProjectionStatementItem

Ƭ **ProjectionStatementItem**: [`ProjectionExpressionStatementNode`](interfaces/ProjectionExpressionStatementNode.md)

___

### ReferenceExpression

Ƭ **ReferenceExpression**: [`TypeReferenceNode`](interfaces/TypeReferenceNode.md) \| [`MemberExpressionNode`](interfaces/MemberExpressionNode.md) \| [`IdentifierNode`](interfaces/IdentifierNode.md) \| [`VoidKeywordNode`](interfaces/VoidKeywordNode.md) \| [`NeverKeywordNode`](interfaces/NeverKeywordNode.md)

___

### ScopeNode

Ƭ **ScopeNode**: [`NamespaceStatementNode`](interfaces/NamespaceStatementNode.md) \| [`ModelStatementNode`](interfaces/ModelStatementNode.md) \| [`InterfaceStatementNode`](interfaces/InterfaceStatementNode.md) \| [`AliasStatementNode`](interfaces/AliasStatementNode.md) \| [`TypeSpecScriptNode`](interfaces/TypeSpecScriptNode.md) \| [`JsSourceFileNode`](interfaces/JsSourceFileNode.md) \| [`ProjectionLambdaExpressionNode`](interfaces/ProjectionLambdaExpressionNode.md) \| [`ProjectionNode`](interfaces/ProjectionNode.md)

___

### SemanticNodeListener

Ƭ **SemanticNodeListener**: { `root?`: (`context`: [`Program`](interfaces/Program.md)) => `void` \| `undefined`  } & [`TypeListeners`](index.md#typelisteners)

___

### SourceFileKind

Ƭ **SourceFileKind**: ``"typespec"`` \| ``"js"``

Type of the source file that can be loaded via typespec

___

### Statement

Ƭ **Statement**: [`ImportStatementNode`](interfaces/ImportStatementNode.md) \| [`ModelStatementNode`](interfaces/ModelStatementNode.md) \| [`ScalarStatementNode`](interfaces/ScalarStatementNode.md) \| [`NamespaceStatementNode`](interfaces/NamespaceStatementNode.md) \| [`InterfaceStatementNode`](interfaces/InterfaceStatementNode.md) \| [`UnionStatementNode`](interfaces/UnionStatementNode.md) \| [`UsingStatementNode`](interfaces/UsingStatementNode.md) \| [`EnumStatementNode`](interfaces/EnumStatementNode.md) \| [`AliasStatementNode`](interfaces/AliasStatementNode.md) \| [`OperationStatementNode`](interfaces/OperationStatementNode.md) \| [`DecoratorDeclarationStatementNode`](interfaces/DecoratorDeclarationStatementNode.md) \| [`FunctionDeclarationStatementNode`](interfaces/FunctionDeclarationStatementNode.md) \| [`AugmentDecoratorStatementNode`](interfaces/AugmentDecoratorStatementNode.md) \| [`EmptyStatementNode`](interfaces/EmptyStatementNode.md) \| [`InvalidStatementNode`](interfaces/InvalidStatementNode.md) \| [`ProjectionStatementNode`](interfaces/ProjectionStatementNode.md)

___

### TemplateableNode

Ƭ **TemplateableNode**: [`ModelStatementNode`](interfaces/ModelStatementNode.md) \| [`ScalarStatementNode`](interfaces/ScalarStatementNode.md) \| [`AliasStatementNode`](interfaces/AliasStatementNode.md) \| [`InterfaceStatementNode`](interfaces/InterfaceStatementNode.md) \| [`OperationStatementNode`](interfaces/OperationStatementNode.md) \| [`UnionStatementNode`](interfaces/UnionStatementNode.md)

Node that can be used as template

___

### TemplatedType

Ƭ **TemplatedType**: [`Model`](interfaces/Model.md) \| [`Operation`](interfaces/Operation.md) \| [`Interface`](interfaces/Interface.md) \| [`Union`](interfaces/Union.md)

Union of all the types that implement TemplatedTypeBase

___

### TrackableType

Ƭ **TrackableType**: [`Model`](interfaces/Model.md) \| [`Enum`](interfaces/Enum.md) \| [`Union`](interfaces/Union.md) \| [`Tuple`](interfaces/Tuple.md)

___

### Type

Ƭ **Type**: [`Model`](interfaces/Model.md) \| [`ModelProperty`](interfaces/ModelProperty.md) \| [`Scalar`](interfaces/Scalar.md) \| [`Interface`](interfaces/Interface.md) \| [`Enum`](interfaces/Enum.md) \| [`EnumMember`](interfaces/EnumMember.md) \| [`TemplateParameter`](interfaces/TemplateParameter.md) \| [`Namespace`](interfaces/Namespace.md) \| [`Operation`](interfaces/Operation.md) \| [`StringLiteral`](interfaces/StringLiteral.md) \| [`NumericLiteral`](interfaces/NumericLiteral.md) \| [`BooleanLiteral`](interfaces/BooleanLiteral.md) \| [`Tuple`](interfaces/Tuple.md) \| [`Union`](interfaces/Union.md) \| [`UnionVariant`](interfaces/UnionVariant.md) \| [`IntrinsicType`](interfaces/IntrinsicType.md) \| [`FunctionType`](interfaces/FunctionType.md) \| [`Decorator`](interfaces/Decorator.md) \| [`FunctionParameter`](interfaces/FunctionParameter.md) \| [`ObjectType`](interfaces/ObjectType.md) \| [`Projection`](interfaces/Projection.md)

___

### TypeKind

Ƭ **TypeKind**: [`Type`](index.md#type)[``"kind"``] \| ``"Any"``

___

### TypeListeners

Ƭ **TypeListeners**: `UnionToIntersection`<`ListenerForType`<[`Type`](index.md#type)\>\>

___

### TypeOfDiagnostics

Ƭ **TypeOfDiagnostics**<`T`\>: `T` extends [`DiagnosticMap`](index.md#diagnosticmap)<infer D\> ? `D` : `never`

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends [`DiagnosticMap`](index.md#diagnosticmap)<`any`\> |

___

### TypeOrReturnRecord

Ƭ **TypeOrReturnRecord**: [`Type`](index.md#type) \| [`ReturnRecord`](interfaces/ReturnRecord.md)

___

### TypeSpecValue

Ƭ **TypeSpecValue**: [`Type`](index.md#type) \| `string` \| `number` \| `boolean`

___

### WriteLine

Ƭ **WriteLine**: (`text?`: `string`) => `void`

#### Type declaration

▸ (`text?`): `void`

##### Parameters

| Name | Type |
| :------ | :------ |
| `text?` | `string` |

##### Returns

`void`

## Variables

### CadlLanguageConfiguration

• `Const` **CadlLanguageConfiguration**: `Object` = `TypeSpecLanguageConfiguration`

**`Deprecated`**

Use TypeSpecLanguageConfiguration

#### Type declaration

| Name | Type |
| :------ | :------ |
| `autoClosingPairs` | readonly [{ `close`: ``"}"`` = "}"; `open`: ``"{"`` = "{" }, { `close`: ``"]"`` = "]"; `open`: ``"["`` = "[" }, { `close`: ``")"`` = ")"; `open`: ``"("`` = "(" }, { `close`: ``"\""`` = '"'; `open`: ``"\""`` = '"' }, { `close`: ``" */"`` = " */"; `notIn`: readonly [``"string"``] ; `open`: ``"/**"`` = "/**" }] |
| `brackets` | readonly [readonly [``"{"``, ``"}"``], readonly [``"["``, ``"]"``], readonly [``"("``, ``")"``]] |
| `comments` | { `blockComment`: readonly [``"/*"``, ``"*/"``] ; `lineComment`: ``"//"`` = "//" } |
| `comments.blockComment` | readonly [``"/*"``, ``"*/"``] |
| `comments.lineComment` | ``"//"`` |
| `indentationRules` | { `decreaseIndentPattern`: { `pattern`: ``"^((?!.*?/\\*).*\\*/)?\\s*[\\}\\]].*$"`` = "^((?!.*?/\\*).*\\*/)?\\s*[\\}\\]].*$" } ; `increaseIndentPattern`: { `pattern`: ``"^((?!//).)*(\\{([^}\"'`/]*\|(\\t\|[ ])*//.*)\|\\([^)\"'`/]*\|\\[[^\\]\"'`/]*)$"`` = "^((?!//).)*(\\{([^}\"'\`/]*\|(\\t\|[ ])*//.*)\|\\([^)\"'\`/]*\|\\[[^\\]\"'\`/]*)$" } ; `unIndentedLinePattern`: { `pattern`: ``"^(\\t\|[ ])*[ ]\\*[^/]*\\*/\\s*$\|^(\\t\|[ ])*[ ]\\*/\\s*$\|^(\\t\|[ ])*[ ]\\*([ ]([^\\*]\|\\*(?!/))*)?$"`` = "^(\\t\|[ ])*[ ]\\*[^/]*\\*/\\s*$\|^(\\t\|[ ])*[ ]\\*/\\s*$\|^(\\t\|[ ])*[ ]\\*([ ]([^\\*]\|\\*(?!/))*)?$" }  } |
| `indentationRules.decreaseIndentPattern` | { `pattern`: ``"^((?!.*?/\\*).*\\*/)?\\s*[\\}\\]].*$"`` = "^((?!.*?/\\*).*\\*/)?\\s*[\\}\\]].*$" } |
| `indentationRules.decreaseIndentPattern.pattern` | ``"^((?!.*?/\\*).*\\*/)?\\s*[\\}\\]].*$"`` |
| `indentationRules.increaseIndentPattern` | { `pattern`: ``"^((?!//).)*(\\{([^}\"'`/]*\|(\\t\|[ ])*//.*)\|\\([^)\"'`/]*\|\\[[^\\]\"'`/]*)$"`` = "^((?!//).)*(\\{([^}\"'\`/]*\|(\\t\|[ ])*//.*)\|\\([^)\"'\`/]*\|\\[[^\\]\"'\`/]*)$" } |
| `indentationRules.increaseIndentPattern.pattern` | ``"^((?!//).)*(\\{([^}\"'`/]*\|(\\t\|[ ])*//.*)\|\\([^)\"'`/]*\|\\[[^\\]\"'`/]*)$"`` |
| `indentationRules.unIndentedLinePattern` | { `pattern`: ``"^(\\t\|[ ])*[ ]\\*[^/]*\\*/\\s*$\|^(\\t\|[ ])*[ ]\\*/\\s*$\|^(\\t\|[ ])*[ ]\\*([ ]([^\\*]\|\\*(?!/))*)?$"`` = "^(\\t\|[ ])*[ ]\\*[^/]*\\*/\\s*$\|^(\\t\|[ ])*[ ]\\*/\\s*$\|^(\\t\|[ ])*[ ]\\*([ ]([^\\*]\|\\*(?!/))*)?$" } |
| `indentationRules.unIndentedLinePattern.pattern` | ``"^(\\t\|[ ])*[ ]\\*[^/]*\\*/\\s*$\|^(\\t\|[ ])*[ ]\\*/\\s*$\|^(\\t\|[ ])*[ ]\\*([ ]([^\\*]\|\\*(?!/))*)?$"`` |
| `onEnterRules` | readonly [{ `action`: { `appendText`: ``" * "`` = " * "; `indent`: ``"indentOutdent"`` = "indentOutdent" } ; `afterText`: { `pattern`: ``"^\\s*\\*/$"`` = "^\\s*\\*/$" } ; `beforeText`: { `pattern`: ``"^\\s*/\\*\\*(?!/)([^\\*]\|\\*(?!/))*$"`` = "^\\s*/\\*\\*(?!/)([^\\*]\|\\*(?!/))*$" }  }, { `action`: { `appendText`: ``" * "`` = " * "; `indent`: ``"none"`` = "none" } ; `beforeText`: { `pattern`: ``"^\\s*/\\*\\*(?!/)([^\\*]\|\\*(?!/))*$"`` = "^\\s*/\\*\\*(?!/)([^\\*]\|\\*(?!/))*$" }  }, { `action`: { `appendText`: ``"* "`` = "* "; `indent`: ``"none"`` = "none" } ; `beforeText`: { `pattern`: ``"^(\\t\|[ ])*[ ]\\*([ ]([^\\*]\|\\*(?!/))*)?$"`` = "^(\\t\|[ ])*[ ]\\*([ ]([^\\*]\|\\*(?!/))*)?$" } ; `previousLineText`: { `pattern`: ``"(?=^(\\s*(/\\*\\*\|\\*)).*)(?=(?!(\\s*\\*/)))"`` = "(?=^(\\s*(/\\*\\*\|\\*)).*)(?=(?!(\\s*\\*/)))" }  }, { `action`: { `indent`: ``"none"`` = "none"; `removeText`: ``1`` = 1 } ; `beforeText`: { `pattern`: ``"^(\\t\|[ ])*[ ]\\*/\\s*$"`` = "^(\\t\|[ ])*[ ]\\*/\\s*$" }  }, { `action`: { `indent`: ``"none"`` = "none"; `removeText`: ``1`` = 1 } ; `beforeText`: { `pattern`: ``"^(\\t\|[ ])*[ ]\\*[^/]*\\*/\\s*$"`` = "^(\\t\|[ ])*[ ]\\*[^/]*\\*/\\s*$" }  }] |
| `surroundingPairs` | readonly [{ `close`: ``"}"`` = "}"; `open`: ``"{"`` = "{" }, { `close`: ``"]"`` = "]"; `open`: ``"["`` = "[" }, { `close`: ``")"`` = ")"; `open`: ``"("`` = "(" }, { `close`: ``"\""`` = '"'; `open`: ``"\""`` = '"' }] |

___

### CadlPrettierPlugin

• `Const` **CadlPrettierPlugin**: `__module` = `TypeSpecPrettierPlugin`

**`Deprecated`**

Use TypeSpecPrettierPlugin

___

### Keywords

• `Const` **Keywords**: `ReadonlyMap`<`string`, [`Token`](enums/Token.md)\>

___

### MANIFEST

• `Const` **MANIFEST**: [`TypeSpecManifest`](interfaces/TypeSpecManifest.md) = `manifest`

___

### NoTarget

• `Const` **NoTarget**: typeof [`NoTarget`](index.md#notarget)

___

### NodeHost

• `Const` **NodeHost**: [`CompilerHost`](interfaces/CompilerHost.md)

Implementation of the

**`See`**

CompilerHost using the real file system.
This is the the CompilerHost used by TypeSpec CLI.

___

### TokenDisplay

• `Const` **TokenDisplay**: readonly `string`[]

___

### TypeSpecLanguageConfiguration

• `Const` **TypeSpecLanguageConfiguration**: `Object`

TypeSpec Language configuration. Format: https://code.visualstudio.com/api/language-extensions/language-configuration-guide

#### Type declaration

| Name | Type |
| :------ | :------ |
| `autoClosingPairs` | readonly [{ `close`: ``"}"`` = "}"; `open`: ``"{"`` = "{" }, { `close`: ``"]"`` = "]"; `open`: ``"["`` = "[" }, { `close`: ``")"`` = ")"; `open`: ``"("`` = "(" }, { `close`: ``"\""`` = '"'; `open`: ``"\""`` = '"' }, { `close`: ``" */"`` = " */"; `notIn`: readonly [``"string"``] ; `open`: ``"/**"`` = "/**" }] |
| `brackets` | readonly [readonly [``"{"``, ``"}"``], readonly [``"["``, ``"]"``], readonly [``"("``, ``")"``]] |
| `comments` | { `blockComment`: readonly [``"/*"``, ``"*/"``] ; `lineComment`: ``"//"`` = "//" } |
| `comments.blockComment` | readonly [``"/*"``, ``"*/"``] |
| `comments.lineComment` | ``"//"`` |
| `indentationRules` | { `decreaseIndentPattern`: { `pattern`: ``"^((?!.*?/\\*).*\\*/)?\\s*[\\}\\]].*$"`` = "^((?!.*?/\\*).*\\*/)?\\s*[\\}\\]].*$" } ; `increaseIndentPattern`: { `pattern`: ``"^((?!//).)*(\\{([^}\"'`/]*\|(\\t\|[ ])*//.*)\|\\([^)\"'`/]*\|\\[[^\\]\"'`/]*)$"`` = "^((?!//).)*(\\{([^}\"'\`/]*\|(\\t\|[ ])*//.*)\|\\([^)\"'\`/]*\|\\[[^\\]\"'\`/]*)$" } ; `unIndentedLinePattern`: { `pattern`: ``"^(\\t\|[ ])*[ ]\\*[^/]*\\*/\\s*$\|^(\\t\|[ ])*[ ]\\*/\\s*$\|^(\\t\|[ ])*[ ]\\*([ ]([^\\*]\|\\*(?!/))*)?$"`` = "^(\\t\|[ ])*[ ]\\*[^/]*\\*/\\s*$\|^(\\t\|[ ])*[ ]\\*/\\s*$\|^(\\t\|[ ])*[ ]\\*([ ]([^\\*]\|\\*(?!/))*)?$" }  } |
| `indentationRules.decreaseIndentPattern` | { `pattern`: ``"^((?!.*?/\\*).*\\*/)?\\s*[\\}\\]].*$"`` = "^((?!.*?/\\*).*\\*/)?\\s*[\\}\\]].*$" } |
| `indentationRules.decreaseIndentPattern.pattern` | ``"^((?!.*?/\\*).*\\*/)?\\s*[\\}\\]].*$"`` |
| `indentationRules.increaseIndentPattern` | { `pattern`: ``"^((?!//).)*(\\{([^}\"'`/]*\|(\\t\|[ ])*//.*)\|\\([^)\"'`/]*\|\\[[^\\]\"'`/]*)$"`` = "^((?!//).)*(\\{([^}\"'\`/]*\|(\\t\|[ ])*//.*)\|\\([^)\"'\`/]*\|\\[[^\\]\"'\`/]*)$" } |
| `indentationRules.increaseIndentPattern.pattern` | ``"^((?!//).)*(\\{([^}\"'`/]*\|(\\t\|[ ])*//.*)\|\\([^)\"'`/]*\|\\[[^\\]\"'`/]*)$"`` |
| `indentationRules.unIndentedLinePattern` | { `pattern`: ``"^(\\t\|[ ])*[ ]\\*[^/]*\\*/\\s*$\|^(\\t\|[ ])*[ ]\\*/\\s*$\|^(\\t\|[ ])*[ ]\\*([ ]([^\\*]\|\\*(?!/))*)?$"`` = "^(\\t\|[ ])*[ ]\\*[^/]*\\*/\\s*$\|^(\\t\|[ ])*[ ]\\*/\\s*$\|^(\\t\|[ ])*[ ]\\*([ ]([^\\*]\|\\*(?!/))*)?$" } |
| `indentationRules.unIndentedLinePattern.pattern` | ``"^(\\t\|[ ])*[ ]\\*[^/]*\\*/\\s*$\|^(\\t\|[ ])*[ ]\\*/\\s*$\|^(\\t\|[ ])*[ ]\\*([ ]([^\\*]\|\\*(?!/))*)?$"`` |
| `onEnterRules` | readonly [{ `action`: { `appendText`: ``" * "`` = " * "; `indent`: ``"indentOutdent"`` = "indentOutdent" } ; `afterText`: { `pattern`: ``"^\\s*\\*/$"`` = "^\\s*\\*/$" } ; `beforeText`: { `pattern`: ``"^\\s*/\\*\\*(?!/)([^\\*]\|\\*(?!/))*$"`` = "^\\s*/\\*\\*(?!/)([^\\*]\|\\*(?!/))*$" }  }, { `action`: { `appendText`: ``" * "`` = " * "; `indent`: ``"none"`` = "none" } ; `beforeText`: { `pattern`: ``"^\\s*/\\*\\*(?!/)([^\\*]\|\\*(?!/))*$"`` = "^\\s*/\\*\\*(?!/)([^\\*]\|\\*(?!/))*$" }  }, { `action`: { `appendText`: ``"* "`` = "* "; `indent`: ``"none"`` = "none" } ; `beforeText`: { `pattern`: ``"^(\\t\|[ ])*[ ]\\*([ ]([^\\*]\|\\*(?!/))*)?$"`` = "^(\\t\|[ ])*[ ]\\*([ ]([^\\*]\|\\*(?!/))*)?$" } ; `previousLineText`: { `pattern`: ``"(?=^(\\s*(/\\*\\*\|\\*)).*)(?=(?!(\\s*\\*/)))"`` = "(?=^(\\s*(/\\*\\*\|\\*)).*)(?=(?!(\\s*\\*/)))" }  }, { `action`: { `indent`: ``"none"`` = "none"; `removeText`: ``1`` = 1 } ; `beforeText`: { `pattern`: ``"^(\\t\|[ ])*[ ]\\*/\\s*$"`` = "^(\\t\|[ ])*[ ]\\*/\\s*$" }  }, { `action`: { `indent`: ``"none"`` = "none"; `removeText`: ``1`` = 1 } ; `beforeText`: { `pattern`: ``"^(\\t\|[ ])*[ ]\\*[^/]*\\*/\\s*$"`` = "^(\\t\|[ ])*[ ]\\*[^/]*\\*/\\s*$" }  }] |
| `surroundingPairs` | readonly [{ `close`: ``"}"`` = "}"; `open`: ``"{"`` = "{" }, { `close`: ``"]"`` = "]"; `open`: ``"["`` = "[" }, { `close`: ``")"`` = ")"; `open`: ``"("`` = "(" }, { `close`: ``"\""`` = '"'; `open`: ``"\""`` = '"' }] |

___

### TypeSpecPrettierPlugin

• `Const` **TypeSpecPrettierPlugin**: `__module` = `formatter`

___

### altDirectorySeparator

• `Const` **altDirectorySeparator**: ``"\\"``

___

### cadlVersion

• `Const` **cadlVersion**: `any` = `typespecVersion`

**`Deprecated`**

Use typespecVersion

___

### directorySeparator

• `Const` **directorySeparator**: ``"/"``

Internally, we represent paths as strings with '/' as the directory separator.
When we make system calls (eg: LanguageServiceHost.getDirectory()),
we expect the host to correctly handle paths in our specified format.

___

### namespace

• `Const` **namespace**: ``"TypeSpec"``

___

### typespecVersion

• `Const` **typespecVersion**: `any` = `manifest.version`

## Functions

### $deprecated

▸ **$deprecated**(`context`, `target`, `message`): `Map`<[`Type`](index.md#type), `any`\>

Mark a type as deprecated

**`Example`**

``` @deprecated("Foo is deprecated, use Bar instead.")
    model Foo {}
```

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) | DecoratorContext |
| `target` | [`Type`](index.md#type) | Decorator target |
| `message` | `string` | Deprecation target. |

#### Returns

`Map`<[`Type`](index.md#type), `any`\>

___

### $discriminator

▸ **$discriminator**(`context`, `entity`, `propertyName`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `entity` | [`Model`](interfaces/Model.md) \| [`Union`](interfaces/Union.md) |
| `propertyName` | `string` |

#### Returns

`void`

___

### $doc

▸ **$doc**(`context`, `target`, `text`, `sourceObject?`): `void`

**`Doc`**

attaches a documentation string. Works great with multi-line string literals.

The first argument to

**`Doc`**

is a string, which may contain template parameters, enclosed in braces,
which are replaced with an attribute for the type (commonly "name") passed as the second (optional) argument.

**`Doc`**

can be specified on any language element -- a model, an operation, a namespace, etc.

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`Type`](index.md#type) |
| `text` | `string` |
| `sourceObject?` | [`Type`](index.md#type) |

#### Returns

`void`

___

### $error

▸ **$error**(`context`, `entity`): `void`

`@error` decorator marks a model as an error type.

`@error` can only be specified on a model.

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `entity` | [`Model`](interfaces/Model.md) |

#### Returns

`void`

___

### $format

▸ **$format**(`context`, `target`, `format`): `void`

`@format` - specify the data format hint for a string type

The first argument is a string that identifies the format that the string type expects.  Any string
can be entered here, but a TypeSpec emitter must know how to interpret

For TypeSpec specs that will be used with an OpenAPI emitter, the OpenAPI specification describes possible
valid values for a string type's format:

https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#dataTypes

`@format` can be specified on a type that extends from `string` or a `string`-typed model property.

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`ModelProperty`](interfaces/ModelProperty.md) \| [`Scalar`](interfaces/Scalar.md) |
| `format` | `string` |

#### Returns

`void`

___

### $friendlyName

▸ **$friendlyName**(`context`, `target`, `friendlyName`, `sourceObject`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`Type`](index.md#type) |
| `friendlyName` | `string` |
| `sourceObject` | `undefined` \| [`Type`](index.md#type) |

#### Returns

`void`

___

### $indexer

▸ **$indexer**(`context`, `target`, `key`, `value`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`Type`](index.md#type) |
| `key` | [`Scalar`](interfaces/Scalar.md) |
| `value` | [`Type`](index.md#type) |

#### Returns

`void`

___

### $inspectType

▸ **$inspectType**(`program`, `target`, `text`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `target` | [`Type`](index.md#type) |
| `text` | `string` |

#### Returns

`void`

___

### $inspectTypeName

▸ **$inspectTypeName**(`program`, `target`, `text`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `target` | [`Type`](index.md#type) |
| `text` | `string` |

#### Returns

`void`

___

### $key

▸ **$key**(`context`, `entity`, `altName?`): `void`

`@key` - mark a model property as the key to identify instances of that type

The optional first argument accepts an alternate key name which may be used by emitters.
Otherwise, the name of the target property will be used.

`@key` can only be applied to model properties.

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `entity` | [`ModelProperty`](interfaces/ModelProperty.md) |
| `altName?` | `string` |

#### Returns

`void`

___

### $knownValues

▸ **$knownValues**(`context`, `target`, `knownValues`): `void`

`@knownValues` marks a string type with an enum that contains all known values

The first parameter is a reference to an enum type that describes all possible values that the
type accepts.

`@knownValues` can only be applied to model types that extend `string`.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) | - |
| `target` | [`ModelProperty`](interfaces/ModelProperty.md) \| [`Scalar`](interfaces/Scalar.md) | Decorator target. Must be a string. (model Foo extends string) |
| `knownValues` | [`Enum`](interfaces/Enum.md) | Must be an enum. |

#### Returns

`void`

___

### $list

▸ **$list**(`context`, `target`, `listedType?`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`Operation`](interfaces/Operation.md) |
| `listedType?` | [`Type`](index.md#type) |

#### Returns

`void`

___

### $maxItems

▸ **$maxItems**(`context`, `target`, `maxItems`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`Model`](interfaces/Model.md) \| [`ModelProperty`](interfaces/ModelProperty.md) |
| `maxItems` | `number` |

#### Returns

`void`

___

### $maxLength

▸ **$maxLength**(`context`, `target`, `maxLength`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`ModelProperty`](interfaces/ModelProperty.md) \| [`Scalar`](interfaces/Scalar.md) |
| `maxLength` | `number` |

#### Returns

`void`

___

### $maxValue

▸ **$maxValue**(`context`, `target`, `maxValue`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`ModelProperty`](interfaces/ModelProperty.md) \| [`Scalar`](interfaces/Scalar.md) |
| `maxValue` | `number` |

#### Returns

`void`

___

### $maxValueExclusive

▸ **$maxValueExclusive**(`context`, `target`, `maxValueExclusive`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`ModelProperty`](interfaces/ModelProperty.md) \| [`Scalar`](interfaces/Scalar.md) |
| `maxValueExclusive` | `number` |

#### Returns

`void`

___

### $minItems

▸ **$minItems**(`context`, `target`, `minItems`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`Model`](interfaces/Model.md) \| [`ModelProperty`](interfaces/ModelProperty.md) |
| `minItems` | `number` |

#### Returns

`void`

___

### $minLength

▸ **$minLength**(`context`, `target`, `minLength`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`ModelProperty`](interfaces/ModelProperty.md) \| [`Scalar`](interfaces/Scalar.md) |
| `minLength` | `number` |

#### Returns

`void`

___

### $minValue

▸ **$minValue**(`context`, `target`, `minValue`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`ModelProperty`](interfaces/ModelProperty.md) \| [`Scalar`](interfaces/Scalar.md) |
| `minValue` | `number` |

#### Returns

`void`

___

### $minValueExclusive

▸ **$minValueExclusive**(`context`, `target`, `minValueExclusive`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`ModelProperty`](interfaces/ModelProperty.md) \| [`Scalar`](interfaces/Scalar.md) |
| `minValueExclusive` | `number` |

#### Returns

`void`

___

### $overload

▸ **$overload**(`context`, `target`, `overloadBase`): `void`

`@overload` - Indicate that the target overloads (specializes) the overloads type.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) | DecoratorContext |
| `target` | [`Operation`](interfaces/Operation.md) | The specializing operation declaration |
| `overloadBase` | [`Operation`](interfaces/Operation.md) | The operation to be overloaded. |

#### Returns

`void`

___

### $pattern

▸ **$pattern**(`context`, `target`, `pattern`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`ModelProperty`](interfaces/ModelProperty.md) \| [`Scalar`](interfaces/Scalar.md) |
| `pattern` | `string` |

#### Returns

`void`

___

### $projectedName

▸ **$projectedName**(`context`, `target`, `projectionName`, `projectedName`): `void`

`@projectedName` - Indicate that this entity should be renamed according to the given projection.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) | DecoratorContext |
| `target` | [`Type`](index.md#type) | The that should have a different name. |
| `projectionName` | `string` | Name of the projection (e.g. "toJson", "toCSharp") |
| `projectedName` | `string` | Name of the type should have in the scope of the projection specified. |

#### Returns

`void`

___

### $secret

▸ **$secret**(`context`, `target`): `void`

Mark a string as a secret value that should be treated carefully to avoid exposure

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) | Decorator context |
| `target` | [`ModelProperty`](interfaces/ModelProperty.md) \| [`Scalar`](interfaces/Scalar.md) | Decorator target, either a string model or a property with type string. |

#### Returns

`void`

___

### $service

▸ **$service**(`context`, `target`, `options?`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`Namespace`](interfaces/Namespace.md) |
| `options?` | [`Model`](interfaces/Model.md) |

#### Returns

`void`

___

### $summary

▸ **$summary**(`context`, `target`, `text`, `sourceObject`): `void`

**`Summary`**

attaches a documentation string. It is typically used to give a short, single-line
description, and can be used in combination with or instead of @doc.

The first argument to

**`Summary`**

is a string, which may contain template parameters, enclosed in braces,
which are replaced with an attribute for the type (commonly "name") passed as the second (optional) argument.

**`Summary`**

can be specified on any language element -- a model, an operation, a namespace, etc.

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`Type`](index.md#type) |
| `text` | `string` |
| `sourceObject` | [`Type`](index.md#type) |

#### Returns

`void`

___

### $tag

▸ **$tag**(`context`, `target`, `tag`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`Interface`](interfaces/Interface.md) \| [`Namespace`](interfaces/Namespace.md) \| [`Operation`](interfaces/Operation.md) |
| `tag` | `string` |

#### Returns

`void`

___

### $visibility

▸ **$visibility**(`context`, `target`, `...visibilities`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`ModelProperty`](interfaces/ModelProperty.md) |
| `...visibilities` | `string`[] |

#### Returns

`void`

___

### $withDefaultKeyVisibility

▸ **$withDefaultKeyVisibility**(`context`, `entity`, `visibility`): `void`

`@withDefaultKeyVisibility` - set the visibility of key properties in a model if not already set

The first argument accepts a string representing the desired default
visibility value.  If a key property already has a `visibility` decorator
then the default visibility is not applied.

`@withDefaultKeyVisibility` can only be applied to model types.

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `entity` | [`Model`](interfaces/Model.md) |
| `visibility` | `string` |

#### Returns

`void`

___

### $withOptionalProperties

▸ **$withOptionalProperties**(`context`, `target`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`Model`](interfaces/Model.md) |

#### Returns

`void`

___

### $withUpdateableProperties

▸ **$withUpdateableProperties**(`context`, `target`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`Type`](index.md#type) |

#### Returns

`void`

___

### $withVisibility

▸ **$withVisibility**(`context`, `target`, `...visibilities`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`Model`](interfaces/Model.md) |
| `...visibilities` | `string`[] |

#### Returns

`void`

___

### $withoutDefaultValues

▸ **$withoutDefaultValues**(`context`, `target`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`Model`](interfaces/Model.md) |

#### Returns

`void`

___

### $withoutOmittedProperties

▸ **$withoutOmittedProperties**(`context`, `target`, `omitProperties`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`Model`](interfaces/Model.md) |
| `omitProperties` | `string` \| [`Union`](interfaces/Union.md) |

#### Returns

`void`

___

### addService

▸ **addService**(`program`, `namespace`, `details?`): `void`

Mark the given namespace as a service.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | Program |
| `namespace` | [`Namespace`](interfaces/Namespace.md) | Namespace |
| `details` | [`ServiceDetails`](interfaces/decorators.ServiceDetails.md) | Service details |

#### Returns

`void`

___

### assertType

▸ **assertType**<`TKind`\>(`typeDescription`, `t`, `...kinds`): asserts t is Object

Assert that the input type has one of the kinds provided

#### Type parameters

| Name | Type |
| :------ | :------ |
| `TKind` | extends (``"Projection"`` \| ``"Model"`` \| ``"ModelProperty"`` \| ``"Scalar"`` \| ``"Interface"`` \| ``"Enum"`` \| ``"EnumMember"`` \| ``"TemplateParameter"`` \| ``"Namespace"`` \| ``"Operation"`` \| ``"String"`` \| ``"Number"`` \| ``"Boolean"`` \| ``"Tuple"`` \| ``"Union"`` \| ``"UnionVariant"`` \| ``"Intrinsic"`` \| ``"Function"`` \| ``"Decorator"`` \| ``"FunctionParameter"`` \| ``"Object"``)[] |

#### Parameters

| Name | Type |
| :------ | :------ |
| `typeDescription` | `string` |
| `t` | [`Type`](index.md#type) |
| `...kinds` | `TKind` |

#### Returns

asserts t is Object

___

### cadlTypeToJson

▸ **cadlTypeToJson**<`T`\>(`typespecType`, `target`): [`T` \| `undefined`, [`Diagnostic`](interfaces/Diagnostic.md)[]]

**`Deprecated`**

use typespecTypeToJson

#### Type parameters

| Name |
| :------ |
| `T` |

#### Parameters

| Name | Type |
| :------ | :------ |
| `typespecType` | [`TypeSpecValue`](index.md#typespecvalue) |
| `target` | [`DiagnosticTarget`](index.md#diagnostictarget) |

#### Returns

[`T` \| `undefined`, [`Diagnostic`](interfaces/Diagnostic.md)[]]

___

### checkFormatCadl

▸ **checkFormatCadl**(`code`, `prettierConfig?`): `Promise`<`boolean`\>

**`Deprecated`**

use checkFormatTypeSpec

#### Parameters

| Name | Type |
| :------ | :------ |
| `code` | `string` |
| `prettierConfig?` | `Options` |

#### Returns

`Promise`<`boolean`\>

___

### checkFormatTypeSpec

▸ **checkFormatTypeSpec**(`code`, `prettierConfig?`): `Promise`<`boolean`\>

Check the given is correctly formatted.

#### Parameters

| Name | Type |
| :------ | :------ |
| `code` | `string` |
| `prettierConfig?` | `Options` |

#### Returns

`Promise`<`boolean`\>

true if code is formatted correctly.

___

### compile

▸ **compile**(`host`, `mainFile`, `options?`, `oldProgram?`): `Promise`<[`Program`](interfaces/Program.md)\>

#### Parameters

| Name | Type |
| :------ | :------ |
| `host` | [`CompilerHost`](interfaces/CompilerHost.md) |
| `mainFile` | `string` |
| `options` | `CompilerOptions` |
| `oldProgram?` | [`Program`](interfaces/Program.md) |

#### Returns

`Promise`<[`Program`](interfaces/Program.md)\>

___

### compilerAssert

▸ **compilerAssert**(`condition`, `message`, `target?`): asserts condition

Use this to report bugs in the compiler, and not errors in the source code
being compiled.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `condition` | `any` | Throw if this is not true. |
| `message` | `string` | Error message. |
| `target?` | [`DiagnosticTarget`](index.md#diagnostictarget) | Optional location in source code that might give a clue about what got the compiler off track. |

#### Returns

asserts condition

___

### createCadlLibrary

▸ **createCadlLibrary**<`T`, `E`\>(`lib`): [`TypeSpecLibrary`](interfaces/TypeSpecLibrary.md)<`T`, `E`\>

**`Deprecated`**

use createTypeSpecLibrary

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends `Object` |
| `E` | extends `Record`<`string`, `any`\> |

#### Parameters

| Name | Type |
| :------ | :------ |
| `lib` | `Readonly`<[`TypeSpecLibraryDef`](interfaces/TypeSpecLibraryDef.md)<`T`, `E`\>\> |

#### Returns

[`TypeSpecLibrary`](interfaces/TypeSpecLibrary.md)<`T`, `E`\>

___

### createChecker

▸ **createChecker**(`program`): [`Checker`](interfaces/Checker.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |

#### Returns

[`Checker`](interfaces/Checker.md)

___

### createDecoratorDefinition

▸ **createDecoratorDefinition**<`T`, `P`, `S`\>(`definition`): [`DecoratorValidator`](interfaces/DecoratorValidator.md)<`T`, `P`, `S`\>

**`Deprecated`**

use extern dec definition in typespec instead.

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends [`TypeKind`](index.md#typekind) |
| `P` | extends readonly [`DecoratorParamDefinition`](interfaces/DecoratorParamDefinition.md)<[`TypeKind`](index.md#typekind)\>[] |
| `S` | extends `undefined` \| [`DecoratorParamDefinition`](interfaces/DecoratorParamDefinition.md)<[`TypeKind`](index.md#typekind)\> |

#### Parameters

| Name | Type |
| :------ | :------ |
| `definition` | [`DecoratorDefinition`](interfaces/DecoratorDefinition.md)<`T`, `P`, `S`\> |

#### Returns

[`DecoratorValidator`](interfaces/DecoratorValidator.md)<`T`, `P`, `S`\>

___

### createDiagnosticCollector

▸ **createDiagnosticCollector**(): [`DiagnosticCollector`](interfaces/DiagnosticCollector.md)

Create a new instance of the

**`See`**

DiagnosticCollector.

#### Returns

[`DiagnosticCollector`](interfaces/DiagnosticCollector.md)

___

### createDiagnosticCreator

▸ **createDiagnosticCreator**<`T`\>(`diagnostics`, `libraryName?`): [`DiagnosticCreator`](interfaces/DiagnosticCreator.md)<`T`\>

Create a new diagnostics creator.

**`See`**

DiagnosticCreator

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends `Object` |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `diagnostics` | [`DiagnosticMap`](index.md#diagnosticmap)<`T`\> | Map of the potential diagnostics. |
| `libraryName?` | `string` | Optional name of the library if in the scope of a library. |

#### Returns

[`DiagnosticCreator`](interfaces/DiagnosticCreator.md)<`T`\>

___

### createProjectedNameProgram

▸ **createProjectedNameProgram**(`program`, `target`): [`ProjectedNameView`](interfaces/ProjectedNameView.md)

Create an helper to manager project names.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | Program |
| `target` | `string` | Name of the projected name target(e.g. json, csharp, etc.) |

#### Returns

[`ProjectedNameView`](interfaces/ProjectedNameView.md)

ProjectedNameView

___

### createScanner

▸ **createScanner**(`source`, `diagnosticHandler`): [`Scanner`](interfaces/Scanner.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `source` | `string` \| [`SourceFile`](interfaces/SourceFile.md) |
| `diagnosticHandler` | [`DiagnosticHandler`](index.md#diagnostichandler) |

#### Returns

[`Scanner`](interfaces/Scanner.md)

___

### createServer

▸ **createServer**(`host`): [`Server`](interfaces/Server.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `host` | [`ServerHost`](interfaces/ServerHost.md) |

#### Returns

[`Server`](interfaces/Server.md)

___

### createSourceFile

▸ **createSourceFile**(`text`, `path`): [`SourceFile`](interfaces/SourceFile.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `text` | `string` |
| `path` | `string` |

#### Returns

[`SourceFile`](interfaces/SourceFile.md)

___

### createStateAccessors

▸ **createStateAccessors**(`stateMaps`, `stateSets`, `projector?`): `Object`

#### Parameters

| Name | Type |
| :------ | :------ |
| `stateMaps` | `Map`<`symbol`, `StateMap`\> |
| `stateSets` | `Map`<`symbol`, `StateSet`\> |
| `projector?` | [`Projector`](interfaces/Projector.md) |

#### Returns

`Object`

| Name | Type |
| :------ | :------ |
| `stateMap` | <T\>(`key`: `symbol`) => `StateMapView`<`T`\> |
| `stateSet` | (`key`: `symbol`) => `StateSetView` |

___

### createTypeSpecLibrary

▸ **createTypeSpecLibrary**<`T`, `E`\>(`lib`): [`TypeSpecLibrary`](interfaces/TypeSpecLibrary.md)<`T`, `E`\>

Create a new TypeSpec library definition.

**`Tutorial`**

Create the lib object with `as const` to get the full typing.

**`Example`**

```ts
const libDef = {
  name: "myLib",
  diagnostics: {
   "my-code": {serverity: "error", messages: {default: "Foo bar"}}
  },
} as const;

const lib = createTypeSpecLibrary(libDef);
```

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends `Object` |
| `E` | extends `Record`<`string`, `any`\> |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `lib` | `Readonly`<[`TypeSpecLibraryDef`](interfaces/TypeSpecLibraryDef.md)<`T`, `E`\>\> | Library definition. |

#### Returns

[`TypeSpecLibrary`](interfaces/TypeSpecLibrary.md)<`T`, `E`\>

Library with utility functions.

___

### emitFile

▸ **emitFile**(`program`, `options`): `Promise`<`void`\>

Helper to emit a file.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | TypeSpec Program |
| `options` | [`EmitFileOptions`](interfaces/EmitFileOptions.md) | File Emitter options |

#### Returns

`Promise`<`void`\>

___

### ensureTrailingDirectorySeparator

▸ **ensureTrailingDirectorySeparator**(`path`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |

#### Returns

`string`

___

### filterModelProperties

▸ **filterModelProperties**(`program`, `model`, `filter`): [`Model`](interfaces/Model.md)

Applies a filter to the properties of a given type. If no properties
are filtered out, then return the input unchanged. Otherwise, return
a new anonymous model with only the filtered properties.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) \| [`ProjectedProgram`](interfaces/ProjectedProgram.md) | - |
| `model` | [`Model`](interfaces/Model.md) | The input model to filter. |
| `filter` | (`property`: [`ModelProperty`](interfaces/ModelProperty.md)) => `boolean` | The filter to apply. Properties are kept when this returns true. |

#### Returns

[`Model`](interfaces/Model.md)

___

### finishTypeForProgram

▸ **finishTypeForProgram**<`T`\>(`program`, `typeDef`, `mapper?`): `T`

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends [`Type`](index.md#type) |

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `typeDef` | `T` |
| `mapper?` | [`TypeMapper`](interfaces/TypeMapper.md) |

#### Returns

`T`

___

### formatDiagnostic

▸ **formatDiagnostic**(`diagnostic`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `diagnostic` | [`Diagnostic`](interfaces/Diagnostic.md) |

#### Returns

`string`

___

### formatIdentifier

▸ **formatIdentifier**(`sv`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `sv` | `string` |

#### Returns

`string`

___

### formatTypeSpec

▸ **formatTypeSpec**(`code`, `prettierConfig?`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `code` | `string` |
| `prettierConfig?` | `Options` |

#### Returns

`string`

___

### getAllTags

▸ **getAllTags**(`program`, `target`): `string`[] \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `target` | [`Interface`](interfaces/Interface.md) \| [`Namespace`](interfaces/Namespace.md) \| [`Operation`](interfaces/Operation.md) |

#### Returns

`string`[] \| `undefined`

___

### getAnyExtensionFromPath

▸ **getAnyExtensionFromPath**(`path`): `string`

Gets the file extension for a path.
Normalizes it to lower case.

```ts
getAnyExtensionFromPath("/path/to/file.ext") === ".ext"
getAnyExtensionFromPath("/path/to/file.ext/") === ".ext"
getAnyExtensionFromPath("/path/to/file") === ""
getAnyExtensionFromPath("/path/to.ext/file") === ""
```

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |

#### Returns

`string`

___

### getBaseFileName

▸ **getBaseFileName**(`path`): `string`

Returns the path except for its containing directory name.
Semantics align with NodeJS's `path.basename` except that we support URL's as well.

```ts
// POSIX
getBaseFileName("/path/to/file.ext") === "file.ext"
getBaseFileName("/path/to/") === "to"
getBaseFileName("/") === ""
// DOS
getBaseFileName("c:/path/to/file.ext") === "file.ext"
getBaseFileName("c:/path/to/") === "to"
getBaseFileName("c:/") === ""
getBaseFileName("c:") === ""
// URL
getBaseFileName("http://typescriptlang.org/path/to/file.ext") === "file.ext"
getBaseFileName("http://typescriptlang.org/path/to/") === "to"
getBaseFileName("http://typescriptlang.org/") === ""
getBaseFileName("http://typescriptlang.org") === ""
getBaseFileName("file://server/path/to/file.ext") === "file.ext"
getBaseFileName("file://server/path/to/") === "to"
getBaseFileName("file://server/") === ""
getBaseFileName("file://server") === ""
getBaseFileName("file:///path/to/file.ext") === "file.ext"
getBaseFileName("file:///path/to/") === "to"
getBaseFileName("file:///") === ""
getBaseFileName("file://") === ""
```

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |

#### Returns

`string`

___

### getCompletionNodeAtPosition

▸ **getCompletionNodeAtPosition**(`script`, `position`, `filter?`): [`Node`](index.md#node) \| `undefined`

Resolve the node that should be auto completed at the given position.
It will try to guess what node it could be as during auto complete the ast might not be complete.

#### Parameters

| Name | Type |
| :------ | :------ |
| `script` | [`TypeSpecScriptNode`](interfaces/TypeSpecScriptNode.md) |
| `position` | `number` |
| `filter` | (`node`: [`Node`](index.md#node)) => `boolean` |

#### Returns

[`Node`](index.md#node) \| `undefined`

___

### getDeprecated

▸ **getDeprecated**(`program`, `type`): `string` \| `undefined`

Return the deprecated message or undefined if not deprecated

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | Program |
| `type` | [`Type`](index.md#type) | Type |

#### Returns

`string` \| `undefined`

___

### getDirectoryPath

▸ **getDirectoryPath**(`path`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |

#### Returns

`string`

___

### getDiscriminatedTypes

▸ **getDiscriminatedTypes**(`program`): [[`Model`](interfaces/Model.md) \| [`Union`](interfaces/Union.md), [`Discriminator`](interfaces/decorators.Discriminator.md)][]

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |

#### Returns

[[`Model`](interfaces/Model.md) \| [`Union`](interfaces/Union.md), [`Discriminator`](interfaces/decorators.Discriminator.md)][]

___

### getDiscriminatedUnion

▸ **getDiscriminatedUnion**(`type`, `discriminator`): [[`DiscriminatedUnion`](interfaces/DiscriminatedUnion.md), readonly [`Diagnostic`](interfaces/Diagnostic.md)[]]

#### Parameters

| Name | Type |
| :------ | :------ |
| `type` | [`Model`](interfaces/Model.md) \| [`Union`](interfaces/Union.md) |
| `discriminator` | [`Discriminator`](interfaces/decorators.Discriminator.md) |

#### Returns

[[`DiscriminatedUnion`](interfaces/DiscriminatedUnion.md), readonly [`Diagnostic`](interfaces/Diagnostic.md)[]]

___

### getDiscriminator

▸ **getDiscriminator**(`program`, `entity`): [`Discriminator`](interfaces/decorators.Discriminator.md) \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `entity` | [`Type`](index.md#type) |

#### Returns

[`Discriminator`](interfaces/decorators.Discriminator.md) \| `undefined`

___

### getDoc

▸ **getDoc**(`program`, `target`): `string` \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `target` | [`Type`](index.md#type) |

#### Returns

`string` \| `undefined`

___

### getEffectiveModelType

▸ **getEffectiveModelType**(`program`, `model`, `filter?`): [`Model`](interfaces/Model.md)

If the input is anonymous (or the provided filter removes properties)
and there exists a named model with the same set of properties
(ignoring filtered properties), then return that named model.
Otherwise, return the input unchanged.

This can be used by emitters to find a better name for a set of
properties after filtering. For example, given `{ @metadata prop:
string} & SomeName`, and an emitter that wishes to discard properties
marked with `@metadata`, the emitter can use this to recover that the
best name for the remaining properties is `SomeName`.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | - |
| `model` | [`Model`](interfaces/Model.md) | The input model |
| `filter?` | (`property`: [`ModelProperty`](interfaces/ModelProperty.md)) => `boolean` | An optional filter to apply to the input model's properties. |

#### Returns

[`Model`](interfaces/Model.md)

___

### getFirstAncestor

▸ **getFirstAncestor**(`node`, `test`): [`Node`](index.md#node) \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `node` | [`Node`](index.md#node) |
| `test` | [`NodeCallback`](index.md#nodecallback)<`boolean`\> |

#### Returns

[`Node`](index.md#node) \| `undefined`

___

### getFormat

▸ **getFormat**(`program`, `target`): `string` \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `target` | [`Type`](index.md#type) |

#### Returns

`string` \| `undefined`

___

### getFriendlyName

▸ **getFriendlyName**(`program`, `target`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `target` | [`Type`](index.md#type) |

#### Returns

`string`

___

### getIdentifierContext

▸ **getIdentifierContext**(`id`): [`IdentifierContext`](interfaces/IdentifierContext.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `id` | [`IdentifierNode`](interfaces/IdentifierNode.md) |

#### Returns

[`IdentifierContext`](interfaces/IdentifierContext.md)

___

### getIndexer

▸ **getIndexer**(`program`, `target`): [`ModelIndexer`](index.md#modelindexer) \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `target` | [`Type`](index.md#type) |

#### Returns

[`ModelIndexer`](index.md#modelindexer) \| `undefined`

___

### getKeyName

▸ **getKeyName**(`program`, `property`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `property` | [`ModelProperty`](interfaces/ModelProperty.md) |

#### Returns

`string`

___

### getKnownValues

▸ **getKnownValues**(`program`, `target`): [`Enum`](interfaces/Enum.md) \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `target` | [`ModelProperty`](interfaces/ModelProperty.md) \| [`Scalar`](interfaces/Scalar.md) |

#### Returns

[`Enum`](interfaces/Enum.md) \| `undefined`

___

### getListOperationType

▸ **getListOperationType**(`program`, `target`): [`Model`](interfaces/Model.md) \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `target` | [`Type`](index.md#type) |

#### Returns

[`Model`](interfaces/Model.md) \| `undefined`

___

### getMaxItems

▸ **getMaxItems**(`program`, `target`): `number` \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `target` | [`Type`](index.md#type) |

#### Returns

`number` \| `undefined`

___

### getMaxLength

▸ **getMaxLength**(`program`, `target`): `number` \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `target` | [`Type`](index.md#type) |

#### Returns

`number` \| `undefined`

___

### getMaxValue

▸ **getMaxValue**(`program`, `target`): `number` \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `target` | [`Type`](index.md#type) |

#### Returns

`number` \| `undefined`

___

### getMaxValueExclusive

▸ **getMaxValueExclusive**(`program`, `target`): `number` \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `target` | [`Type`](index.md#type) |

#### Returns

`number` \| `undefined`

___

### getMinItems

▸ **getMinItems**(`program`, `target`): `number` \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `target` | [`Type`](index.md#type) |

#### Returns

`number` \| `undefined`

___

### getMinLength

▸ **getMinLength**(`program`, `target`): `number` \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `target` | [`Type`](index.md#type) |

#### Returns

`number` \| `undefined`

___

### getMinValue

▸ **getMinValue**(`program`, `target`): `number` \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `target` | [`Type`](index.md#type) |

#### Returns

`number` \| `undefined`

___

### getMinValueExclusive

▸ **getMinValueExclusive**(`program`, `target`): `number` \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `target` | [`Type`](index.md#type) |

#### Returns

`number` \| `undefined`

___

### getNamespaceFullName

▸ **getNamespaceFullName**(`type`, `options?`): `string`

Return the full name of the namespace(e.g. "Foo.Bar")

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `type` | [`Namespace`](interfaces/Namespace.md) | namespace type |
| `options?` | [`TypeNameOptions`](interfaces/TypeNameOptions.md) |  |

#### Returns

`string`

___

### getNodeAtPosition

▸ **getNodeAtPosition**(`script`, `position`, `filter?`): [`Node`](index.md#node) \| `undefined`

Resolve the node in the syntax tree that that is at the given position.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `script` | [`TypeSpecScriptNode`](interfaces/TypeSpecScriptNode.md) | TypeSpec Script node |
| `position` | `number` | Position |
| `filter` | (`node`: [`Node`](index.md#node)) => `boolean` | Filter if wanting to return a parent containing node early. |

#### Returns

[`Node`](index.md#node) \| `undefined`

___

### getNormalizedAbsolutePath

▸ **getNormalizedAbsolutePath**(`fileName`, `currentDirectory`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `fileName` | `string` |
| `currentDirectory` | `undefined` \| `string` |

#### Returns

`string`

___

### getNormalizedAbsolutePathWithoutRoot

▸ **getNormalizedAbsolutePathWithoutRoot**(`fileName`, `currentDirectory`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `fileName` | `string` |
| `currentDirectory` | `undefined` \| `string` |

#### Returns

`string`

___

### getNormalizedPathComponents

▸ **getNormalizedPathComponents**(`path`, `currentDirectory`): `string`[]

Parse a path into an array containing a root component (at index 0) and zero or more path
components (at indices > 0). The result is normalized.
If the path is relative, the root component is `""`.
If the path is absolute, the root component includes the first path separator (`/`).

```ts
getNormalizedPathComponents("to/dir/../file.ext", "/path/") === ["/", "path", "to", "file.ext"]
```

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |
| `currentDirectory` | `undefined` \| `string` |

#### Returns

`string`[]

___

### getOverloadedOperation

▸ **getOverloadedOperation**(`program`, `operation`): [`Operation`](interfaces/Operation.md) \| `undefined`

If the given operation overloads another operation, return that operation.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | Program |
| `operation` | [`Operation`](interfaces/Operation.md) | The operation to check for an overload target. |

#### Returns

[`Operation`](interfaces/Operation.md) \| `undefined`

The operation this operation overloads, if any.

___

### getOverloads

▸ **getOverloads**(`program`, `operation`): [`Operation`](interfaces/Operation.md)[] \| `undefined`

Get all operations that are marked as overloads of the given operation

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | Program |
| `operation` | [`Operation`](interfaces/Operation.md) | Operation |

#### Returns

[`Operation`](interfaces/Operation.md)[] \| `undefined`

An array of operations that overload the given operation.

___

### getOverriddenProperty

▸ **getOverriddenProperty**(`property`): [`ModelProperty`](interfaces/ModelProperty.md) \| `undefined`

Gets the property from the nearest base type that is overridden by the
given property, if any.

#### Parameters

| Name | Type |
| :------ | :------ |
| `property` | [`ModelProperty`](interfaces/ModelProperty.md) |

#### Returns

[`ModelProperty`](interfaces/ModelProperty.md) \| `undefined`

___

### getParentTemplateNode

▸ **getParentTemplateNode**(`node`): [`Node`](index.md#node) & [`TemplateDeclarationNode`](interfaces/TemplateDeclarationNode.md) \| `undefined`

Lookup and find the node

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `node` | [`Node`](index.md#node) | Node |

#### Returns

[`Node`](index.md#node) & [`TemplateDeclarationNode`](interfaces/TemplateDeclarationNode.md) \| `undefined`

Template Parent node if applicable

___

### getPathComponents

▸ **getPathComponents**(`path`, `currentDirectory?`): `string`[]

Parse a path into an array containing a root component (at index 0) and zero or more path
components (at indices > 0). The result is not normalized.
If the path is relative, the root component is `""`.
If the path is absolute, the root component includes the first path separator (`/`).

```ts
// POSIX
getPathComponents("/path/to/file.ext") === ["/", "path", "to", "file.ext"]
getPathComponents("/path/to/") === ["/", "path", "to"]
getPathComponents("/") === ["/"]
// DOS
getPathComponents("c:/path/to/file.ext") === ["c:/", "path", "to", "file.ext"]
getPathComponents("c:/path/to/") === ["c:/", "path", "to"]
getPathComponents("c:/") === ["c:/"]
getPathComponents("c:") === ["c:"]
// URL
getPathComponents("http://typescriptlang.org/path/to/file.ext") === ["http://typescriptlang.org/", "path", "to", "file.ext"]
getPathComponents("http://typescriptlang.org/path/to/") === ["http://typescriptlang.org/", "path", "to"]
getPathComponents("http://typescriptlang.org/") === ["http://typescriptlang.org/"]
getPathComponents("http://typescriptlang.org") === ["http://typescriptlang.org"]
getPathComponents("file://server/path/to/file.ext") === ["file://server/", "path", "to", "file.ext"]
getPathComponents("file://server/path/to/") === ["file://server/", "path", "to"]
getPathComponents("file://server/") === ["file://server/"]
getPathComponents("file://server") === ["file://server"]
getPathComponents("file:///path/to/file.ext") === ["file:///", "path", "to", "file.ext"]
getPathComponents("file:///path/to/") === ["file:///", "path", "to"]
getPathComponents("file:///") === ["file:///"]
getPathComponents("file://") === ["file://"]

#### Parameters

| Name | Type | Default value |
| :------ | :------ | :------ |
| `path` | `string` | `undefined` |
| `currentDirectory` | `string` | `""` |

#### Returns

`string`[]

___

### getPathFromPathComponents

▸ **getPathFromPathComponents**(`pathComponents`): `string`

Formats a parsed path consisting of a root component (at index 0) and zero or more path
segments (at indices > 0).

```ts
getPathFromPathComponents(["/", "path", "to", "file.ext"]) === "/path/to/file.ext"
```

#### Parameters

| Name | Type |
| :------ | :------ |
| `pathComponents` | readonly `string`[] |

#### Returns

`string`

___

### getPattern

▸ **getPattern**(`program`, `target`): `string` \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `target` | [`Type`](index.md#type) |

#### Returns

`string` \| `undefined`

___

### getProjectedName

▸ **getProjectedName**(`program`, `target`, `projectionName`): `string` \| `undefined`

Get the projected name of the given entity for the given projection.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | Program |
| `target` | [`Type`](index.md#type) | Target |
| `projectionName` | `string` | - |

#### Returns

`string` \| `undefined`

Projected name for the given projection

___

### getProjectedNames

▸ **getProjectedNames**(`program`, `target`): `ReadonlyMap`<`string`, `string`\> \| `undefined`

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | Program |
| `target` | [`Type`](index.md#type) | Target |

#### Returns

`ReadonlyMap`<`string`, `string`\> \| `undefined`

Map of the projected names for the given entity.

___

### getProperty

▸ **getProperty**(`type`, `propertyName`): [`ModelProperty`](interfaces/ModelProperty.md) \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `type` | [`Model`](interfaces/Model.md) |
| `propertyName` | `string` |

#### Returns

[`ModelProperty`](interfaces/ModelProperty.md) \| `undefined`

___

### getPropertyType

▸ **getPropertyType**(`target`): [`Type`](index.md#type)

Return the type of the property or the model itself.

#### Parameters

| Name | Type |
| :------ | :------ |
| `target` | [`ModelProperty`](interfaces/ModelProperty.md) \| [`Scalar`](interfaces/Scalar.md) |

#### Returns

[`Type`](index.md#type)

___

### getRootLength

▸ **getRootLength**(`path`): `number`

Returns length of the root part of a path or URL (i.e. length of "/", "x:/", "//server/share/, file:///user/files").

For example:
```ts
getRootLength("a") === 0                   // ""
getRootLength("/") === 1                   // "/"
getRootLength("c:") === 2                  // "c:"
getRootLength("c:d") === 0                 // ""
getRootLength("c:/") === 3                 // "c:/"
getRootLength("c:\\") === 3                // "c:\\"
getRootLength("//server") === 7            // "//server"
getRootLength("//server/share") === 8      // "//server/"
getRootLength("\\\\server") === 7          // "\\\\server"
getRootLength("\\\\server\\share") === 8   // "\\\\server\\"
getRootLength("file:///path") === 8        // "file:///"
getRootLength("file:///c:") === 10         // "file:///c:"
getRootLength("file:///c:d") === 8         // "file:///"
getRootLength("file:///c:/path") === 11    // "file:///c:/"
getRootLength("file://server") === 13      // "file://server"
getRootLength("file://server/path") === 14 // "file://server/"
getRootLength("http://server") === 13      // "http://server"
getRootLength("http://server/path") === 14 // "http://server/"
```

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |

#### Returns

`number`

___

### getService

▸ **getService**(`program`, `namespace`): [`Service`](interfaces/decorators.Service.md) \| `undefined`

Get the service information for the given namespace.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | Program |
| `namespace` | [`Namespace`](interfaces/Namespace.md) | Service namespace |

#### Returns

[`Service`](interfaces/decorators.Service.md) \| `undefined`

Service information or undefined if namespace is not a service namespace.

___

### getSourceFileKindFromExt

▸ **getSourceFileKindFromExt**(`path`): [`SourceFileKind`](index.md#sourcefilekind) \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |

#### Returns

[`SourceFileKind`](index.md#sourcefilekind) \| `undefined`

___

### getSourceLocation

▸ **getSourceLocation**(`target`): [`SourceLocation`](interfaces/SourceLocation.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `target` | [`DiagnosticTarget`](index.md#diagnostictarget) |

#### Returns

[`SourceLocation`](interfaces/SourceLocation.md)

▸ **getSourceLocation**(`target`): `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `target` | `undefined` \| typeof [`NoTarget`](index.md#notarget) |

#### Returns

`undefined`

▸ **getSourceLocation**(`target`): [`SourceLocation`](interfaces/SourceLocation.md) \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `target` | `undefined` \| [`DiagnosticTarget`](index.md#diagnostictarget) \| typeof [`NoTarget`](index.md#notarget) |

#### Returns

[`SourceLocation`](interfaces/SourceLocation.md) \| `undefined`

___

### getSummary

▸ **getSummary**(`program`, `type`): `string` \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `type` | [`Type`](index.md#type) |

#### Returns

`string` \| `undefined`

___

### getTags

▸ **getTags**(`program`, `target`): `string`[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `target` | [`Type`](index.md#type) |

#### Returns

`string`[]

___

### getTypeName

▸ **getTypeName**(`type`, `options?`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `type` | [`Type`](index.md#type) |
| `options?` | [`TypeNameOptions`](interfaces/TypeNameOptions.md) |

#### Returns

`string`

___

### getVisibility

▸ **getVisibility**(`program`, `target`): `string`[] \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `target` | [`Type`](index.md#type) |

#### Returns

`string`[] \| `undefined`

___

### hasParseError

▸ **hasParseError**(`node`): `number` \| ``true``

#### Parameters

| Name | Type |
| :------ | :------ |
| `node` | [`Node`](index.md#node) |

#### Returns

`number` \| ``true``

___

### hasProjectedName

▸ **hasProjectedName**(`program`, `target`, `projectionName`): `boolean`

Get the projected name of the given entity for the given projection.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | Program |
| `target` | [`Type`](index.md#type) | Target |
| `projectionName` | `string` | - |

#### Returns

`boolean`

Projected name for the given projection

___

### hasTrailingDirectorySeparator

▸ **hasTrailingDirectorySeparator**(`path`): `boolean`

Determines whether a path has a trailing separator (`/` or `\\`).

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |

#### Returns

`boolean`

___

### ignoreDiagnostics

▸ **ignoreDiagnostics**<`T`\>(`result`): `T`

Ignore the diagnostics emitted by the diagnostic accessor pattern and just return the actual result.

#### Type parameters

| Name |
| :------ |
| `T` |

#### Parameters

| Name | Type |
| :------ | :------ |
| `result` | [`DiagnosticResult`](index.md#diagnosticresult)<`T`\> |

#### Returns

`T`

Actual result.

___

### isAnyDirectorySeparator

▸ **isAnyDirectorySeparator**(`charCode`): `boolean`

Determines whether a charCode corresponds to `/` or ``.

#### Parameters

| Name | Type |
| :------ | :------ |
| `charCode` | `number` |

#### Returns

`boolean`

___

### isArrayModelType

▸ **isArrayModelType**(`program`, `type`): type is ArrayModelType

Check if a model is an array type.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | - |
| `type` | [`Model`](interfaces/Model.md) | Model type |

#### Returns

type is ArrayModelType

___

### isCadlValueTypeOf

▸ **isCadlValueTypeOf**<`K`\>(`target`, `expectedType`): target is InferredTypeSpecValue<K\>

**`Deprecated`**

use isTypeSpecValueTypeOf

#### Type parameters

| Name | Type |
| :------ | :------ |
| `K` | extends [`TypeKind`](index.md#typekind) |

#### Parameters

| Name | Type |
| :------ | :------ |
| `target` | [`TypeSpecValue`](index.md#typespecvalue) |
| `expectedType` | `K` \| readonly `K`[] |

#### Returns

target is InferredTypeSpecValue<K\>

___

### isComment

▸ **isComment**(`token`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `token` | [`Token`](enums/Token.md) |

#### Returns

`boolean`

___

### isDeclaredInNamespace

▸ **isDeclaredInNamespace**(`type`, `namespace`, `options?`): `boolean`

Check if the given type is declared in the specified namespace or, optionally, its child namespaces.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `type` | [`Model`](interfaces/Model.md) \| [`Interface`](interfaces/Interface.md) \| [`Enum`](interfaces/Enum.md) \| [`Namespace`](interfaces/Namespace.md) \| [`Operation`](interfaces/Operation.md) | Type |
| `namespace` | [`Namespace`](interfaces/Namespace.md) | Namespace |
| `options` | `Object` | - |
| `options.recursive?` | `boolean` | - |

#### Returns

`boolean`

___

### isDeprecated

▸ **isDeprecated**(`program`, `type`): `boolean`

Check if the given type is deprecated

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | Program |
| `type` | [`Type`](index.md#type) | Type |

#### Returns

`boolean`

___

### isErrorModel

▸ **isErrorModel**(`program`, `target`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `target` | [`Type`](index.md#type) |

#### Returns

`boolean`

___

### isErrorType

▸ **isErrorType**(`type`): type is ErrorType

#### Parameters

| Name | Type |
| :------ | :------ |
| `type` | [`Type`](index.md#type) |

#### Returns

type is ErrorType

___

### isGlobalNamespace

▸ **isGlobalNamespace**(`program`, `namespace`): namespace is Namespace & Object

Check if the given namespace is the global namespace

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | Program |
| `namespace` | [`Namespace`](interfaces/Namespace.md) | Namespace |

#### Returns

namespace is Namespace & Object

___

### isImportStatement

▸ **isImportStatement**(`node`): node is ImportStatementNode

#### Parameters

| Name | Type |
| :------ | :------ |
| `node` | [`Node`](index.md#node) |

#### Returns

node is ImportStatementNode

___

### isKey

▸ **isKey**(`program`, `property`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `property` | [`ModelProperty`](interfaces/ModelProperty.md) |

#### Returns

`boolean`

___

### isKeyword

▸ **isKeyword**(`token`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `token` | [`Token`](enums/Token.md) |

#### Returns

`boolean`

___

### isListOperation

▸ **isListOperation**(`program`, `target`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `target` | [`Operation`](interfaces/Operation.md) |

#### Returns

`boolean`

___

### isModifier

▸ **isModifier**(`token`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `token` | [`Token`](enums/Token.md) |

#### Returns

`boolean`

___

### isNeverType

▸ **isNeverType**(`type`): type is NeverType

#### Parameters

| Name | Type |
| :------ | :------ |
| `type` | [`Type`](index.md#type) |

#### Returns

type is NeverType

___

### isNullType

▸ **isNullType**(`type`): type is NullType

#### Parameters

| Name | Type |
| :------ | :------ |
| `type` | [`Type`](index.md#type) |

#### Returns

type is NullType

___

### isNumericType

▸ **isNumericType**(`program`, `target`): target is Scalar

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) \| [`ProjectedProgram`](interfaces/ProjectedProgram.md) |
| `target` | [`Type`](index.md#type) |

#### Returns

target is Scalar

___

### isPathAbsolute

▸ **isPathAbsolute**(`path`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |

#### Returns

`boolean`

___

### isProjectedProgram

▸ **isProjectedProgram**(`program`): program is ProjectedProgram

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) \| [`ProjectedProgram`](interfaces/ProjectedProgram.md) |

#### Returns

program is ProjectedProgram

___

### isPunctuation

▸ **isPunctuation**(`token`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `token` | [`Token`](enums/Token.md) |

#### Returns

`boolean`

___

### isRecordModelType

▸ **isRecordModelType**(`program`, `type`): type is ArrayModelType

Check if a model is an array type.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | - |
| `type` | [`Model`](interfaces/Model.md) | Model type |

#### Returns

type is ArrayModelType

___

### isSecret

▸ **isSecret**(`program`, `target`): `boolean` \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `target` | [`Type`](index.md#type) |

#### Returns

`boolean` \| `undefined`

___

### isService

▸ **isService**(`program`, `namespace`): `boolean`

Check if the namespace is defined as a service.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | Program |
| `namespace` | [`Namespace`](interfaces/Namespace.md) | Namespace |

#### Returns

`boolean`

Boolean

___

### isStatementKeyword

▸ **isStatementKeyword**(`token`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `token` | [`Token`](enums/Token.md) |

#### Returns

`boolean`

___

### isStringType

▸ **isStringType**(`program`, `target`): target is Scalar

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) \| [`ProjectedProgram`](interfaces/ProjectedProgram.md) |
| `target` | [`Type`](index.md#type) |

#### Returns

target is Scalar

___

### isTemplateDeclaration

▸ **isTemplateDeclaration**(`type`): type is Object

Resolve if the type is a template type declaration(Non initialized template type).

#### Parameters

| Name | Type |
| :------ | :------ |
| `type` | [`TemplatedType`](index.md#templatedtype) |

#### Returns

type is Object

___

### isTemplateDeclarationOrInstance

▸ **isTemplateDeclarationOrInstance**(`type`): `boolean`

Resolve if the type was created from a template type or is a template type declaration.

#### Parameters

| Name | Type |
| :------ | :------ |
| `type` | [`TemplatedType`](index.md#templatedtype) |

#### Returns

`boolean`

___

### isTemplateInstance

▸ **isTemplateInstance**(`type`): type is Object

Check if the given type has template arguments.

#### Parameters

| Name | Type |
| :------ | :------ |
| `type` | [`Type`](index.md#type) |

#### Returns

type is Object

___

### isTrivia

▸ **isTrivia**(`token`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `token` | [`Token`](enums/Token.md) |

#### Returns

`boolean`

___

### isTypeSpecValueTypeOf

▸ **isTypeSpecValueTypeOf**<`K`\>(`target`, `expectedType`): target is InferredTypeSpecValue<K\>

Check if the given target is of any of the typespec types.

#### Type parameters

| Name | Type |
| :------ | :------ |
| `K` | extends [`TypeKind`](index.md#typekind) |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `target` | [`TypeSpecValue`](index.md#typespecvalue) | Target to validate. |
| `expectedType` | `K` \| readonly `K`[] | One or multiple allowed typespec types. |

#### Returns

target is InferredTypeSpecValue<K\>

boolean if the target is of one of the allowed types.

___

### isUnknownType

▸ **isUnknownType**(`type`): type is UnknownType

#### Parameters

| Name | Type |
| :------ | :------ |
| `type` | [`Type`](index.md#type) |

#### Returns

type is UnknownType

___

### isUrl

▸ **isUrl**(`path`): `boolean`

Determines whether a path starts with a URL scheme (e.g. starts with `http://`, `ftp://`, `file://`, etc.).

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |

#### Returns

`boolean`

___

### isVisible

▸ **isVisible**(`program`, `property`, `visibilities`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `property` | [`ModelProperty`](interfaces/ModelProperty.md) |
| `visibilities` | readonly `string`[] |

#### Returns

`boolean`

___

### isVoidType

▸ **isVoidType**(`type`): type is VoidType

#### Parameters

| Name | Type |
| :------ | :------ |
| `type` | [`Type`](index.md#type) |

#### Returns

type is VoidType

___

### joinPaths

▸ **joinPaths**(`path`, `...paths`): `string`

Combines paths. If a path is absolute, it replaces any previous path. Relative paths are not simplified.

```ts
// Non-rooted
joinPaths("path", "to", "file.ext") === "path/to/file.ext"
joinPaths("path", "dir", "..", "to", "file.ext") === "path/dir/../to/file.ext"
// POSIX
joinPaths("/path", "to", "file.ext") === "/path/to/file.ext"
joinPaths("/path", "/to", "file.ext") === "/to/file.ext"
// DOS
joinPaths("c:/path", "to", "file.ext") === "c:/path/to/file.ext"
joinPaths("c:/path", "c:/to", "file.ext") === "c:/to/file.ext"
// URL
joinPaths("file:///path", "to", "file.ext") === "file:///path/to/file.ext"
joinPaths("file:///path", "file:///to", "file.ext") === "file:///to/file.ext"
```

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |
| `...paths` | (`undefined` \| `string`)[] |

#### Returns

`string`

___

### listOperationsIn

▸ **listOperationsIn**(`container`, `options?`): [`Operation`](interfaces/Operation.md)[]

List operations in the given container. Will list operation recursively by default(Check subnamespaces.)

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `container` | [`Interface`](interfaces/Interface.md) \| [`Namespace`](interfaces/Namespace.md) | Container. |
| `options` | [`ListOperationOptions`](interfaces/ListOperationOptions.md) | Options. |

#### Returns

[`Operation`](interfaces/Operation.md)[]

___

### listServices

▸ **listServices**(`program`): [`Service`](interfaces/decorators.Service.md)[]

List all the services defined in the typespec program

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | Program |

#### Returns

[`Service`](interfaces/decorators.Service.md)[]

List of service.

___

### logDiagnostics

▸ **logDiagnostics**(`diagnostics`, `logger`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `diagnostics` | readonly [`Diagnostic`](interfaces/Diagnostic.md)[] |
| `logger` | [`LogSink`](interfaces/LogSink.md) |

#### Returns

`void`

___

### logVerboseTestOutput

▸ **logVerboseTestOutput**(`messageOrCallback`): `void`

Verbose output is enabled by default for runs in mocha explorer in VS Code,
where the output is nicely associated with the individual test, and disabled
by default for command line runs where we don't want to spam the console.

If the steps taken to produce the message are expensive, pass a callback
instead of producing the message then passing it here only to be dropped
when verbose output is disabled.

#### Parameters

| Name | Type |
| :------ | :------ |
| `messageOrCallback` | `string` \| (`log`: (`message`: `string`) => `void`) => `void` |

#### Returns

`void`

___

### mapEventEmitterToNodeListener

▸ **mapEventEmitterToNodeListener**(`eventEmitter`): [`SemanticNodeListener`](index.md#semanticnodelistener)

Create a Semantic node listener from an event emitter.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `eventEmitter` | [`EventEmitter`](classes/EventEmitter.md)<[`SemanticNodeListener`](index.md#semanticnodelistener)\> | Event emitter. |

#### Returns

[`SemanticNodeListener`](index.md#semanticnodelistener)

Semantic node listener.

___

### navigateProgram

▸ **navigateProgram**(`program`, `listeners`, `options?`): `void`

Navigate all types in the program.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | Program to navigate. |
| `listeners` | [`SemanticNodeListener`](index.md#semanticnodelistener) | Listener called when visiting types. |
| `options` | [`NavigationOptions`](interfaces/NavigationOptions.md) | Navigation options. |

#### Returns

`void`

___

### navigateType

▸ **navigateType**(`type`, `listeners`, `options`): `void`

Navigate the given type and all the types that are used in it.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `type` | [`Type`](index.md#type) | Type to navigate. |
| `listeners` | [`SemanticNodeListener`](index.md#semanticnodelistener) | Listener for the types found. |
| `options` | [`NavigationOptions`](interfaces/NavigationOptions.md) | Navigation options |

#### Returns

`void`

___

### navigateTypesInNamespace

▸ **navigateTypesInNamespace**(`namespace`, `listeners`, `options?`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `namespace` | [`Namespace`](interfaces/Namespace.md) |
| `listeners` | { `exitModel`: `undefined` \| `TypeListener`<[`Model`](interfaces/Model.md)\> ; `model`: `undefined` \| `TypeListener`<[`Model`](interfaces/Model.md)\>  } & { `exitModelProperty`: `undefined` \| `TypeListener`<[`ModelProperty`](interfaces/ModelProperty.md)\> ; `modelProperty`: `undefined` \| `TypeListener`<[`ModelProperty`](interfaces/ModelProperty.md)\>  } & { `exitScalar`: `undefined` \| `TypeListener`<[`Scalar`](interfaces/Scalar.md)\> ; `scalar`: `undefined` \| `TypeListener`<[`Scalar`](interfaces/Scalar.md)\>  } & { `exitInterface`: `undefined` \| `TypeListener`<[`Interface`](interfaces/Interface.md)\> ; `interface`: `undefined` \| `TypeListener`<[`Interface`](interfaces/Interface.md)\>  } & { `enum`: `undefined` \| `TypeListener`<[`Enum`](interfaces/Enum.md)\> ; `exitEnum`: `undefined` \| `TypeListener`<[`Enum`](interfaces/Enum.md)\>  } & { `enumMember`: `undefined` \| `TypeListener`<[`EnumMember`](interfaces/EnumMember.md)\> ; `exitEnumMember`: `undefined` \| `TypeListener`<[`EnumMember`](interfaces/EnumMember.md)\>  } & { `exitTemplateParameter`: `undefined` \| `TypeListener`<[`TemplateParameter`](interfaces/TemplateParameter.md)\> ; `templateParameter`: `undefined` \| `TypeListener`<[`TemplateParameter`](interfaces/TemplateParameter.md)\>  } & { `exitNamespace`: `undefined` \| `TypeListener`<[`Namespace`](interfaces/Namespace.md)\> ; `namespace`: `undefined` \| `TypeListener`<[`Namespace`](interfaces/Namespace.md)\>  } & { `exitOperation`: `undefined` \| `TypeListener`<[`Operation`](interfaces/Operation.md)\> ; `operation`: `undefined` \| `TypeListener`<[`Operation`](interfaces/Operation.md)\>  } & { `exitString`: `undefined` \| `TypeListener`<[`StringLiteral`](interfaces/StringLiteral.md)\> ; `string`: `undefined` \| `TypeListener`<[`StringLiteral`](interfaces/StringLiteral.md)\>  } & { `exitNumber`: `undefined` \| `TypeListener`<[`NumericLiteral`](interfaces/NumericLiteral.md)\> ; `number`: `undefined` \| `TypeListener`<[`NumericLiteral`](interfaces/NumericLiteral.md)\>  } & { `boolean`: `undefined` \| `TypeListener`<[`BooleanLiteral`](interfaces/BooleanLiteral.md)\> ; `exitBoolean`: `undefined` \| `TypeListener`<[`BooleanLiteral`](interfaces/BooleanLiteral.md)\>  } & { `exitTuple`: `undefined` \| `TypeListener`<[`Tuple`](interfaces/Tuple.md)\> ; `tuple`: `undefined` \| `TypeListener`<[`Tuple`](interfaces/Tuple.md)\>  } & { `exitUnion`: `undefined` \| `TypeListener`<[`Union`](interfaces/Union.md)\> ; `union`: `undefined` \| `TypeListener`<[`Union`](interfaces/Union.md)\>  } & { `exitUnionVariant`: `undefined` \| `TypeListener`<[`UnionVariant`](interfaces/UnionVariant.md)\> ; `unionVariant`: `undefined` \| `TypeListener`<[`UnionVariant`](interfaces/UnionVariant.md)\>  } & { `exitIntrinsic`: `undefined` \| `TypeListener`<[`IntrinsicType`](interfaces/IntrinsicType.md)\> ; `intrinsic`: `undefined` \| `TypeListener`<[`IntrinsicType`](interfaces/IntrinsicType.md)\>  } & { `exitFunction`: `undefined` \| `TypeListener`<[`FunctionType`](interfaces/FunctionType.md)\> ; `function`: `undefined` \| `TypeListener`<[`FunctionType`](interfaces/FunctionType.md)\>  } & { `decorator`: `undefined` \| `TypeListener`<[`Decorator`](interfaces/Decorator.md)\> ; `exitDecorator`: `undefined` \| `TypeListener`<[`Decorator`](interfaces/Decorator.md)\>  } & { `exitFunctionParameter`: `undefined` \| `TypeListener`<[`FunctionParameter`](interfaces/FunctionParameter.md)\> ; `functionParameter`: `undefined` \| `TypeListener`<[`FunctionParameter`](interfaces/FunctionParameter.md)\>  } & { `exitObject`: `undefined` \| `TypeListener`<[`ObjectType`](interfaces/ObjectType.md)\> ; `object`: `undefined` \| `TypeListener`<[`ObjectType`](interfaces/ObjectType.md)\>  } & { `exitProjection`: `undefined` \| `TypeListener`<[`Projection`](interfaces/Projection.md)\> ; `projection`: `undefined` \| `TypeListener`<[`Projection`](interfaces/Projection.md)\>  } |
| `options` | [`NamespaceNavigationOptions`](interfaces/NamespaceNavigationOptions.md) & [`NavigationOptions`](interfaces/NavigationOptions.md) |

#### Returns

`void`

___

### normalizePath

▸ **normalizePath**(`path`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |

#### Returns

`string`

___

### normalizeSlashes

▸ **normalizeSlashes**(`path`): `string`

Normalize path separators, converting `\` into `/`.

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |

#### Returns

`string`

___

### paramMessage

▸ **paramMessage**<`T`\>(`strings`, `...keys`): [`CallableMessage`](interfaces/CallableMessage.md)<`T`\>

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends `string`[] |

#### Parameters

| Name | Type |
| :------ | :------ |
| `strings` | readonly `string`[] |
| `...keys` | `T` |

#### Returns

[`CallableMessage`](interfaces/CallableMessage.md)<`T`\>

___

### parse

▸ **parse**(`code`, `options?`): [`TypeSpecScriptNode`](interfaces/TypeSpecScriptNode.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `code` | `string` \| [`SourceFile`](interfaces/SourceFile.md) |
| `options` | [`ParseOptions`](interfaces/ParseOptions.md) |

#### Returns

[`TypeSpecScriptNode`](interfaces/TypeSpecScriptNode.md)

___

### parseStandaloneTypeReference

▸ **parseStandaloneTypeReference**(`code`): [[`TypeReferenceNode`](interfaces/TypeReferenceNode.md), readonly [`Diagnostic`](interfaces/Diagnostic.md)[]]

#### Parameters

| Name | Type |
| :------ | :------ |
| `code` | `string` \| [`SourceFile`](interfaces/SourceFile.md) |

#### Returns

[[`TypeReferenceNode`](interfaces/TypeReferenceNode.md), readonly [`Diagnostic`](interfaces/Diagnostic.md)[]]

___

### projectProgram

▸ **projectProgram**(`program`, `projections`, `startNode?`): [`ProjectedProgram`](interfaces/ProjectedProgram.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `projections` | [`ProjectionApplication`](interfaces/ProjectionApplication.md)[] |
| `startNode?` | [`Type`](index.md#type) |

#### Returns

[`ProjectedProgram`](interfaces/ProjectedProgram.md)

___

### reducePathComponents

▸ **reducePathComponents**(`components`): `string`[]

Reduce an array of path components to a more simplified path by navigating any
`"."` or `".."` entries in the path.

#### Parameters

| Name | Type |
| :------ | :------ |
| `components` | readonly `string`[] |

#### Returns

`string`[]

___

### removeTrailingDirectorySeparator

▸ **removeTrailingDirectorySeparator**(`path`): `string`

Removes a trailing directory separator from a path, if it does not already have one.

```ts
removeTrailingDirectorySeparator("/path/to/file.ext") === "/path/to/file.ext"
removeTrailingDirectorySeparator("/path/to/file.ext/") === "/path/to/file.ext"
```

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |

#### Returns

`string`

___

### reportDeprecated

▸ **reportDeprecated**(`program`, `message`, `target`): `void`

Report a deprecated diagnostic.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | TypeSpec Program. |
| `message` | `string` | Message describing the deprecation. |
| `target` | [`DiagnosticTarget`](index.md#diagnostictarget) \| typeof [`NoTarget`](index.md#notarget) | Target of the deprecation. |

#### Returns

`void`

___

### resolveModule

▸ **resolveModule**(`host`, `name`, `options`): `Promise`<[`ModuleResolutionResult`](index.md#moduleresolutionresult)\>

Resolve a module

#### Parameters

| Name | Type |
| :------ | :------ |
| `host` | [`ResolveModuleHost`](interfaces/ResolveModuleHost.md) |
| `name` | `string` |
| `options` | [`ResolveModuleOptions`](interfaces/ResolveModuleOptions.md) |

#### Returns

`Promise`<[`ModuleResolutionResult`](index.md#moduleresolutionresult)\>

___

### resolvePath

▸ **resolvePath**(`path`, `...paths`): `string`

Combines and resolves paths. If a path is absolute, it replaces any previous path. Any
`.` and `..` path components are resolved. Trailing directory separators are preserved.

```ts
resolvePath("/path", "to", "file.ext") === "path/to/file.ext"
resolvePath("/path", "to", "file.ext/") === "path/to/file.ext/"
resolvePath("/path", "dir", "..", "to", "file.ext") === "path/to/file.ext"
```

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |
| `...paths` | (`undefined` \| `string`)[] |

#### Returns

`string`

___

### resolveUsages

▸ **resolveUsages**(`types`): [`UsageTracker`](interfaces/UsageTracker.md)

Resolve usage(input, output or both) of various types in the given namespace.
Will recursively scan all namespace, interfaces and operations contained inside the namespace.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `types` | [`OperationContainer`](index.md#operationcontainer) \| [`OperationContainer`](index.md#operationcontainer)[] | Entrypoint(s) namespace, interface or operations to get usage from. |

#### Returns

[`UsageTracker`](interfaces/UsageTracker.md)

Map of types to usage.

___

### scopeNavigationToNamespace

▸ **scopeNavigationToNamespace**<`T`\>(`namespace`, `listeners`, `options?`): `T`

Scope the current navigation to the given namespace.

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends { `exitModel`: `undefined` \| `TypeListener`<[`Model`](interfaces/Model.md)\> ; `model`: `undefined` \| `TypeListener`<[`Model`](interfaces/Model.md)\>  } & { `exitModelProperty`: `undefined` \| `TypeListener`<[`ModelProperty`](interfaces/ModelProperty.md)\> ; `modelProperty`: `undefined` \| `TypeListener`<[`ModelProperty`](interfaces/ModelProperty.md)\>  } & { `exitScalar`: `undefined` \| `TypeListener`<[`Scalar`](interfaces/Scalar.md)\> ; `scalar`: `undefined` \| `TypeListener`<[`Scalar`](interfaces/Scalar.md)\>  } & { `exitInterface`: `undefined` \| `TypeListener`<[`Interface`](interfaces/Interface.md)\> ; `interface`: `undefined` \| `TypeListener`<[`Interface`](interfaces/Interface.md)\>  } & { `enum`: `undefined` \| `TypeListener`<[`Enum`](interfaces/Enum.md)\> ; `exitEnum`: `undefined` \| `TypeListener`<[`Enum`](interfaces/Enum.md)\>  } & { `enumMember`: `undefined` \| `TypeListener`<[`EnumMember`](interfaces/EnumMember.md)\> ; `exitEnumMember`: `undefined` \| `TypeListener`<[`EnumMember`](interfaces/EnumMember.md)\>  } & { `exitTemplateParameter`: `undefined` \| `TypeListener`<[`TemplateParameter`](interfaces/TemplateParameter.md)\> ; `templateParameter`: `undefined` \| `TypeListener`<[`TemplateParameter`](interfaces/TemplateParameter.md)\>  } & { `exitNamespace`: `undefined` \| `TypeListener`<[`Namespace`](interfaces/Namespace.md)\> ; `namespace`: `undefined` \| `TypeListener`<[`Namespace`](interfaces/Namespace.md)\>  } & { `exitOperation`: `undefined` \| `TypeListener`<[`Operation`](interfaces/Operation.md)\> ; `operation`: `undefined` \| `TypeListener`<[`Operation`](interfaces/Operation.md)\>  } & { `exitString`: `undefined` \| `TypeListener`<[`StringLiteral`](interfaces/StringLiteral.md)\> ; `string`: `undefined` \| `TypeListener`<[`StringLiteral`](interfaces/StringLiteral.md)\>  } & { `exitNumber`: `undefined` \| `TypeListener`<[`NumericLiteral`](interfaces/NumericLiteral.md)\> ; `number`: `undefined` \| `TypeListener`<[`NumericLiteral`](interfaces/NumericLiteral.md)\>  } & { `boolean`: `undefined` \| `TypeListener`<[`BooleanLiteral`](interfaces/BooleanLiteral.md)\> ; `exitBoolean`: `undefined` \| `TypeListener`<[`BooleanLiteral`](interfaces/BooleanLiteral.md)\>  } & { `exitTuple`: `undefined` \| `TypeListener`<[`Tuple`](interfaces/Tuple.md)\> ; `tuple`: `undefined` \| `TypeListener`<[`Tuple`](interfaces/Tuple.md)\>  } & { `exitUnion`: `undefined` \| `TypeListener`<[`Union`](interfaces/Union.md)\> ; `union`: `undefined` \| `TypeListener`<[`Union`](interfaces/Union.md)\>  } & { `exitUnionVariant`: `undefined` \| `TypeListener`<[`UnionVariant`](interfaces/UnionVariant.md)\> ; `unionVariant`: `undefined` \| `TypeListener`<[`UnionVariant`](interfaces/UnionVariant.md)\>  } & { `exitIntrinsic`: `undefined` \| `TypeListener`<[`IntrinsicType`](interfaces/IntrinsicType.md)\> ; `intrinsic`: `undefined` \| `TypeListener`<[`IntrinsicType`](interfaces/IntrinsicType.md)\>  } & { `exitFunction`: `undefined` \| `TypeListener`<[`FunctionType`](interfaces/FunctionType.md)\> ; `function`: `undefined` \| `TypeListener`<[`FunctionType`](interfaces/FunctionType.md)\>  } & { `decorator`: `undefined` \| `TypeListener`<[`Decorator`](interfaces/Decorator.md)\> ; `exitDecorator`: `undefined` \| `TypeListener`<[`Decorator`](interfaces/Decorator.md)\>  } & { `exitFunctionParameter`: `undefined` \| `TypeListener`<[`FunctionParameter`](interfaces/FunctionParameter.md)\> ; `functionParameter`: `undefined` \| `TypeListener`<[`FunctionParameter`](interfaces/FunctionParameter.md)\>  } & { `exitObject`: `undefined` \| `TypeListener`<[`ObjectType`](interfaces/ObjectType.md)\> ; `object`: `undefined` \| `TypeListener`<[`ObjectType`](interfaces/ObjectType.md)\>  } & { `exitProjection`: `undefined` \| `TypeListener`<[`Projection`](interfaces/Projection.md)\> ; `projection`: `undefined` \| `TypeListener`<[`Projection`](interfaces/Projection.md)\>  } |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `namespace` | [`Namespace`](interfaces/Namespace.md) | Namespace the traversal shouldn't leave. |
| `listeners` | `T` | Type listeners. |
| `options` | [`NamespaceNavigationOptions`](interfaces/NamespaceNavigationOptions.md) | Scope options |

#### Returns

`T`

wrapped listeners that that can be used with `navigateType`

___

### setCadlNamespace

▸ **setCadlNamespace**(`namespace`, `...functions`): `void`

**`Deprecated`**

use setTypeSpecNamespace

#### Parameters

| Name | Type |
| :------ | :------ |
| `namespace` | `string` |
| `...functions` | (...`args`: `any`[]) => `any`[] |

#### Returns

`void`

___

### setTypeSpecNamespace

▸ **setTypeSpecNamespace**(`namespace`, `...functions`): `void`

Set the TypeSpec namespace for that function.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `namespace` | `string` | Namespace string (e.g. "Foo.Bar") |
| `...functions` | (...`args`: `any`[]) => `any`[] | Functions |

#### Returns

`void`

___

### skipTrivia

▸ **skipTrivia**(`input`, `position`, `endPosition?`): `number`

#### Parameters

| Name | Type | Default value |
| :------ | :------ | :------ |
| `input` | `string` | `undefined` |
| `position` | `number` | `undefined` |
| `endPosition` | `number` | `input.length` |

#### Returns

`number`

___

### skipWhiteSpace

▸ **skipWhiteSpace**(`input`, `position`, `endPosition?`): `number`

#### Parameters

| Name | Type | Default value |
| :------ | :------ | :------ |
| `input` | `string` | `undefined` |
| `position` | `number` | `undefined` |
| `endPosition` | `number` | `input.length` |

#### Returns

`number`

___

### typespecTypeToJson

▸ **typespecTypeToJson**<`T`\>(`typespecType`, `target`): [`T` \| `undefined`, [`Diagnostic`](interfaces/Diagnostic.md)[]]

Convert a typespec type to a serializable Json object.
Emits diagnostics if the given type is invalid

#### Type parameters

| Name |
| :------ |
| `T` |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `typespecType` | [`TypeSpecValue`](index.md#typespecvalue) | The type to convert to Json data |
| `target` | [`DiagnosticTarget`](index.md#diagnostictarget) | The diagnostic target in case of errors. |

#### Returns

[`T` \| `undefined`, [`Diagnostic`](interfaces/Diagnostic.md)[]]

___

### validateDecoratorNotOnType

▸ **validateDecoratorNotOnType**(`context`, `type`, `badDecorator`, `givenDecorator`): `boolean`

Validate that a given decorator is not on a type or any of its base types.
Useful to check for decorator usage that conflicts with another decorator.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) | Decorator context |
| `type` | [`Type`](index.md#type) | The type to check |
| `badDecorator` | [`DecoratorFunction`](interfaces/DecoratorFunction.md) | The decorator we don't want present |
| `givenDecorator` | [`DecoratorFunction`](interfaces/DecoratorFunction.md) | The decorator that is the reason why we don't want the bad decorator present |

#### Returns

`boolean`

Whether the decorator application is valid

___

### validateDecoratorParamCount

▸ **validateDecoratorParamCount**(`context`, `min`, `max`, `parameters`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `min` | `number` |
| `max` | `undefined` \| `number` |
| `parameters` | `unknown`[] |

#### Returns

`boolean`

___

### validateDecoratorParamType

▸ **validateDecoratorParamType**<`K`\>(`program`, `target`, `value`, `expectedType`): value is InferredTypeSpecValue<K\>

Validate a decorator parameter has the correct type.

**`Deprecated`**

use

**`See`**

createDecoratorDefinition#validate instead.

#### Type parameters

| Name | Type |
| :------ | :------ |
| `K` | extends ``"Projection"`` \| ``"Model"`` \| ``"ModelProperty"`` \| ``"Scalar"`` \| ``"Interface"`` \| ``"Enum"`` \| ``"EnumMember"`` \| ``"TemplateParameter"`` \| ``"Namespace"`` \| ``"Operation"`` \| ``"String"`` \| ``"Number"`` \| ``"Boolean"`` \| ``"Tuple"`` \| ``"Union"`` \| ``"UnionVariant"`` \| ``"Intrinsic"`` \| ``"Function"`` \| ``"Decorator"`` \| ``"FunctionParameter"`` \| ``"Object"`` |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | Program |
| `target` | [`Type`](index.md#type) | Decorator target |
| `value` | [`TypeSpecValue`](index.md#typespecvalue) | Value of the parameter. |
| `expectedType` | `K` \| `K`[] | Expected type or list of expected type |

#### Returns

value is InferredTypeSpecValue<K\>

true if the value is of one of the type in the list of expected types. If not emit a diagnostic.

___

### validateDecoratorTarget

▸ **validateDecoratorTarget**<`K`\>(`context`, `target`, `decoratorName`, `expectedType`): target is K extends "Any" ? Type : Object

Validate the decorator target is matching the expected value.

#### Type parameters

| Name | Type |
| :------ | :------ |
| `K` | extends [`TypeKind`](index.md#typekind) |

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`Type`](index.md#type) |
| `decoratorName` | `string` |
| `expectedType` | `K` \| readonly `K`[] |

#### Returns

target is K extends "Any" ? Type : Object

___

### validateDecoratorTargetIntrinsic

▸ **validateDecoratorTargetIntrinsic**(`context`, `target`, `decoratorName`, `expectedType`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`ModelProperty`](interfaces/ModelProperty.md) \| [`Scalar`](interfaces/Scalar.md) |
| `decoratorName` | `string` |
| `expectedType` | [`IntrinsicScalarName`](index.md#intrinsicscalarname) \| [`IntrinsicScalarName`](index.md#intrinsicscalarname)[] |

#### Returns

`boolean`

___

### validateDecoratorUniqueOnNode

▸ **validateDecoratorUniqueOnNode**(`context`, `type`, `decorator`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `type` | [`Type`](index.md#type) |
| `decorator` | [`DecoratorFunction`](interfaces/DecoratorFunction.md) |

#### Returns

`boolean`

___

### visitChildren

▸ **visitChildren**<`T`\>(`node`, `cb`): `T` \| `undefined`

#### Type parameters

| Name |
| :------ |
| `T` |

#### Parameters

| Name | Type |
| :------ | :------ |
| `node` | [`Node`](index.md#node) |
| `cb` | [`NodeCallback`](index.md#nodecallback)<`T`\> |

#### Returns

`T` \| `undefined`

___

### walkPropertiesInherited

▸ **walkPropertiesInherited**(`model`): `Generator`<[`ModelProperty`](interfaces/ModelProperty.md), `void`, `unknown`\>

Enumerates the properties declared by model or inherited from its base.

Properties declared by more derived types are enumerated before properties
of less derived types.

Properties that are overridden are not enumerated.

#### Parameters

| Name | Type |
| :------ | :------ |
| `model` | [`Model`](interfaces/Model.md) |

#### Returns

`Generator`<[`ModelProperty`](interfaces/ModelProperty.md), `void`, `unknown`\>
