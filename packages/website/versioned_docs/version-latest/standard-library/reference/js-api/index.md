JS Api

# JS Api

## Table of contents

### References

- [$deprecated](index.md#$deprecated)
- [$discriminator](index.md#$discriminator)
- [$doc](index.md#$doc)
- [$docFromComment](index.md#$docfromcomment)
- [$encode](index.md#$encode)
- [$error](index.md#$error)
- [$format](index.md#$format)
- [$friendlyName](index.md#$friendlyname)
- [$indexer](index.md#$indexer)
- [$inspectType](index.md#$inspecttype)
- [$inspectTypeName](index.md#$inspecttypename)
- [$key](index.md#$key)
- [$knownValues](index.md#$knownvalues)
- [$list](index.md#$list)
- [$maxItems](index.md#$maxitems)
- [$maxLength](index.md#$maxlength)
- [$maxValue](index.md#$maxvalue)
- [$maxValueExclusive](index.md#$maxvalueexclusive)
- [$minItems](index.md#$minitems)
- [$minLength](index.md#$minlength)
- [$minValue](index.md#$minvalue)
- [$minValueExclusive](index.md#$minvalueexclusive)
- [$overload](index.md#$overload)
- [$pattern](index.md#$pattern)
- [$projectedName](index.md#$projectedname)
- [$secret](index.md#$secret)
- [$service](index.md#$service)
- [$summary](index.md#$summary)
- [$tag](index.md#$tag)
- [$visibility](index.md#$visibility)
- [$withDefaultKeyVisibility](index.md#$withdefaultkeyvisibility)
- [$withOptionalProperties](index.md#$withoptionalproperties)
- [$withUpdateableProperties](index.md#$withupdateableproperties)
- [$withVisibility](index.md#$withvisibility)
- [$withoutDefaultValues](index.md#$withoutdefaultvalues)
- [$withoutOmittedProperties](index.md#$withoutomittedproperties)
- [BytesKnownEncoding](index.md#bytesknownencoding)
- [DateTimeKnownEncoding](index.md#datetimeknownencoding)
- [Discriminator](index.md#discriminator)
- [DocData](index.md#docdata)
- [DurationKnownEncoding](index.md#durationknownencoding)
- [EncodeData](index.md#encodedata)
- [Service](index.md#service)
- [ServiceDetails](index.md#servicedetails)
- [addService](index.md#addservice)
- [getAllTags](index.md#getalltags)
- [getDeprecated](index.md#getdeprecated)
- [getDiscriminatedTypes](index.md#getdiscriminatedtypes)
- [getDiscriminator](index.md#getdiscriminator)
- [getDoc](index.md#getdoc)
- [getDocData](index.md#getdocdata)
- [getEncode](index.md#getencode)
- [getFormat](index.md#getformat)
- [getFriendlyName](index.md#getfriendlyname)
- [getIndexer](index.md#getindexer)
- [getKeyName](index.md#getkeyname)
- [getKnownValues](index.md#getknownvalues)
- [getListOperationType](index.md#getlistoperationtype)
- [getMaxItems](index.md#getmaxitems)
- [getMaxLength](index.md#getmaxlength)
- [getMaxValue](index.md#getmaxvalue)
- [getMaxValueExclusive](index.md#getmaxvalueexclusive)
- [getMinItems](index.md#getminitems)
- [getMinLength](index.md#getminlength)
- [getMinValue](index.md#getminvalue)
- [getMinValueExclusive](index.md#getminvalueexclusive)
- [getOverloadedOperation](index.md#getoverloadedoperation)
- [getOverloads](index.md#getoverloads)
- [getPattern](index.md#getpattern)
- [getProjectedName](index.md#getprojectedname)
- [getProjectedNames](index.md#getprojectednames)
- [getPropertyType](index.md#getpropertytype)
- [getService](index.md#getservice)
- [getSummary](index.md#getsummary)
- [getTags](index.md#gettags)
- [getVisibility](index.md#getvisibility)
- [hasProjectedName](index.md#hasprojectedname)
- [isArrayModelType](index.md#isarraymodeltype)
- [isDeprecated](index.md#isdeprecated)
- [isErrorModel](index.md#iserrormodel)
- [isKey](index.md#iskey)
- [isListOperation](index.md#islistoperation)
- [isNumericType](index.md#isnumerictype)
- [isRecordModelType](index.md#isrecordmodeltype)
- [isSecret](index.md#issecret)
- [isService](index.md#isservice)
- [isStringType](index.md#isstringtype)
- [isVisible](index.md#isvisible)
- [listServices](index.md#listservices)
- [namespace](index.md#namespace)

### Namespaces

- [decorators](modules/decorators.md)

### Enumerations

- [IdentifierKind](enums/IdentifierKind.md)
- [KeywordLimit](enums/KeywordLimit.md)
- [ListenerFlow](enums/ListenerFlow.md)
- [ModifierFlags](enums/ModifierFlags.md)
- [NodeFlags](enums/NodeFlags.md)
- [SemanticTokenKind](enums/SemanticTokenKind.md)
- [SymbolFlags](enums/SymbolFlags.md)
- [SyntaxKind](enums/SyntaxKind.md)
- [Token](enums/Token.md)
- [TokenFlags](enums/TokenFlags.md)
- [UsageFlags](enums/UsageFlags.md)

### Classes

- [DuplicateTracker](classes/DuplicateTracker.md)
- [EventEmitter](classes/EventEmitter.md)
- [InvalidEncodingError](classes/InvalidEncodingError.md)
- [ProjectionError](classes/ProjectionError.md)
- [Queue](classes/Queue.md)
- [ResolveModuleError](classes/ResolveModuleError.md)
- [TwoLevelMap](classes/TwoLevelMap.md)

### Interfaces

- [AliasStatementNode](interfaces/AliasStatementNode.md)
- [AnyKeywordNode](interfaces/AnyKeywordNode.md)
- [ArrayExpressionNode](interfaces/ArrayExpressionNode.md)
- [ArrayModelType](interfaces/ArrayModelType.md)
- [AugmentDecoratorStatementNode](interfaces/AugmentDecoratorStatementNode.md)
- [BaseNode](interfaces/BaseNode.md)
- [BaseType](interfaces/BaseType.md)
- [BlockComment](interfaces/BlockComment.md)
- [BooleanLiteral](interfaces/BooleanLiteral.md)
- [BooleanLiteralNode](interfaces/BooleanLiteralNode.md)
- [CallableMessage](interfaces/CallableMessage.md)
- [Checker](interfaces/Checker.md)
- [CompilerHost](interfaces/CompilerHost.md)
- [CompilerLocationContext](interfaces/CompilerLocationContext.md)
- [DeclarationNode](interfaces/DeclarationNode.md)
- [DecoratedType](interfaces/DecoratedType.md)
- [Decorator](interfaces/Decorator.md)
- [DecoratorApplication](interfaces/DecoratorApplication.md)
- [DecoratorArgument](interfaces/DecoratorArgument.md)
- [DecoratorContext](interfaces/DecoratorContext.md)
- [DecoratorDeclarationStatementNode](interfaces/DecoratorDeclarationStatementNode.md)
- [DecoratorDefinition](interfaces/DecoratorDefinition.md)
- [DecoratorExpressionNode](interfaces/DecoratorExpressionNode.md)
- [DecoratorFunction](interfaces/DecoratorFunction.md)
- [DecoratorParamDefinition](interfaces/DecoratorParamDefinition.md)
- [DecoratorValidator](interfaces/DecoratorValidator.md)
- [Diagnostic](interfaces/Diagnostic.md)
- [DiagnosticCollector](interfaces/DiagnosticCollector.md)
- [DiagnosticCreator](interfaces/DiagnosticCreator.md)
- [DiagnosticDefinition](interfaces/DiagnosticDefinition.md)
- [DiagnosticMessages](interfaces/DiagnosticMessages.md)
- [DirectiveBase](interfaces/DirectiveBase.md)
- [DirectiveExpressionNode](interfaces/DirectiveExpressionNode.md)
- [Dirent](interfaces/Dirent.md)
- [DiscriminatedUnion](interfaces/DiscriminatedUnion.md)
- [DocNode](interfaces/DocNode.md)
- [DocParamTagNode](interfaces/DocParamTagNode.md)
- [DocReturnsTagNode](interfaces/DocReturnsTagNode.md)
- [DocTagBaseNode](interfaces/DocTagBaseNode.md)
- [DocTemplateTagNode](interfaces/DocTemplateTagNode.md)
- [DocTextNode](interfaces/DocTextNode.md)
- [DocUnknownTagNode](interfaces/DocUnknownTagNode.md)
- [EmitContext](interfaces/EmitContext.md)
- [EmitFileOptions](interfaces/EmitFileOptions.md)
- [EmptyStatementNode](interfaces/EmptyStatementNode.md)
- [Enum](interfaces/Enum.md)
- [EnumMember](interfaces/EnumMember.md)
- [EnumMemberNode](interfaces/EnumMemberNode.md)
- [EnumSpreadMemberNode](interfaces/EnumSpreadMemberNode.md)
- [EnumStatementNode](interfaces/EnumStatementNode.md)
- [ErrorType](interfaces/ErrorType.md)
- [ExternKeywordNode](interfaces/ExternKeywordNode.md)
- [FileLibraryMetadata](interfaces/FileLibraryMetadata.md)
- [FunctionDeclarationStatementNode](interfaces/FunctionDeclarationStatementNode.md)
- [FunctionParameter](interfaces/FunctionParameter.md)
- [FunctionParameterNode](interfaces/FunctionParameterNode.md)
- [FunctionType](interfaces/FunctionType.md)
- [IdentifierContext](interfaces/IdentifierContext.md)
- [IdentifierNode](interfaces/IdentifierNode.md)
- [ImportStatementNode](interfaces/ImportStatementNode.md)
- [Interface](interfaces/Interface.md)
- [InterfaceStatementNode](interfaces/InterfaceStatementNode.md)
- [IntersectionExpressionNode](interfaces/IntersectionExpressionNode.md)
- [IntrinsicType](interfaces/IntrinsicType.md)
- [InvalidStatementNode](interfaces/InvalidStatementNode.md)
- [JSONSchemaValidator](interfaces/JSONSchemaValidator.md)
- [JsSourceFileNode](interfaces/JsSourceFileNode.md)
- [LibraryInstance](interfaces/LibraryInstance.md)
- [LibraryLocationContext](interfaces/LibraryLocationContext.md)
- [LineAndCharacter](interfaces/LineAndCharacter.md)
- [LineComment](interfaces/LineComment.md)
- [LinterDefinition](interfaces/LinterDefinition.md)
- [LinterRule](interfaces/LinterRule.md)
- [LinterRuleContext](interfaces/LinterRuleContext.md)
- [LinterRuleDefinition](interfaces/LinterRuleDefinition.md)
- [LinterRuleSet](interfaces/LinterRuleSet.md)
- [ListOperationOptions](interfaces/ListOperationOptions.md)
- [LogInfo](interfaces/LogInfo.md)
- [LogSink](interfaces/LogSink.md)
- [Logger](interfaces/Logger.md)
- [MemberExpressionNode](interfaces/MemberExpressionNode.md)
- [Model](interfaces/Model.md)
- [ModelExpressionNode](interfaces/ModelExpressionNode.md)
- [ModelProperty](interfaces/ModelProperty.md)
- [ModelPropertyNode](interfaces/ModelPropertyNode.md)
- [ModelSpreadPropertyNode](interfaces/ModelSpreadPropertyNode.md)
- [ModelStatementNode](interfaces/ModelStatementNode.md)
- [ModuleLibraryMetadata](interfaces/ModuleLibraryMetadata.md)
- [Namespace](interfaces/Namespace.md)
- [NamespaceNavigationOptions](interfaces/NamespaceNavigationOptions.md)
- [NamespaceStatementNode](interfaces/NamespaceStatementNode.md)
- [NavigationOptions](interfaces/NavigationOptions.md)
- [NeverKeywordNode](interfaces/NeverKeywordNode.md)
- [NeverType](interfaces/NeverType.md)
- [NodePackage](interfaces/NodePackage.md)
- [NullType](interfaces/NullType.md)
- [NumericLiteral](interfaces/NumericLiteral.md)
- [NumericLiteralNode](interfaces/NumericLiteralNode.md)
- [ObjectType](interfaces/ObjectType.md)
- [Operation](interfaces/Operation.md)
- [OperationSignatureDeclarationNode](interfaces/OperationSignatureDeclarationNode.md)
- [OperationSignatureReferenceNode](interfaces/OperationSignatureReferenceNode.md)
- [OperationStatementNode](interfaces/OperationStatementNode.md)
- [ParseOptions](interfaces/ParseOptions.md)
- [ProcessedLog](interfaces/ProcessedLog.md)
- [Program](interfaces/Program.md)
- [ProjectLocationContext](interfaces/ProjectLocationContext.md)
- [ProjectedNameView](interfaces/ProjectedNameView.md)
- [ProjectedProgram](interfaces/ProjectedProgram.md)
- [Projection](interfaces/Projection.md)
- [ProjectionApplication](interfaces/ProjectionApplication.md)
- [ProjectionArithmeticExpressionNode](interfaces/ProjectionArithmeticExpressionNode.md)
- [ProjectionBlockExpressionNode](interfaces/ProjectionBlockExpressionNode.md)
- [ProjectionCallExpressionNode](interfaces/ProjectionCallExpressionNode.md)
- [ProjectionDecoratorReferenceExpressionNode](interfaces/ProjectionDecoratorReferenceExpressionNode.md)
- [ProjectionEnumMemberSelectorNode](interfaces/ProjectionEnumMemberSelectorNode.md)
- [ProjectionEnumSelectorNode](interfaces/ProjectionEnumSelectorNode.md)
- [ProjectionEqualityExpressionNode](interfaces/ProjectionEqualityExpressionNode.md)
- [ProjectionExpressionStatementNode](interfaces/ProjectionExpressionStatementNode.md)
- [ProjectionIfExpressionNode](interfaces/ProjectionIfExpressionNode.md)
- [ProjectionInterfaceSelectorNode](interfaces/ProjectionInterfaceSelectorNode.md)
- [ProjectionLambdaExpressionNode](interfaces/ProjectionLambdaExpressionNode.md)
- [ProjectionLambdaParameterDeclarationNode](interfaces/ProjectionLambdaParameterDeclarationNode.md)
- [ProjectionLogicalExpressionNode](interfaces/ProjectionLogicalExpressionNode.md)
- [ProjectionMemberExpressionNode](interfaces/ProjectionMemberExpressionNode.md)
- [ProjectionModelExpressionNode](interfaces/ProjectionModelExpressionNode.md)
- [ProjectionModelPropertyNode](interfaces/ProjectionModelPropertyNode.md)
- [ProjectionModelPropertySelectorNode](interfaces/ProjectionModelPropertySelectorNode.md)
- [ProjectionModelSelectorNode](interfaces/ProjectionModelSelectorNode.md)
- [ProjectionModelSpreadPropertyNode](interfaces/ProjectionModelSpreadPropertyNode.md)
- [ProjectionNode](interfaces/ProjectionNode.md)
- [ProjectionOperationSelectorNode](interfaces/ProjectionOperationSelectorNode.md)
- [ProjectionParameterDeclarationNode](interfaces/ProjectionParameterDeclarationNode.md)
- [ProjectionReferenceNode](interfaces/ProjectionReferenceNode.md)
- [ProjectionRelationalExpressionNode](interfaces/ProjectionRelationalExpressionNode.md)
- [ProjectionStatementNode](interfaces/ProjectionStatementNode.md)
- [ProjectionTupleExpressionNode](interfaces/ProjectionTupleExpressionNode.md)
- [ProjectionUnaryExpressionNode](interfaces/ProjectionUnaryExpressionNode.md)
- [ProjectionUnionSelectorNode](interfaces/ProjectionUnionSelectorNode.md)
- [ProjectionUnionVariantSelectorNode](interfaces/ProjectionUnionVariantSelectorNode.md)
- [Projector](interfaces/Projector.md)
- [RecordModelType](interfaces/RecordModelType.md)
- [RekeyableMap](interfaces/RekeyableMap.md)
- [ResolveModuleHost](interfaces/ResolveModuleHost.md)
- [ResolveModuleOptions](interfaces/ResolveModuleOptions.md)
- [ResolvedFile](interfaces/ResolvedFile.md)
- [ResolvedModule](interfaces/ResolvedModule.md)
- [ReturnExpressionNode](interfaces/ReturnExpressionNode.md)
- [ReturnRecord](interfaces/ReturnRecord.md)
- [RmOptions](interfaces/RmOptions.md)
- [Scalar](interfaces/Scalar.md)
- [ScalarStatementNode](interfaces/ScalarStatementNode.md)
- [Scanner](interfaces/Scanner.md)
- [SemanticToken](interfaces/SemanticToken.md)
- [Server](interfaces/Server.md)
- [ServerHost](interfaces/ServerHost.md)
- [ServerSourceFile](interfaces/ServerSourceFile.md)
- [ServerWorkspaceFolder](interfaces/ServerWorkspaceFolder.md)
- [SourceFile](interfaces/SourceFile.md)
- [SourceLocation](interfaces/SourceLocation.md)
- [StringLiteral](interfaces/StringLiteral.md)
- [StringLiteralNode](interfaces/StringLiteralNode.md)
- [SuppressDirective](interfaces/SuppressDirective.md)
- [Sym](interfaces/Sym.md)
- [SymbolLinks](interfaces/SymbolLinks.md)
- [SymbolTable](interfaces/SymbolTable.md)
- [SyntheticLocationContext](interfaces/SyntheticLocationContext.md)
- [TemplateDeclarationNode](interfaces/TemplateDeclarationNode.md)
- [TemplateParameter](interfaces/TemplateParameter.md)
- [TemplateParameterDeclarationNode](interfaces/TemplateParameterDeclarationNode.md)
- [TemplatedTypeBase](interfaces/TemplatedTypeBase.md)
- [TextRange](interfaces/TextRange.md)
- [Tracer](interfaces/Tracer.md)
- [TracerOptions](interfaces/TracerOptions.md)
- [Tuple](interfaces/Tuple.md)
- [TupleExpressionNode](interfaces/TupleExpressionNode.md)
- [TypeInstantiationMap](interfaces/TypeInstantiationMap.md)
- [TypeMapper](interfaces/TypeMapper.md)
- [TypeNameOptions](interfaces/TypeNameOptions.md)
- [TypeReferenceNode](interfaces/TypeReferenceNode.md)
- [TypeSpecCompletionItem](interfaces/TypeSpecCompletionItem.md)
- [TypeSpecLibrary](interfaces/TypeSpecLibrary.md)
- [TypeSpecLibraryDef](interfaces/TypeSpecLibraryDef.md)
- [TypeSpecManifest](interfaces/TypeSpecManifest.md)
- [TypeSpecScriptNode](interfaces/TypeSpecScriptNode.md)
- [Union](interfaces/Union.md)
- [UnionExpressionNode](interfaces/UnionExpressionNode.md)
- [UnionStatementNode](interfaces/UnionStatementNode.md)
- [UnionVariant](interfaces/UnionVariant.md)
- [UnionVariantNode](interfaces/UnionVariantNode.md)
- [UnknownType](interfaces/UnknownType.md)
- [UsageTracker](interfaces/UsageTracker.md)
- [UsingStatementNode](interfaces/UsingStatementNode.md)
- [ValueOfExpressionNode](interfaces/ValueOfExpressionNode.md)
- [ValueType](interfaces/ValueType.md)
- [VoidKeywordNode](interfaces/VoidKeywordNode.md)
- [VoidType](interfaces/VoidType.md)

### Type Aliases

- [CadlCompletionItem](index.md#cadlcompletionitem)
- [CadlLibrary](index.md#cadllibrary)
- [CadlLibraryDef](index.md#cadllibrarydef)
- [CadlManifest](index.md#cadlmanifest)
- [CadlScriptNode](index.md#cadlscriptnode)
- [CadlValue](index.md#cadlvalue)
- [Comment](index.md#comment)
- [CreateTypeProps](index.md#createtypeprops)
- [Declaration](index.md#declaration)
- [DecoratorArgumentValue](index.md#decoratorargumentvalue)
- [DiagnosticFormat](index.md#diagnosticformat)
- [DiagnosticHandler](index.md#diagnostichandler)
- [DiagnosticMap](index.md#diagnosticmap)
- [DiagnosticReport](index.md#diagnosticreport)
- [DiagnosticReportWithoutTarget](index.md#diagnosticreportwithouttarget)
- [DiagnosticResult](index.md#diagnosticresult)
- [DiagnosticSeverity](index.md#diagnosticseverity)
- [DiagnosticTarget](index.md#diagnostictarget)
- [Directive](index.md#directive)
- [DirectiveArgument](index.md#directiveargument)
- [DocContent](index.md#doccontent)
- [DocTag](index.md#doctag)
- [DocToken](index.md#doctoken)
- [EmitOptionsFor](index.md#emitoptionsfor)
- [EmitterFunc](index.md#emitterfunc)
- [Expression](index.md#expression)
- [InferredCadlValue](index.md#inferredcadlvalue)
- [InferredTypeSpecValue](index.md#inferredtypespecvalue)
- [IntrinsicScalarName](index.md#intrinsicscalarname)
- [JSONSchemaType](index.md#jsonschematype)
- [LibraryMetadata](index.md#librarymetadata)
- [LinterRuleDiagnosticFormat](index.md#linterrulediagnosticformat)
- [LinterRuleDiagnosticReport](index.md#linterrulediagnosticreport)
- [LinterRuleDiagnosticReportWithoutTarget](index.md#linterrulediagnosticreportwithouttarget)
- [LiteralNode](index.md#literalnode)
- [LiteralType](index.md#literaltype)
- [LocationContext](index.md#locationcontext)
- [LogLevel](index.md#loglevel)
- [MarshalledValue](index.md#marshalledvalue)
- [MemberContainerNode](index.md#membercontainernode)
- [MemberContainerType](index.md#membercontainertype)
- [MemberNode](index.md#membernode)
- [MemberType](index.md#membertype)
- [ModelIndexer](index.md#modelindexer)
- [Modifier](index.md#modifier)
- [ModuleResolutionResult](index.md#moduleresolutionresult)
- [NeverIndexer](index.md#neverindexer)
- [NewLine](index.md#newline)
- [Node](index.md#node)
- [NodeCallback](index.md#nodecallback)
- [OperationContainer](index.md#operationcontainer)
- [OperationSignature](index.md#operationsignature)
- [ProjectionExpression](index.md#projectionexpression)
- [ProjectionStatementItem](index.md#projectionstatementitem)
- [ReferenceExpression](index.md#referenceexpression)
- [RuleRef](index.md#ruleref)
- [ScopeNode](index.md#scopenode)
- [SemanticNodeListener](index.md#semanticnodelistener)
- [SourceFileKind](index.md#sourcefilekind)
- [Statement](index.md#statement)
- [StdTypeName](index.md#stdtypename)
- [StdTypes](index.md#stdtypes)
- [TemplateableNode](index.md#templateablenode)
- [TemplatedType](index.md#templatedtype)
- [TrackableType](index.md#trackabletype)
- [Type](index.md#type)
- [TypeKind](index.md#typekind)
- [TypeListeners](index.md#typelisteners)
- [TypeOfDiagnostics](index.md#typeofdiagnostics)
- [TypeOrReturnRecord](index.md#typeorreturnrecord)
- [TypeSpecValue](index.md#typespecvalue)
- [WriteLine](index.md#writeline)

### Variables

- [CadlPrettierPlugin](index.md#cadlprettierplugin)
- [Keywords](index.md#keywords)
- [MANIFEST](index.md#manifest)
- [NoTarget](index.md#notarget)
- [NodeHost](index.md#nodehost)
- [TokenDisplay](index.md#tokendisplay)
- [TypeSpecPrettierPlugin](index.md#typespecprettierplugin)
- [altDirectorySeparator](index.md#altdirectoryseparator)
- [cadlVersion](index.md#cadlversion)
- [directorySeparator](index.md#directoryseparator)
- [typespecVersion](index.md#typespecversion)

### Functions

- [assertType](index.md#asserttype)
- [cadlTypeToJson](index.md#cadltypetojson)
- [checkFormatCadl](index.md#checkformatcadl)
- [checkFormatTypeSpec](index.md#checkformattypespec)
- [compile](index.md#compile)
- [compilerAssert](index.md#compilerassert)
- [createCadlLibrary](index.md#createcadllibrary)
- [createChecker](index.md#createchecker)
- [createDecoratorDefinition](index.md#createdecoratordefinition)
- [createDiagnosticCollector](index.md#creatediagnosticcollector)
- [createDiagnosticCreator](index.md#creatediagnosticcreator)
- [createProjectedNameProgram](index.md#createprojectednameprogram)
- [createRekeyableMap](index.md#createrekeyablemap)
- [createRule](index.md#createrule)
- [createScanner](index.md#createscanner)
- [createServer](index.md#createserver)
- [createSourceFile](index.md#createsourcefile)
- [createStateAccessors](index.md#createstateaccessors)
- [createTypeSpecLibrary](index.md#createtypespeclibrary)
- [emitFile](index.md#emitfile)
- [ensurePathIsNonModuleName](index.md#ensurepathisnonmodulename)
- [ensureTrailingDirectorySeparator](index.md#ensuretrailingdirectoryseparator)
- [filterModelProperties](index.md#filtermodelproperties)
- [finishTypeForProgram](index.md#finishtypeforprogram)
- [formatDiagnostic](index.md#formatdiagnostic)
- [formatIdentifier](index.md#formatidentifier)
- [formatTypeSpec](index.md#formattypespec)
- [getAnyExtensionFromPath](index.md#getanyextensionfrompath)
- [getBaseFileName](index.md#getbasefilename)
- [getCompletionNodeAtPosition](index.md#getcompletionnodeatposition)
- [getDirectoryPath](index.md#getdirectorypath)
- [getDiscriminatedUnion](index.md#getdiscriminatedunion)
- [getEffectiveModelType](index.md#geteffectivemodeltype)
- [getFirstAncestor](index.md#getfirstancestor)
- [getFullyQualifiedSymbolName](index.md#getfullyqualifiedsymbolname)
- [getIdentifierContext](index.md#getidentifiercontext)
- [getLocationContext](index.md#getlocationcontext)
- [getNamespaceFullName](index.md#getnamespacefullname)
- [getNodeAtPosition](index.md#getnodeatposition)
- [getNormalizedAbsolutePath](index.md#getnormalizedabsolutepath)
- [getNormalizedAbsolutePathWithoutRoot](index.md#getnormalizedabsolutepathwithoutroot)
- [getNormalizedPathComponents](index.md#getnormalizedpathcomponents)
- [getOverriddenProperty](index.md#getoverriddenproperty)
- [getParentTemplateNode](index.md#getparenttemplatenode)
- [getPathComponents](index.md#getpathcomponents)
- [getPathFromPathComponents](index.md#getpathfrompathcomponents)
- [getProperty](index.md#getproperty)
- [getRelativePathFromDirectory](index.md#getrelativepathfromdirectory)
- [getRootLength](index.md#getrootlength)
- [getSourceFileKindFromExt](index.md#getsourcefilekindfromext)
- [getSourceLocation](index.md#getsourcelocation)
- [getTypeName](index.md#gettypename)
- [hasParseError](index.md#hasparseerror)
- [hasTrailingDirectorySeparator](index.md#hastrailingdirectoryseparator)
- [ignoreDiagnostics](index.md#ignorediagnostics)
- [interpolatePath](index.md#interpolatepath)
- [isAnyDirectorySeparator](index.md#isanydirectoryseparator)
- [isCadlValueTypeOf](index.md#iscadlvaluetypeof)
- [isComment](index.md#iscomment)
- [isDeclaredInNamespace](index.md#isdeclaredinnamespace)
- [isDeclaredType](index.md#isdeclaredtype)
- [isErrorType](index.md#iserrortype)
- [isGlobalNamespace](index.md#isglobalnamespace)
- [isImportStatement](index.md#isimportstatement)
- [isIntrinsicType](index.md#isintrinsictype)
- [isKeyword](index.md#iskeyword)
- [isModifier](index.md#ismodifier)
- [isNeverType](index.md#isnevertype)
- [isNullType](index.md#isnulltype)
- [isPathAbsolute](index.md#ispathabsolute)
- [isProjectedProgram](index.md#isprojectedprogram)
- [isPunctuation](index.md#ispunctuation)
- [isStatementKeyword](index.md#isstatementkeyword)
- [isStdNamespace](index.md#isstdnamespace)
- [isTemplateDeclaration](index.md#istemplatedeclaration)
- [isTemplateDeclarationOrInstance](index.md#istemplatedeclarationorinstance)
- [isTemplateInstance](index.md#istemplateinstance)
- [isTrivia](index.md#istrivia)
- [isTypeSpecValueTypeOf](index.md#istypespecvaluetypeof)
- [isUnknownType](index.md#isunknowntype)
- [isUrl](index.md#isurl)
- [isVoidType](index.md#isvoidtype)
- [joinPaths](index.md#joinpaths)
- [listOperationsIn](index.md#listoperationsin)
- [logDiagnostics](index.md#logdiagnostics)
- [logVerboseTestOutput](index.md#logverbosetestoutput)
- [mapEventEmitterToNodeListener](index.md#mapeventemittertonodelistener)
- [navigateProgram](index.md#navigateprogram)
- [navigateType](index.md#navigatetype)
- [navigateTypesInNamespace](index.md#navigatetypesinnamespace)
- [normalizePath](index.md#normalizepath)
- [normalizeSlashes](index.md#normalizeslashes)
- [paramMessage](index.md#parammessage)
- [parse](index.md#parse)
- [parseStandaloneTypeReference](index.md#parsestandalonetypereference)
- [projectProgram](index.md#projectprogram)
- [reducePathComponents](index.md#reducepathcomponents)
- [removeTrailingDirectorySeparator](index.md#removetrailingdirectoryseparator)
- [reportDeprecated](index.md#reportdeprecated)
- [resolveModule](index.md#resolvemodule)
- [resolvePath](index.md#resolvepath)
- [resolveUsages](index.md#resolveusages)
- [scopeNavigationToNamespace](index.md#scopenavigationtonamespace)
- [setCadlNamespace](index.md#setcadlnamespace)
- [setTypeSpecNamespace](index.md#settypespecnamespace)
- [skipTrivia](index.md#skiptrivia)
- [skipWhiteSpace](index.md#skipwhitespace)
- [typespecTypeToJson](index.md#typespectypetojson)
- [validateDecoratorNotOnType](index.md#validatedecoratornotontype)
- [validateDecoratorParamCount](index.md#validatedecoratorparamcount)
- [validateDecoratorParamType](index.md#validatedecoratorparamtype)
- [validateDecoratorTarget](index.md#validatedecoratortarget)
- [validateDecoratorTargetIntrinsic](index.md#validatedecoratortargetintrinsic)
- [validateDecoratorUniqueOnNode](index.md#validatedecoratoruniqueonnode)
- [visitChildren](index.md#visitchildren)
- [walkPropertiesInherited](index.md#walkpropertiesinherited)

## References

### $deprecated

Re-exports [$deprecated](modules/decorators.md#$deprecated)

___

### $discriminator

Re-exports [$discriminator](modules/decorators.md#$discriminator)

___

### $doc

Re-exports [$doc](modules/decorators.md#$doc)

___

### $docFromComment

Re-exports [$docFromComment](modules/decorators.md#$docfromcomment)

___

### $encode

Re-exports [$encode](modules/decorators.md#$encode)

___

### $error

Re-exports [$error](modules/decorators.md#$error)

___

### $format

Re-exports [$format](modules/decorators.md#$format)

___

### $friendlyName

Re-exports [$friendlyName](modules/decorators.md#$friendlyname)

___

### $indexer

Re-exports [$indexer](modules/decorators.md#$indexer)

___

### $inspectType

Re-exports [$inspectType](modules/decorators.md#$inspecttype)

___

### $inspectTypeName

Re-exports [$inspectTypeName](modules/decorators.md#$inspecttypename)

___

### $key

Re-exports [$key](modules/decorators.md#$key)

___

### $knownValues

Re-exports [$knownValues](modules/decorators.md#$knownvalues)

___

### $list

Re-exports [$list](modules/decorators.md#$list)

___

### $maxItems

Re-exports [$maxItems](modules/decorators.md#$maxitems)

___

### $maxLength

Re-exports [$maxLength](modules/decorators.md#$maxlength)

___

### $maxValue

Re-exports [$maxValue](modules/decorators.md#$maxvalue)

___

### $maxValueExclusive

Re-exports [$maxValueExclusive](modules/decorators.md#$maxvalueexclusive)

___

### $minItems

Re-exports [$minItems](modules/decorators.md#$minitems)

___

### $minLength

Re-exports [$minLength](modules/decorators.md#$minlength)

___

### $minValue

Re-exports [$minValue](modules/decorators.md#$minvalue)

___

### $minValueExclusive

Re-exports [$minValueExclusive](modules/decorators.md#$minvalueexclusive)

___

### $overload

Re-exports [$overload](modules/decorators.md#$overload)

___

### $pattern

Re-exports [$pattern](modules/decorators.md#$pattern)

___

### $projectedName

Re-exports [$projectedName](modules/decorators.md#$projectedname)

___

### $secret

Re-exports [$secret](modules/decorators.md#$secret)

___

### $service

Re-exports [$service](modules/decorators.md#$service)

___

### $summary

Re-exports [$summary](modules/decorators.md#$summary)

___

### $tag

Re-exports [$tag](modules/decorators.md#$tag)

___

### $visibility

Re-exports [$visibility](modules/decorators.md#$visibility)

___

### $withDefaultKeyVisibility

Re-exports [$withDefaultKeyVisibility](modules/decorators.md#$withdefaultkeyvisibility)

___

### $withOptionalProperties

Re-exports [$withOptionalProperties](modules/decorators.md#$withoptionalproperties)

___

### $withUpdateableProperties

Re-exports [$withUpdateableProperties](modules/decorators.md#$withupdateableproperties)

___

### $withVisibility

Re-exports [$withVisibility](modules/decorators.md#$withvisibility)

___

### $withoutDefaultValues

Re-exports [$withoutDefaultValues](modules/decorators.md#$withoutdefaultvalues)

___

### $withoutOmittedProperties

Re-exports [$withoutOmittedProperties](modules/decorators.md#$withoutomittedproperties)

___

### BytesKnownEncoding

Re-exports [BytesKnownEncoding](modules/decorators.md#bytesknownencoding)

___

### DateTimeKnownEncoding

Re-exports [DateTimeKnownEncoding](modules/decorators.md#datetimeknownencoding)

___

### Discriminator

Re-exports [Discriminator](interfaces/decorators.Discriminator.md)

___

### DocData

Re-exports [DocData](interfaces/decorators.DocData.md)

___

### DurationKnownEncoding

Re-exports [DurationKnownEncoding](modules/decorators.md#durationknownencoding)

___

### EncodeData

Re-exports [EncodeData](interfaces/decorators.EncodeData.md)

___

### Service

Re-exports [Service](interfaces/decorators.Service.md)

___

### ServiceDetails

Re-exports [ServiceDetails](interfaces/decorators.ServiceDetails.md)

___

### addService

Re-exports [addService](modules/decorators.md#addservice)

___

### getAllTags

Re-exports [getAllTags](modules/decorators.md#getalltags)

___

### getDeprecated

Re-exports [getDeprecated](modules/decorators.md#getdeprecated)

___

### getDiscriminatedTypes

Re-exports [getDiscriminatedTypes](modules/decorators.md#getdiscriminatedtypes)

___

### getDiscriminator

Re-exports [getDiscriminator](modules/decorators.md#getdiscriminator)

___

### getDoc

Re-exports [getDoc](modules/decorators.md#getdoc)

___

### getDocData

Re-exports [getDocData](modules/decorators.md#getdocdata)

___

### getEncode

Re-exports [getEncode](modules/decorators.md#getencode)

___

### getFormat

Re-exports [getFormat](modules/decorators.md#getformat)

___

### getFriendlyName

Re-exports [getFriendlyName](modules/decorators.md#getfriendlyname)

___

### getIndexer

Re-exports [getIndexer](modules/decorators.md#getindexer)

___

### getKeyName

Re-exports [getKeyName](modules/decorators.md#getkeyname)

___

### getKnownValues

Re-exports [getKnownValues](modules/decorators.md#getknownvalues)

___

### getListOperationType

Re-exports [getListOperationType](modules/decorators.md#getlistoperationtype)

___

### getMaxItems

Re-exports [getMaxItems](modules/decorators.md#getmaxitems)

___

### getMaxLength

Re-exports [getMaxLength](modules/decorators.md#getmaxlength)

___

### getMaxValue

Re-exports [getMaxValue](modules/decorators.md#getmaxvalue)

___

### getMaxValueExclusive

Re-exports [getMaxValueExclusive](modules/decorators.md#getmaxvalueexclusive)

___

### getMinItems

Re-exports [getMinItems](modules/decorators.md#getminitems)

___

### getMinLength

Re-exports [getMinLength](modules/decorators.md#getminlength)

___

### getMinValue

Re-exports [getMinValue](modules/decorators.md#getminvalue)

___

### getMinValueExclusive

Re-exports [getMinValueExclusive](modules/decorators.md#getminvalueexclusive)

___

### getOverloadedOperation

Re-exports [getOverloadedOperation](modules/decorators.md#getoverloadedoperation)

___

### getOverloads

Re-exports [getOverloads](modules/decorators.md#getoverloads)

___

### getPattern

Re-exports [getPattern](modules/decorators.md#getpattern)

___

### getProjectedName

Re-exports [getProjectedName](modules/decorators.md#getprojectedname)

___

### getProjectedNames

Re-exports [getProjectedNames](modules/decorators.md#getprojectednames)

___

### getPropertyType

Re-exports [getPropertyType](modules/decorators.md#getpropertytype)

___

### getService

Re-exports [getService](modules/decorators.md#getservice)

___

### getSummary

Re-exports [getSummary](modules/decorators.md#getsummary)

___

### getTags

Re-exports [getTags](modules/decorators.md#gettags)

___

### getVisibility

Re-exports [getVisibility](modules/decorators.md#getvisibility)

___

### hasProjectedName

Re-exports [hasProjectedName](modules/decorators.md#hasprojectedname)

___

### isArrayModelType

Re-exports [isArrayModelType](modules/decorators.md#isarraymodeltype)

___

### isDeprecated

Re-exports [isDeprecated](modules/decorators.md#isdeprecated)

___

### isErrorModel

Re-exports [isErrorModel](modules/decorators.md#iserrormodel)

___

### isKey

Re-exports [isKey](modules/decorators.md#iskey)

___

### isListOperation

Re-exports [isListOperation](modules/decorators.md#islistoperation)

___

### isNumericType

Re-exports [isNumericType](modules/decorators.md#isnumerictype)

___

### isRecordModelType

Re-exports [isRecordModelType](modules/decorators.md#isrecordmodeltype)

___

### isSecret

Re-exports [isSecret](modules/decorators.md#issecret)

___

### isService

Re-exports [isService](modules/decorators.md#isservice)

___

### isStringType

Re-exports [isStringType](modules/decorators.md#isstringtype)

___

### isVisible

Re-exports [isVisible](modules/decorators.md#isvisible)

___

### listServices

Re-exports [listServices](modules/decorators.md#listservices)

___

### namespace

Re-exports [namespace](modules/decorators.md#namespace)

## Type Aliases

### CadlCompletionItem

Ƭ **CadlCompletionItem**: [`TypeSpecCompletionItem`](interfaces/TypeSpecCompletionItem.md)

**`Deprecated`**

Use TypeSpecCompletionItem

___

### CadlLibrary

Ƭ **CadlLibrary**<`T`, `E`\>: [`TypeSpecLibrary`](interfaces/TypeSpecLibrary.md)<`T`, `E`\>

**`Deprecated`**

Use TypeSpecLibrary

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends `Object` |
| `E` | extends `Record`<`string`, `any`\> = `Record`<`string`, `never`\> |

___

### CadlLibraryDef

Ƭ **CadlLibraryDef**<`T`, `E`\>: [`TypeSpecLibraryDef`](interfaces/TypeSpecLibraryDef.md)<`T`, `E`\>

**`Deprecated`**

Use TypeSpecLibraryDef

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends `Object` |
| `E` | extends `Record`<`string`, `any`\> = `Record`<`string`, `never`\> |

___

### CadlManifest

Ƭ **CadlManifest**: [`TypeSpecManifest`](interfaces/TypeSpecManifest.md)

**`Deprecated`**

Use TypeSpecManifest

___

### CadlScriptNode

Ƭ **CadlScriptNode**: [`TypeSpecScriptNode`](interfaces/TypeSpecScriptNode.md)

**`Deprecated`**

Use TypeSpecScriptNode

___

### CadlValue

Ƭ **CadlValue**: [`TypeSpecValue`](index.md#typespecvalue)

**`Deprecated`**

Use TypeSpecValue

___

### Comment

Ƭ **Comment**: [`LineComment`](interfaces/LineComment.md) \| [`BlockComment`](interfaces/BlockComment.md)

___

### CreateTypeProps

Ƭ **CreateTypeProps**: `Omit`<[`Type`](index.md#type), ``"isFinished"`` \| keyof `TypePrototype`\>

___

### Declaration

Ƭ **Declaration**: [`ModelStatementNode`](interfaces/ModelStatementNode.md) \| [`ScalarStatementNode`](interfaces/ScalarStatementNode.md) \| [`InterfaceStatementNode`](interfaces/InterfaceStatementNode.md) \| [`UnionStatementNode`](interfaces/UnionStatementNode.md) \| [`NamespaceStatementNode`](interfaces/NamespaceStatementNode.md) \| [`OperationStatementNode`](interfaces/OperationStatementNode.md) \| [`TemplateParameterDeclarationNode`](interfaces/TemplateParameterDeclarationNode.md) \| [`ProjectionStatementNode`](interfaces/ProjectionStatementNode.md) \| [`ProjectionParameterDeclarationNode`](interfaces/ProjectionParameterDeclarationNode.md) \| [`ProjectionLambdaParameterDeclarationNode`](interfaces/ProjectionLambdaParameterDeclarationNode.md) \| [`EnumStatementNode`](interfaces/EnumStatementNode.md) \| [`AliasStatementNode`](interfaces/AliasStatementNode.md) \| [`DecoratorDeclarationStatementNode`](interfaces/DecoratorDeclarationStatementNode.md) \| [`FunctionDeclarationStatementNode`](interfaces/FunctionDeclarationStatementNode.md)

___

### DecoratorArgumentValue

Ƭ **DecoratorArgumentValue**: [`Type`](index.md#type) \| `number` \| `string` \| `boolean`

Type System types

___

### DiagnosticFormat

Ƭ **DiagnosticFormat**<`T`, `C`, `M`\>: `T`[`C`][`M`] extends [`CallableMessage`](interfaces/CallableMessage.md)<infer A\> ? { `format`: `Record`<`A`[`number`], `string`\>  } : `Record`<`string`, `unknown`\>

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends `Object` |
| `C` | extends keyof `T` |
| `M` | extends keyof `T`[`C`] = ``"default"`` |

___

### DiagnosticHandler

Ƭ **DiagnosticHandler**: (`diagnostic`: [`Diagnostic`](interfaces/Diagnostic.md)) => `void`

#### Type declaration

▸ (`diagnostic`): `void`

##### Parameters

| Name | Type |
| :------ | :------ |
| `diagnostic` | [`Diagnostic`](interfaces/Diagnostic.md) |

##### Returns

`void`

___

### DiagnosticMap

Ƭ **DiagnosticMap**<`T`\>: { readonly [code in keyof T]: DiagnosticDefinition<T[code]\> }

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends `Object` |

___

### DiagnosticReport

Ƭ **DiagnosticReport**<`T`, `C`, `M`\>: [`DiagnosticReportWithoutTarget`](index.md#diagnosticreportwithouttarget)<`T`, `C`, `M`\> & { `target`: [`DiagnosticTarget`](index.md#diagnostictarget) \| typeof [`NoTarget`](index.md#notarget)  }

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends `Object` |
| `C` | extends keyof `T` |
| `M` | extends keyof `T`[`C`] = ``"default"`` |

___

### DiagnosticReportWithoutTarget

Ƭ **DiagnosticReportWithoutTarget**<`T`, `C`, `M`\>: { `code`: `C` ; `messageId?`: `M`  } & [`DiagnosticFormat`](index.md#diagnosticformat)<`T`, `C`, `M`\>

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends `Object` |
| `C` | extends keyof `T` |
| `M` | extends keyof `T`[`C`] = ``"default"`` |

___

### DiagnosticResult

Ƭ **DiagnosticResult**<`T`\>: [`T`, readonly [`Diagnostic`](interfaces/Diagnostic.md)[]]

Return type of accessor functions in TypeSpec.
Tuple composed of:
- 0: Actual result of an accessor function
- 1: List of diagnostics that were emitted while retrieving the data.

#### Type parameters

| Name |
| :------ |
| `T` |

___

### DiagnosticSeverity

Ƭ **DiagnosticSeverity**: ``"error"`` \| ``"warning"``

___

### DiagnosticTarget

Ƭ **DiagnosticTarget**: [`Node`](index.md#node) \| [`Type`](index.md#type) \| [`Sym`](interfaces/Sym.md) \| [`SourceLocation`](interfaces/SourceLocation.md)

___

### Directive

Ƭ **Directive**: [`SuppressDirective`](interfaces/SuppressDirective.md)

___

### DirectiveArgument

Ƭ **DirectiveArgument**: [`StringLiteralNode`](interfaces/StringLiteralNode.md) \| [`IdentifierNode`](interfaces/IdentifierNode.md)

___

### DocContent

Ƭ **DocContent**: [`DocTextNode`](interfaces/DocTextNode.md)

___

### DocTag

Ƭ **DocTag**: [`DocReturnsTagNode`](interfaces/DocReturnsTagNode.md) \| [`DocParamTagNode`](interfaces/DocParamTagNode.md) \| [`DocTemplateTagNode`](interfaces/DocTemplateTagNode.md) \| [`DocUnknownTagNode`](interfaces/DocUnknownTagNode.md)

___

### DocToken

Ƭ **DocToken**: [`NewLine`](enums/Token.md#newline) \| [`Whitespace`](enums/Token.md#whitespace) \| [`ConflictMarker`](enums/Token.md#conflictmarker) \| [`Star`](enums/Token.md#star) \| [`At`](enums/Token.md#at) \| [`CloseBrace`](enums/Token.md#closebrace) \| [`Identifier`](enums/Token.md#identifier) \| [`DocText`](enums/Token.md#doctext) \| [`DocCodeSpan`](enums/Token.md#doccodespan) \| [`DocCodeFenceDelimiter`](enums/Token.md#doccodefencedelimiter) \| [`EndOfFile`](enums/Token.md#endoffile)

___

### EmitOptionsFor

Ƭ **EmitOptionsFor**<`C`\>: `C` extends [`TypeSpecLibrary`](interfaces/TypeSpecLibrary.md)<infer \_T, infer E\> ? `E` : `never`

Get the options for the onEmit of this library.

#### Type parameters

| Name |
| :------ |
| `C` |

___

### EmitterFunc

Ƭ **EmitterFunc**: (`context`: [`EmitContext`](interfaces/EmitContext.md)) => `Promise`<`void`\> \| `void`

#### Type declaration

▸ (`context`): `Promise`<`void`\> \| `void`

##### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`EmitContext`](interfaces/EmitContext.md) |

##### Returns

`Promise`<`void`\> \| `void`

___

### Expression

Ƭ **Expression**: [`ArrayExpressionNode`](interfaces/ArrayExpressionNode.md) \| [`MemberExpressionNode`](interfaces/MemberExpressionNode.md) \| [`ModelExpressionNode`](interfaces/ModelExpressionNode.md) \| [`TupleExpressionNode`](interfaces/TupleExpressionNode.md) \| [`UnionExpressionNode`](interfaces/UnionExpressionNode.md) \| [`IntersectionExpressionNode`](interfaces/IntersectionExpressionNode.md) \| [`TypeReferenceNode`](interfaces/TypeReferenceNode.md) \| [`ValueOfExpressionNode`](interfaces/ValueOfExpressionNode.md) \| [`IdentifierNode`](interfaces/IdentifierNode.md) \| [`StringLiteralNode`](interfaces/StringLiteralNode.md) \| [`NumericLiteralNode`](interfaces/NumericLiteralNode.md) \| [`BooleanLiteralNode`](interfaces/BooleanLiteralNode.md) \| [`VoidKeywordNode`](interfaces/VoidKeywordNode.md) \| [`NeverKeywordNode`](interfaces/NeverKeywordNode.md) \| [`AnyKeywordNode`](interfaces/AnyKeywordNode.md)

___

### InferredCadlValue

Ƭ **InferredCadlValue**<`K`\>: [`InferredTypeSpecValue`](index.md#inferredtypespecvalue)<`K`\>

**`Deprecated`**

Use InferredTypeSpecValue

#### Type parameters

| Name | Type |
| :------ | :------ |
| `K` | extends [`TypeKind`](index.md#typekind) |

___

### InferredTypeSpecValue

Ƭ **InferredTypeSpecValue**<`K`\>: `K` extends ``"Any"`` ? [`TypeSpecValue`](index.md#typespecvalue) : `K` extends infer T[] ? [`InferredTypeSpecValue`](index.md#inferredtypespecvalue)<`T`\> : `K` extends ``"String"`` ? `string` : `K` extends ``"Number"`` ? `number` : `K` extends ``"Boolean"`` ? `boolean` : [`Type`](index.md#type) & { `kind`: `K`  }

#### Type parameters

| Name | Type |
| :------ | :------ |
| `K` | extends [`TypeKind`](index.md#typekind) |

___

### IntrinsicScalarName

Ƭ **IntrinsicScalarName**: ``"bytes"`` \| ``"numeric"`` \| ``"integer"`` \| ``"float"`` \| ``"int64"`` \| ``"int32"`` \| ``"int16"`` \| ``"int8"`` \| ``"uint64"`` \| ``"uint32"`` \| ``"uint16"`` \| ``"uint8"`` \| ``"safeint"`` \| ``"float32"`` \| ``"float64"`` \| ``"decimal"`` \| ``"decimal128"`` \| ``"string"`` \| ``"plainDate"`` \| ``"plainTime"`` \| ``"utcDateTime"`` \| ``"offsetDateTime"`` \| ``"duration"`` \| ``"boolean"`` \| ``"url"``

___

### JSONSchemaType

Ƭ **JSONSchemaType**<`T`\>: `AjvJSONSchemaType`<`T`\>

#### Type parameters

| Name |
| :------ |
| `T` |

___

### LibraryMetadata

Ƭ **LibraryMetadata**: [`FileLibraryMetadata`](interfaces/FileLibraryMetadata.md) \| [`ModuleLibraryMetadata`](interfaces/ModuleLibraryMetadata.md)

___

### LinterRuleDiagnosticFormat

Ƭ **LinterRuleDiagnosticFormat**<`T`, `M`\>: `T`[`M`] extends [`CallableMessage`](interfaces/CallableMessage.md)<infer A\> ? { `format`: `Record`<`A`[`number`], `string`\>  } : `Record`<`string`, `unknown`\>

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends [`DiagnosticMessages`](interfaces/DiagnosticMessages.md) |
| `M` | extends keyof `T` = ``"default"`` |

___

### LinterRuleDiagnosticReport

Ƭ **LinterRuleDiagnosticReport**<`T`, `M`\>: [`LinterRuleDiagnosticReportWithoutTarget`](index.md#linterrulediagnosticreportwithouttarget)<`T`, `M`\> & { `target`: [`DiagnosticTarget`](index.md#diagnostictarget) \| typeof [`NoTarget`](index.md#notarget)  }

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends [`DiagnosticMessages`](interfaces/DiagnosticMessages.md) |
| `M` | extends keyof `T` = ``"default"`` |

___

### LinterRuleDiagnosticReportWithoutTarget

Ƭ **LinterRuleDiagnosticReportWithoutTarget**<`T`, `M`\>: { `messageId?`: `M`  } & [`LinterRuleDiagnosticFormat`](index.md#linterrulediagnosticformat)<`T`, `M`\>

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends [`DiagnosticMessages`](interfaces/DiagnosticMessages.md) |
| `M` | extends keyof `T` = ``"default"`` |

___

### LiteralNode

Ƭ **LiteralNode**: [`StringLiteralNode`](interfaces/StringLiteralNode.md) \| [`NumericLiteralNode`](interfaces/NumericLiteralNode.md) \| [`BooleanLiteralNode`](interfaces/BooleanLiteralNode.md)

___

### LiteralType

Ƭ **LiteralType**: [`StringLiteral`](interfaces/StringLiteral.md) \| [`NumericLiteral`](interfaces/NumericLiteral.md) \| [`BooleanLiteral`](interfaces/BooleanLiteral.md)

___

### LocationContext

Ƭ **LocationContext**: [`ProjectLocationContext`](interfaces/ProjectLocationContext.md) \| [`CompilerLocationContext`](interfaces/CompilerLocationContext.md) \| [`SyntheticLocationContext`](interfaces/SyntheticLocationContext.md) \| [`LibraryLocationContext`](interfaces/LibraryLocationContext.md)

Represent a location context in the mind of the compiler. This can be:
- the user project
- a library
- the compiler(standard library)
- virtual

___

### LogLevel

Ƭ **LogLevel**: ``"trace"`` \| ``"warning"`` \| ``"error"``

___

### MarshalledValue

Ƭ **MarshalledValue**<`Type`\>: `Type` extends [`StringLiteral`](interfaces/StringLiteral.md) ? `string` : `Type` extends [`NumericLiteral`](interfaces/NumericLiteral.md) ? `number` : `Type` extends [`BooleanLiteral`](interfaces/BooleanLiteral.md) ? `boolean` : `Type`

#### Type parameters

| Name |
| :------ |
| `Type` |

___

### MemberContainerNode

Ƭ **MemberContainerNode**: [`ModelStatementNode`](interfaces/ModelStatementNode.md) \| [`ModelExpressionNode`](interfaces/ModelExpressionNode.md) \| [`InterfaceStatementNode`](interfaces/InterfaceStatementNode.md) \| [`EnumStatementNode`](interfaces/EnumStatementNode.md) \| [`UnionStatementNode`](interfaces/UnionStatementNode.md)

Node types that can have referencable members

___

### MemberContainerType

Ƭ **MemberContainerType**: [`Model`](interfaces/Model.md) \| [`Enum`](interfaces/Enum.md) \| [`Interface`](interfaces/Interface.md) \| [`Union`](interfaces/Union.md)

___

### MemberNode

Ƭ **MemberNode**: [`ModelPropertyNode`](interfaces/ModelPropertyNode.md) \| [`EnumMemberNode`](interfaces/EnumMemberNode.md) \| [`OperationStatementNode`](interfaces/OperationStatementNode.md) \| [`UnionVariantNode`](interfaces/UnionVariantNode.md)

___

### MemberType

Ƭ **MemberType**: [`ModelProperty`](interfaces/ModelProperty.md) \| [`EnumMember`](interfaces/EnumMember.md) \| [`Operation`](interfaces/Operation.md) \| [`UnionVariant`](interfaces/UnionVariant.md)

Type that can be used as members of a container type.

___

### ModelIndexer

Ƭ **ModelIndexer**: `Object`

#### Type declaration

| Name | Type |
| :------ | :------ |
| `key` | [`Scalar`](interfaces/Scalar.md) |
| `value` | [`Type`](index.md#type) |

___

### Modifier

Ƭ **Modifier**: [`ExternKeywordNode`](interfaces/ExternKeywordNode.md)

___

### ModuleResolutionResult

Ƭ **ModuleResolutionResult**: [`ResolvedFile`](interfaces/ResolvedFile.md) \| [`ResolvedModule`](interfaces/ResolvedModule.md)

___

### NeverIndexer

Ƭ **NeverIndexer**: `Object`

#### Type declaration

| Name | Type |
| :------ | :------ |
| `key` | [`NeverType`](interfaces/NeverType.md) |
| `value` | `undefined` |

___

### NewLine

Ƭ **NewLine**: ``"lf"`` \| ``"crlf"``

___

### Node

Ƭ **Node**: [`TypeSpecScriptNode`](interfaces/TypeSpecScriptNode.md) \| [`JsSourceFileNode`](interfaces/JsSourceFileNode.md) \| [`TemplateParameterDeclarationNode`](interfaces/TemplateParameterDeclarationNode.md) \| [`ProjectionParameterDeclarationNode`](interfaces/ProjectionParameterDeclarationNode.md) \| [`ProjectionLambdaParameterDeclarationNode`](interfaces/ProjectionLambdaParameterDeclarationNode.md) \| [`ModelPropertyNode`](interfaces/ModelPropertyNode.md) \| [`UnionVariantNode`](interfaces/UnionVariantNode.md) \| [`OperationStatementNode`](interfaces/OperationStatementNode.md) \| [`OperationSignatureDeclarationNode`](interfaces/OperationSignatureDeclarationNode.md) \| [`OperationSignatureReferenceNode`](interfaces/OperationSignatureReferenceNode.md) \| [`EnumMemberNode`](interfaces/EnumMemberNode.md) \| [`EnumSpreadMemberNode`](interfaces/EnumSpreadMemberNode.md) \| [`ModelSpreadPropertyNode`](interfaces/ModelSpreadPropertyNode.md) \| [`DecoratorExpressionNode`](interfaces/DecoratorExpressionNode.md) \| [`DirectiveExpressionNode`](interfaces/DirectiveExpressionNode.md) \| [`Statement`](index.md#statement) \| [`Expression`](index.md#expression) \| [`FunctionParameterNode`](interfaces/FunctionParameterNode.md) \| [`Modifier`](index.md#modifier) \| [`DocNode`](interfaces/DocNode.md) \| [`DocContent`](index.md#doccontent) \| [`DocTag`](index.md#doctag) \| [`ProjectionStatementItem`](index.md#projectionstatementitem) \| [`ProjectionExpression`](index.md#projectionexpression) \| [`ProjectionModelSelectorNode`](interfaces/ProjectionModelSelectorNode.md) \| [`ProjectionModelPropertySelectorNode`](interfaces/ProjectionModelPropertySelectorNode.md) \| [`ProjectionInterfaceSelectorNode`](interfaces/ProjectionInterfaceSelectorNode.md) \| [`ProjectionOperationSelectorNode`](interfaces/ProjectionOperationSelectorNode.md) \| [`ProjectionEnumSelectorNode`](interfaces/ProjectionEnumSelectorNode.md) \| [`ProjectionEnumMemberSelectorNode`](interfaces/ProjectionEnumMemberSelectorNode.md) \| [`ProjectionUnionSelectorNode`](interfaces/ProjectionUnionSelectorNode.md) \| [`ProjectionUnionVariantSelectorNode`](interfaces/ProjectionUnionVariantSelectorNode.md) \| [`ProjectionModelPropertyNode`](interfaces/ProjectionModelPropertyNode.md) \| [`ProjectionModelSpreadPropertyNode`](interfaces/ProjectionModelSpreadPropertyNode.md) \| [`ProjectionStatementNode`](interfaces/ProjectionStatementNode.md) \| [`ProjectionNode`](interfaces/ProjectionNode.md)

___

### NodeCallback

Ƭ **NodeCallback**<`T`\>: (`c`: [`Node`](index.md#node)) => `T`

#### Type parameters

| Name |
| :------ |
| `T` |

#### Type declaration

▸ (`c`): `T`

##### Parameters

| Name | Type |
| :------ | :------ |
| `c` | [`Node`](index.md#node) |

##### Returns

`T`

___

### OperationContainer

Ƭ **OperationContainer**: [`Namespace`](interfaces/Namespace.md) \| [`Interface`](interfaces/Interface.md) \| [`Operation`](interfaces/Operation.md)

___

### OperationSignature

Ƭ **OperationSignature**: [`OperationSignatureDeclarationNode`](interfaces/OperationSignatureDeclarationNode.md) \| [`OperationSignatureReferenceNode`](interfaces/OperationSignatureReferenceNode.md)

___

### ProjectionExpression

Ƭ **ProjectionExpression**: [`ProjectionLogicalExpressionNode`](interfaces/ProjectionLogicalExpressionNode.md) \| [`ProjectionRelationalExpressionNode`](interfaces/ProjectionRelationalExpressionNode.md) \| [`ProjectionEqualityExpressionNode`](interfaces/ProjectionEqualityExpressionNode.md) \| [`ProjectionUnaryExpressionNode`](interfaces/ProjectionUnaryExpressionNode.md) \| [`ProjectionArithmeticExpressionNode`](interfaces/ProjectionArithmeticExpressionNode.md) \| [`ProjectionCallExpressionNode`](interfaces/ProjectionCallExpressionNode.md) \| [`ProjectionMemberExpressionNode`](interfaces/ProjectionMemberExpressionNode.md) \| [`ProjectionDecoratorReferenceExpressionNode`](interfaces/ProjectionDecoratorReferenceExpressionNode.md) \| [`ProjectionTupleExpressionNode`](interfaces/ProjectionTupleExpressionNode.md) \| [`ProjectionModelExpressionNode`](interfaces/ProjectionModelExpressionNode.md) \| [`ProjectionIfExpressionNode`](interfaces/ProjectionIfExpressionNode.md) \| [`ProjectionBlockExpressionNode`](interfaces/ProjectionBlockExpressionNode.md) \| [`ProjectionLambdaExpressionNode`](interfaces/ProjectionLambdaExpressionNode.md) \| [`StringLiteralNode`](interfaces/StringLiteralNode.md) \| [`NumericLiteralNode`](interfaces/NumericLiteralNode.md) \| [`BooleanLiteralNode`](interfaces/BooleanLiteralNode.md) \| [`IdentifierNode`](interfaces/IdentifierNode.md) \| [`VoidKeywordNode`](interfaces/VoidKeywordNode.md) \| [`NeverKeywordNode`](interfaces/NeverKeywordNode.md) \| [`AnyKeywordNode`](interfaces/AnyKeywordNode.md) \| [`ReturnExpressionNode`](interfaces/ReturnExpressionNode.md)

___

### ProjectionStatementItem

Ƭ **ProjectionStatementItem**: [`ProjectionExpressionStatementNode`](interfaces/ProjectionExpressionStatementNode.md)

___

### ReferenceExpression

Ƭ **ReferenceExpression**: [`TypeReferenceNode`](interfaces/TypeReferenceNode.md) \| [`MemberExpressionNode`](interfaces/MemberExpressionNode.md) \| [`IdentifierNode`](interfaces/IdentifierNode.md) \| [`VoidKeywordNode`](interfaces/VoidKeywordNode.md) \| [`NeverKeywordNode`](interfaces/NeverKeywordNode.md)

___

### RuleRef

Ƭ **RuleRef**: \`${string}/${string}\`

Reference to a rule. In this format `<library name>:<rule/ruleset name>`

___

### ScopeNode

Ƭ **ScopeNode**: [`NamespaceStatementNode`](interfaces/NamespaceStatementNode.md) \| [`ModelStatementNode`](interfaces/ModelStatementNode.md) \| [`InterfaceStatementNode`](interfaces/InterfaceStatementNode.md) \| [`AliasStatementNode`](interfaces/AliasStatementNode.md) \| [`TypeSpecScriptNode`](interfaces/TypeSpecScriptNode.md) \| [`JsSourceFileNode`](interfaces/JsSourceFileNode.md) \| [`ProjectionLambdaExpressionNode`](interfaces/ProjectionLambdaExpressionNode.md) \| [`ProjectionNode`](interfaces/ProjectionNode.md)

___

### SemanticNodeListener

Ƭ **SemanticNodeListener**: { `root?`: (`context`: [`Program`](interfaces/Program.md)) => `void` \| `undefined`  } & [`TypeListeners`](index.md#typelisteners)

___

### SourceFileKind

Ƭ **SourceFileKind**: ``"typespec"`` \| ``"js"``

Type of the source file that can be loaded via typespec

___

### Statement

Ƭ **Statement**: [`ImportStatementNode`](interfaces/ImportStatementNode.md) \| [`ModelStatementNode`](interfaces/ModelStatementNode.md) \| [`ScalarStatementNode`](interfaces/ScalarStatementNode.md) \| [`NamespaceStatementNode`](interfaces/NamespaceStatementNode.md) \| [`InterfaceStatementNode`](interfaces/InterfaceStatementNode.md) \| [`UnionStatementNode`](interfaces/UnionStatementNode.md) \| [`UsingStatementNode`](interfaces/UsingStatementNode.md) \| [`EnumStatementNode`](interfaces/EnumStatementNode.md) \| [`AliasStatementNode`](interfaces/AliasStatementNode.md) \| [`OperationStatementNode`](interfaces/OperationStatementNode.md) \| [`DecoratorDeclarationStatementNode`](interfaces/DecoratorDeclarationStatementNode.md) \| [`FunctionDeclarationStatementNode`](interfaces/FunctionDeclarationStatementNode.md) \| [`AugmentDecoratorStatementNode`](interfaces/AugmentDecoratorStatementNode.md) \| [`EmptyStatementNode`](interfaces/EmptyStatementNode.md) \| [`InvalidStatementNode`](interfaces/InvalidStatementNode.md) \| [`ProjectionStatementNode`](interfaces/ProjectionStatementNode.md)

___

### StdTypeName

Ƭ **StdTypeName**: keyof [`StdTypes`](index.md#stdtypes)

___

### StdTypes

Ƭ **StdTypes**: { `Array`: [`Model`](interfaces/Model.md) ; `Record`: [`Model`](interfaces/Model.md)  } & `Record`<[`IntrinsicScalarName`](index.md#intrinsicscalarname), [`Scalar`](interfaces/Scalar.md)\>

___

### TemplateableNode

Ƭ **TemplateableNode**: [`ModelStatementNode`](interfaces/ModelStatementNode.md) \| [`ScalarStatementNode`](interfaces/ScalarStatementNode.md) \| [`AliasStatementNode`](interfaces/AliasStatementNode.md) \| [`InterfaceStatementNode`](interfaces/InterfaceStatementNode.md) \| [`OperationStatementNode`](interfaces/OperationStatementNode.md) \| [`UnionStatementNode`](interfaces/UnionStatementNode.md)

Node that can be used as template

___

### TemplatedType

Ƭ **TemplatedType**: [`Model`](interfaces/Model.md) \| [`Operation`](interfaces/Operation.md) \| [`Interface`](interfaces/Interface.md) \| [`Union`](interfaces/Union.md)

Union of all the types that implement TemplatedTypeBase

___

### TrackableType

Ƭ **TrackableType**: [`Model`](interfaces/Model.md) \| [`Enum`](interfaces/Enum.md) \| [`Union`](interfaces/Union.md) \| [`Tuple`](interfaces/Tuple.md)

___

### Type

Ƭ **Type**: [`Model`](interfaces/Model.md) \| [`ModelProperty`](interfaces/ModelProperty.md) \| [`Scalar`](interfaces/Scalar.md) \| [`Interface`](interfaces/Interface.md) \| [`Enum`](interfaces/Enum.md) \| [`EnumMember`](interfaces/EnumMember.md) \| [`TemplateParameter`](interfaces/TemplateParameter.md) \| [`Namespace`](interfaces/Namespace.md) \| [`Operation`](interfaces/Operation.md) \| [`StringLiteral`](interfaces/StringLiteral.md) \| [`NumericLiteral`](interfaces/NumericLiteral.md) \| [`BooleanLiteral`](interfaces/BooleanLiteral.md) \| [`Tuple`](interfaces/Tuple.md) \| [`Union`](interfaces/Union.md) \| [`UnionVariant`](interfaces/UnionVariant.md) \| [`IntrinsicType`](interfaces/IntrinsicType.md) \| [`FunctionType`](interfaces/FunctionType.md) \| [`Decorator`](interfaces/Decorator.md) \| [`FunctionParameter`](interfaces/FunctionParameter.md) \| [`ObjectType`](interfaces/ObjectType.md) \| [`Projection`](interfaces/Projection.md)

___

### TypeKind

Ƭ **TypeKind**: [`Type`](index.md#type)[``"kind"``] \| ``"Any"``

___

### TypeListeners

Ƭ **TypeListeners**: `UnionToIntersection`<`ListenerForType`<[`Type`](index.md#type)\>\>

___

### TypeOfDiagnostics

Ƭ **TypeOfDiagnostics**<`T`\>: `T` extends [`DiagnosticMap`](index.md#diagnosticmap)<infer D\> ? `D` : `never`

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends [`DiagnosticMap`](index.md#diagnosticmap)<`any`\> |

___

### TypeOrReturnRecord

Ƭ **TypeOrReturnRecord**: [`Type`](index.md#type) \| [`ReturnRecord`](interfaces/ReturnRecord.md)

___

### TypeSpecValue

Ƭ **TypeSpecValue**: [`Type`](index.md#type) \| `string` \| `number` \| `boolean`

___

### WriteLine

Ƭ **WriteLine**: (`text?`: `string`) => `void`

#### Type declaration

▸ (`text?`): `void`

##### Parameters

| Name | Type |
| :------ | :------ |
| `text?` | `string` |

##### Returns

`void`

## Variables

### CadlPrettierPlugin

• `Const` **CadlPrettierPlugin**: `__module` = `TypeSpecPrettierPlugin`

**`Deprecated`**

Use TypeSpecPrettierPlugin

___

### Keywords

• `Const` **Keywords**: `ReadonlyMap`<`string`, [`Token`](enums/Token.md)\>

___

### MANIFEST

• `Const` **MANIFEST**: [`TypeSpecManifest`](interfaces/TypeSpecManifest.md) = `manifest`

___

### NoTarget

• `Const` **NoTarget**: typeof [`NoTarget`](index.md#notarget)

___

### NodeHost

• `Const` **NodeHost**: [`CompilerHost`](interfaces/CompilerHost.md)

Implementation of the

**`See`**

CompilerHost using the real file system.
This is the the CompilerHost used by TypeSpec CLI.

___

### TokenDisplay

• `Const` **TokenDisplay**: readonly `string`[]

___

### TypeSpecPrettierPlugin

• `Const` **TypeSpecPrettierPlugin**: `__module` = `formatter`

___

### altDirectorySeparator

• `Const` **altDirectorySeparator**: ``"\\"``

___

### cadlVersion

• `Const` **cadlVersion**: `any` = `typespecVersion`

**`Deprecated`**

Use typespecVersion

___

### directorySeparator

• `Const` **directorySeparator**: ``"/"``

Internally, we represent paths as strings with '/' as the directory separator.
When we make system calls (eg: LanguageServiceHost.getDirectory()),
we expect the host to correctly handle paths in our specified format.

___

### typespecVersion

• `Const` **typespecVersion**: `any` = `manifest.version`

## Functions

### assertType

▸ **assertType**<`TKind`\>(`typeDescription`, `t`, `...kinds`): asserts t is Object

Assert that the input type has one of the kinds provided

#### Type parameters

| Name | Type |
| :------ | :------ |
| `TKind` | extends (``"Model"`` \| ``"Scalar"`` \| ``"Interface"`` \| ``"Enum"`` \| ``"Operation"`` \| ``"Union"`` \| ``"Intrinsic"`` \| ``"ModelProperty"`` \| ``"EnumMember"`` \| ``"TemplateParameter"`` \| ``"Namespace"`` \| ``"String"`` \| ``"Number"`` \| ``"Boolean"`` \| ``"Tuple"`` \| ``"UnionVariant"`` \| ``"Function"`` \| ``"Decorator"`` \| ``"FunctionParameter"`` \| ``"Object"`` \| ``"Projection"``)[] |

#### Parameters

| Name | Type |
| :------ | :------ |
| `typeDescription` | `string` |
| `t` | [`Type`](index.md#type) |
| `...kinds` | `TKind` |

#### Returns

asserts t is Object

___

### cadlTypeToJson

▸ **cadlTypeToJson**<`T`\>(`typespecType`, `target`): [`T` \| `undefined`, [`Diagnostic`](interfaces/Diagnostic.md)[]]

**`Deprecated`**

use typespecTypeToJson

#### Type parameters

| Name |
| :------ |
| `T` |

#### Parameters

| Name | Type |
| :------ | :------ |
| `typespecType` | [`TypeSpecValue`](index.md#typespecvalue) |
| `target` | [`DiagnosticTarget`](index.md#diagnostictarget) |

#### Returns

[`T` \| `undefined`, [`Diagnostic`](interfaces/Diagnostic.md)[]]

___

### checkFormatCadl

▸ **checkFormatCadl**(`code`, `prettierConfig?`): `Promise`<`boolean`\>

**`Deprecated`**

use checkFormatTypeSpec

#### Parameters

| Name | Type |
| :------ | :------ |
| `code` | `string` |
| `prettierConfig?` | `Options` |

#### Returns

`Promise`<`boolean`\>

___

### checkFormatTypeSpec

▸ **checkFormatTypeSpec**(`code`, `prettierConfig?`): `Promise`<`boolean`\>

Check the given is correctly formatted.

#### Parameters

| Name | Type |
| :------ | :------ |
| `code` | `string` |
| `prettierConfig?` | `Options` |

#### Returns

`Promise`<`boolean`\>

true if code is formatted correctly.

___

### compile

▸ **compile**(`host`, `mainFile`, `options?`, `oldProgram?`): `Promise`<[`Program`](interfaces/Program.md)\>

#### Parameters

| Name | Type |
| :------ | :------ |
| `host` | [`CompilerHost`](interfaces/CompilerHost.md) |
| `mainFile` | `string` |
| `options` | `CompilerOptions` |
| `oldProgram?` | [`Program`](interfaces/Program.md) |

#### Returns

`Promise`<[`Program`](interfaces/Program.md)\>

___

### compilerAssert

▸ **compilerAssert**(`condition`, `message`, `target?`): asserts condition

Use this to report bugs in the compiler, and not errors in the source code
being compiled.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `condition` | `any` | Throw if this is not true. |
| `message` | `string` | Error message. |
| `target?` | [`DiagnosticTarget`](index.md#diagnostictarget) | Optional location in source code that might give a clue about what got the compiler off track. |

#### Returns

asserts condition

___

### createCadlLibrary

▸ **createCadlLibrary**<`T`, `E`\>(`lib`): [`TypeSpecLibrary`](interfaces/TypeSpecLibrary.md)<`T`, `E`\>

**`Deprecated`**

use createTypeSpecLibrary

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends `Object` |
| `E` | extends `Record`<`string`, `any`\> |

#### Parameters

| Name | Type |
| :------ | :------ |
| `lib` | `Readonly`<[`TypeSpecLibraryDef`](interfaces/TypeSpecLibraryDef.md)<`T`, `E`\>\> |

#### Returns

[`TypeSpecLibrary`](interfaces/TypeSpecLibrary.md)<`T`, `E`\>

___

### createChecker

▸ **createChecker**(`program`): [`Checker`](interfaces/Checker.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |

#### Returns

[`Checker`](interfaces/Checker.md)

___

### createDecoratorDefinition

▸ **createDecoratorDefinition**<`T`, `P`, `S`\>(`definition`): [`DecoratorValidator`](interfaces/DecoratorValidator.md)<`T`, `P`, `S`\>

**`Deprecated`**

use extern dec definition in typespec instead.

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends [`TypeKind`](index.md#typekind) |
| `P` | extends readonly [`DecoratorParamDefinition`](interfaces/DecoratorParamDefinition.md)<[`TypeKind`](index.md#typekind)\>[] |
| `S` | extends `undefined` \| [`DecoratorParamDefinition`](interfaces/DecoratorParamDefinition.md)<[`TypeKind`](index.md#typekind)\> |

#### Parameters

| Name | Type |
| :------ | :------ |
| `definition` | [`DecoratorDefinition`](interfaces/DecoratorDefinition.md)<`T`, `P`, `S`\> |

#### Returns

[`DecoratorValidator`](interfaces/DecoratorValidator.md)<`T`, `P`, `S`\>

___

### createDiagnosticCollector

▸ **createDiagnosticCollector**(): [`DiagnosticCollector`](interfaces/DiagnosticCollector.md)

Create a new instance of the

**`See`**

DiagnosticCollector.

#### Returns

[`DiagnosticCollector`](interfaces/DiagnosticCollector.md)

___

### createDiagnosticCreator

▸ **createDiagnosticCreator**<`T`\>(`diagnostics`, `libraryName?`): [`DiagnosticCreator`](interfaces/DiagnosticCreator.md)<`T`\>

Create a new diagnostics creator.

**`See`**

DiagnosticCreator

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends `Object` |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `diagnostics` | [`DiagnosticMap`](index.md#diagnosticmap)<`T`\> | Map of the potential diagnostics. |
| `libraryName?` | `string` | Optional name of the library if in the scope of a library. |

#### Returns

[`DiagnosticCreator`](interfaces/DiagnosticCreator.md)<`T`\>

___

### createProjectedNameProgram

▸ **createProjectedNameProgram**(`program`, `target`): [`ProjectedNameView`](interfaces/ProjectedNameView.md)

Create an helper to manager project names.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | Program |
| `target` | `string` | Name of the projected name target(e.g. json, csharp, etc.) |

#### Returns

[`ProjectedNameView`](interfaces/ProjectedNameView.md)

ProjectedNameView

___

### createRekeyableMap

▸ **createRekeyableMap**<`K`, `V`\>(`entries?`): [`RekeyableMap`](interfaces/RekeyableMap.md)<`K`, `V`\>

#### Type parameters

| Name |
| :------ |
| `K` |
| `V` |

#### Parameters

| Name | Type |
| :------ | :------ |
| `entries?` | [`K`, `V`][] |

#### Returns

[`RekeyableMap`](interfaces/RekeyableMap.md)<`K`, `V`\>

___

### createRule

▸ **createRule**<`N`, `T`\>(`definition`): [`LinterRuleDefinition`](interfaces/LinterRuleDefinition.md)<`N`, `T`\>

Create a new linter rule.

#### Type parameters

| Name | Type |
| :------ | :------ |
| `N` | extends `string` |
| `T` | extends [`DiagnosticMessages`](interfaces/DiagnosticMessages.md) |

#### Parameters

| Name | Type |
| :------ | :------ |
| `definition` | [`LinterRuleDefinition`](interfaces/LinterRuleDefinition.md)<`N`, `T`\> |

#### Returns

[`LinterRuleDefinition`](interfaces/LinterRuleDefinition.md)<`N`, `T`\>

___

### createScanner

▸ **createScanner**(`source`, `diagnosticHandler`): [`Scanner`](interfaces/Scanner.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `source` | `string` \| [`SourceFile`](interfaces/SourceFile.md) |
| `diagnosticHandler` | [`DiagnosticHandler`](index.md#diagnostichandler) |

#### Returns

[`Scanner`](interfaces/Scanner.md)

___

### createServer

▸ **createServer**(`host`): [`Server`](interfaces/Server.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `host` | [`ServerHost`](interfaces/ServerHost.md) |

#### Returns

[`Server`](interfaces/Server.md)

___

### createSourceFile

▸ **createSourceFile**(`text`, `path`): [`SourceFile`](interfaces/SourceFile.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `text` | `string` |
| `path` | `string` |

#### Returns

[`SourceFile`](interfaces/SourceFile.md)

___

### createStateAccessors

▸ **createStateAccessors**(`stateMaps`, `stateSets`, `projector?`): `Object`

#### Parameters

| Name | Type |
| :------ | :------ |
| `stateMaps` | `Map`<`symbol`, `StateMap`\> |
| `stateSets` | `Map`<`symbol`, `StateSet`\> |
| `projector?` | [`Projector`](interfaces/Projector.md) |

#### Returns

`Object`

| Name | Type |
| :------ | :------ |
| `stateMap` | <T\>(`key`: `symbol`) => `StateMapView`<`T`\> |
| `stateSet` | (`key`: `symbol`) => `StateSetView` |

___

### createTypeSpecLibrary

▸ **createTypeSpecLibrary**<`T`, `E`\>(`lib`): [`TypeSpecLibrary`](interfaces/TypeSpecLibrary.md)<`T`, `E`\>

Create a new TypeSpec library definition.

**`Tutorial`**

Create the lib object with `as const` to get the full typing.

**`Example`**

```ts
const libDef = {
  name: "myLib",
  diagnostics: {
   "my-code": {serverity: "error", messages: {default: "Foo bar"}}
  },
} as const;

const lib = createTypeSpecLibrary(libDef);
```

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends `Object` |
| `E` | extends `Record`<`string`, `any`\> |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `lib` | `Readonly`<[`TypeSpecLibraryDef`](interfaces/TypeSpecLibraryDef.md)<`T`, `E`\>\> | Library definition. |

#### Returns

[`TypeSpecLibrary`](interfaces/TypeSpecLibrary.md)<`T`, `E`\>

Library with utility functions.

___

### emitFile

▸ **emitFile**(`program`, `options`): `Promise`<`void`\>

Helper to emit a file.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | TypeSpec Program |
| `options` | [`EmitFileOptions`](interfaces/EmitFileOptions.md) | File Emitter options |

#### Returns

`Promise`<`void`\>

___

### ensurePathIsNonModuleName

▸ **ensurePathIsNonModuleName**(`path`): `string`

Ensures a path is either absolute (prefixed with `/` or `c:`) or dot-relative (prefixed
with `./` or `../`) so as not to be confused with an unprefixed module name.

```ts
ensurePathIsNonModuleName("/path/to/file.ext") === "/path/to/file.ext"
ensurePathIsNonModuleName("./path/to/file.ext") === "./path/to/file.ext"
ensurePathIsNonModuleName("../path/to/file.ext") === "../path/to/file.ext"
ensurePathIsNonModuleName("path/to/file.ext") === "./path/to/file.ext"
```

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |

#### Returns

`string`

___

### ensureTrailingDirectorySeparator

▸ **ensureTrailingDirectorySeparator**(`path`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |

#### Returns

`string`

___

### filterModelProperties

▸ **filterModelProperties**(`program`, `model`, `filter`): [`Model`](interfaces/Model.md)

Applies a filter to the properties of a given type. If no properties
are filtered out, then return the input unchanged. Otherwise, return
a new anonymous model with only the filtered properties.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) \| [`ProjectedProgram`](interfaces/ProjectedProgram.md) | - |
| `model` | [`Model`](interfaces/Model.md) | The input model to filter. |
| `filter` | (`property`: [`ModelProperty`](interfaces/ModelProperty.md)) => `boolean` | The filter to apply. Properties are kept when this returns true. |

#### Returns

[`Model`](interfaces/Model.md)

___

### finishTypeForProgram

▸ **finishTypeForProgram**<`T`\>(`program`, `typeDef`): `T`

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends [`Type`](index.md#type) |

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `typeDef` | `T` |

#### Returns

`T`

___

### formatDiagnostic

▸ **formatDiagnostic**(`diagnostic`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `diagnostic` | [`Diagnostic`](interfaces/Diagnostic.md) |

#### Returns

`string`

___

### formatIdentifier

▸ **formatIdentifier**(`sv`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `sv` | `string` |

#### Returns

`string`

___

### formatTypeSpec

▸ **formatTypeSpec**(`code`, `prettierConfig?`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `code` | `string` |
| `prettierConfig?` | `Options` |

#### Returns

`string`

___

### getAnyExtensionFromPath

▸ **getAnyExtensionFromPath**(`path`): `string`

Gets the file extension for a path.
Normalizes it to lower case.

```ts
getAnyExtensionFromPath("/path/to/file.ext") === ".ext"
getAnyExtensionFromPath("/path/to/file.ext/") === ".ext"
getAnyExtensionFromPath("/path/to/file") === ""
getAnyExtensionFromPath("/path/to.ext/file") === ""
```

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |

#### Returns

`string`

___

### getBaseFileName

▸ **getBaseFileName**(`path`): `string`

Returns the path except for its containing directory name.
Semantics align with NodeJS's `path.basename` except that we support URL's as well.

```ts
// POSIX
getBaseFileName("/path/to/file.ext") === "file.ext"
getBaseFileName("/path/to/") === "to"
getBaseFileName("/") === ""
// DOS
getBaseFileName("c:/path/to/file.ext") === "file.ext"
getBaseFileName("c:/path/to/") === "to"
getBaseFileName("c:/") === ""
getBaseFileName("c:") === ""
// URL
getBaseFileName("http://typescriptlang.org/path/to/file.ext") === "file.ext"
getBaseFileName("http://typescriptlang.org/path/to/") === "to"
getBaseFileName("http://typescriptlang.org/") === ""
getBaseFileName("http://typescriptlang.org") === ""
getBaseFileName("file://server/path/to/file.ext") === "file.ext"
getBaseFileName("file://server/path/to/") === "to"
getBaseFileName("file://server/") === ""
getBaseFileName("file://server") === ""
getBaseFileName("file:///path/to/file.ext") === "file.ext"
getBaseFileName("file:///path/to/") === "to"
getBaseFileName("file:///") === ""
getBaseFileName("file://") === ""
```

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |

#### Returns

`string`

___

### getCompletionNodeAtPosition

▸ **getCompletionNodeAtPosition**(`script`, `position`, `filter?`): [`Node`](index.md#node) \| `undefined`

Resolve the node that should be auto completed at the given position.
It will try to guess what node it could be as during auto complete the ast might not be complete.

#### Parameters

| Name | Type |
| :------ | :------ |
| `script` | [`TypeSpecScriptNode`](interfaces/TypeSpecScriptNode.md) |
| `position` | `number` |
| `filter` | (`node`: [`Node`](index.md#node)) => `boolean` |

#### Returns

[`Node`](index.md#node) \| `undefined`

___

### getDirectoryPath

▸ **getDirectoryPath**(`path`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |

#### Returns

`string`

___

### getDiscriminatedUnion

▸ **getDiscriminatedUnion**(`type`, `discriminator`): [[`DiscriminatedUnion`](interfaces/DiscriminatedUnion.md), readonly [`Diagnostic`](interfaces/Diagnostic.md)[]]

#### Parameters

| Name | Type |
| :------ | :------ |
| `type` | [`Model`](interfaces/Model.md) \| [`Union`](interfaces/Union.md) |
| `discriminator` | [`Discriminator`](interfaces/decorators.Discriminator.md) |

#### Returns

[[`DiscriminatedUnion`](interfaces/DiscriminatedUnion.md), readonly [`Diagnostic`](interfaces/Diagnostic.md)[]]

___

### getEffectiveModelType

▸ **getEffectiveModelType**(`program`, `model`, `filter?`): [`Model`](interfaces/Model.md)

If the input is anonymous (or the provided filter removes properties)
and there exists a named model with the same set of properties
(ignoring filtered properties), then return that named model.
Otherwise, return the input unchanged.

This can be used by emitters to find a better name for a set of
properties after filtering. For example, given `{ @metadata prop:
string} & SomeName`, and an emitter that wishes to discard properties
marked with `@metadata`, the emitter can use this to recover that the
best name for the remaining properties is `SomeName`.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | - |
| `model` | [`Model`](interfaces/Model.md) | The input model |
| `filter?` | (`property`: [`ModelProperty`](interfaces/ModelProperty.md)) => `boolean` | An optional filter to apply to the input model's properties. |

#### Returns

[`Model`](interfaces/Model.md)

___

### getFirstAncestor

▸ **getFirstAncestor**(`node`, `test`): [`Node`](index.md#node) \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `node` | [`Node`](index.md#node) |
| `test` | [`NodeCallback`](index.md#nodecallback)<`boolean`\> |

#### Returns

[`Node`](index.md#node) \| `undefined`

___

### getFullyQualifiedSymbolName

▸ **getFullyQualifiedSymbolName**(`sym`, `options?`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `sym` | `undefined` \| [`Sym`](interfaces/Sym.md) |
| `options?` | `Object` |
| `options.useGlobalPrefixAtTopLevel?` | `boolean` |

#### Returns

`string`

___

### getIdentifierContext

▸ **getIdentifierContext**(`id`): [`IdentifierContext`](interfaces/IdentifierContext.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `id` | [`IdentifierNode`](interfaces/IdentifierNode.md) |

#### Returns

[`IdentifierContext`](interfaces/IdentifierContext.md)

___

### getLocationContext

▸ **getLocationContext**(`program`, `type`): [`LocationContext`](index.md#locationcontext)

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `type` | [`DiagnosticTarget`](index.md#diagnostictarget) |

#### Returns

[`LocationContext`](index.md#locationcontext)

___

### getNamespaceFullName

▸ **getNamespaceFullName**(`type`, `options?`): `string`

Return the full name of the namespace(e.g. "Foo.Bar")

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `type` | [`Namespace`](interfaces/Namespace.md) | namespace type |
| `options?` | [`TypeNameOptions`](interfaces/TypeNameOptions.md) |  |

#### Returns

`string`

___

### getNodeAtPosition

▸ **getNodeAtPosition**(`script`, `position`, `filter?`): [`Node`](index.md#node) \| `undefined`

Resolve the node in the syntax tree that that is at the given position.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `script` | [`TypeSpecScriptNode`](interfaces/TypeSpecScriptNode.md) | TypeSpec Script node |
| `position` | `number` | Position |
| `filter?` | (`node`: [`Node`](index.md#node)) => `boolean` | Filter if wanting to return a parent containing node early. |

#### Returns

[`Node`](index.md#node) \| `undefined`

▸ **getNodeAtPosition**<`T`\>(`script`, `position`, `filter`): `T` \| `undefined`

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends [`Node`](index.md#node) |

#### Parameters

| Name | Type |
| :------ | :------ |
| `script` | [`TypeSpecScriptNode`](interfaces/TypeSpecScriptNode.md) |
| `position` | `number` |
| `filter` | (`node`: [`Node`](index.md#node)) => node is T |

#### Returns

`T` \| `undefined`

___

### getNormalizedAbsolutePath

▸ **getNormalizedAbsolutePath**(`fileName`, `currentDirectory`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `fileName` | `string` |
| `currentDirectory` | `undefined` \| `string` |

#### Returns

`string`

___

### getNormalizedAbsolutePathWithoutRoot

▸ **getNormalizedAbsolutePathWithoutRoot**(`fileName`, `currentDirectory`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `fileName` | `string` |
| `currentDirectory` | `undefined` \| `string` |

#### Returns

`string`

___

### getNormalizedPathComponents

▸ **getNormalizedPathComponents**(`path`, `currentDirectory`): `string`[]

Parse a path into an array containing a root component (at index 0) and zero or more path
components (at indices > 0). The result is normalized.
If the path is relative, the root component is `""`.
If the path is absolute, the root component includes the first path separator (`/`).

```ts
getNormalizedPathComponents("to/dir/../file.ext", "/path/") === ["/", "path", "to", "file.ext"]
```

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |
| `currentDirectory` | `undefined` \| `string` |

#### Returns

`string`[]

___

### getOverriddenProperty

▸ **getOverriddenProperty**(`property`): [`ModelProperty`](interfaces/ModelProperty.md) \| `undefined`

Gets the property from the nearest base type that is overridden by the
given property, if any.

#### Parameters

| Name | Type |
| :------ | :------ |
| `property` | [`ModelProperty`](interfaces/ModelProperty.md) |

#### Returns

[`ModelProperty`](interfaces/ModelProperty.md) \| `undefined`

___

### getParentTemplateNode

▸ **getParentTemplateNode**(`node`): [`Node`](index.md#node) & [`TemplateDeclarationNode`](interfaces/TemplateDeclarationNode.md) \| `undefined`

Lookup and find the node

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `node` | [`Node`](index.md#node) | Node |

#### Returns

[`Node`](index.md#node) & [`TemplateDeclarationNode`](interfaces/TemplateDeclarationNode.md) \| `undefined`

Template Parent node if applicable

___

### getPathComponents

▸ **getPathComponents**(`path`, `currentDirectory?`): `string`[]

Parse a path into an array containing a root component (at index 0) and zero or more path
components (at indices > 0). The result is not normalized.
If the path is relative, the root component is `""`.
If the path is absolute, the root component includes the first path separator (`/`).

```ts
// POSIX
getPathComponents("/path/to/file.ext") === ["/", "path", "to", "file.ext"]
getPathComponents("/path/to/") === ["/", "path", "to"]
getPathComponents("/") === ["/"]
// DOS
getPathComponents("c:/path/to/file.ext") === ["c:/", "path", "to", "file.ext"]
getPathComponents("c:/path/to/") === ["c:/", "path", "to"]
getPathComponents("c:/") === ["c:/"]
getPathComponents("c:") === ["c:"]
// URL
getPathComponents("http://typescriptlang.org/path/to/file.ext") === ["http://typescriptlang.org/", "path", "to", "file.ext"]
getPathComponents("http://typescriptlang.org/path/to/") === ["http://typescriptlang.org/", "path", "to"]
getPathComponents("http://typescriptlang.org/") === ["http://typescriptlang.org/"]
getPathComponents("http://typescriptlang.org") === ["http://typescriptlang.org"]
getPathComponents("file://server/path/to/file.ext") === ["file://server/", "path", "to", "file.ext"]
getPathComponents("file://server/path/to/") === ["file://server/", "path", "to"]
getPathComponents("file://server/") === ["file://server/"]
getPathComponents("file://server") === ["file://server"]
getPathComponents("file:///path/to/file.ext") === ["file:///", "path", "to", "file.ext"]
getPathComponents("file:///path/to/") === ["file:///", "path", "to"]
getPathComponents("file:///") === ["file:///"]
getPathComponents("file://") === ["file://"]
```

#### Parameters

| Name | Type | Default value |
| :------ | :------ | :------ |
| `path` | `string` | `undefined` |
| `currentDirectory` | `string` | `""` |

#### Returns

`string`[]

___

### getPathFromPathComponents

▸ **getPathFromPathComponents**(`pathComponents`): `string`

Formats a parsed path consisting of a root component (at index 0) and zero or more path
segments (at indices > 0).

```ts
getPathFromPathComponents(["/", "path", "to", "file.ext"]) === "/path/to/file.ext"
```

#### Parameters

| Name | Type |
| :------ | :------ |
| `pathComponents` | readonly `string`[] |

#### Returns

`string`

___

### getProperty

▸ **getProperty**(`type`, `propertyName`): [`ModelProperty`](interfaces/ModelProperty.md) \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `type` | [`Model`](interfaces/Model.md) |
| `propertyName` | `string` |

#### Returns

[`ModelProperty`](interfaces/ModelProperty.md) \| `undefined`

___

### getRelativePathFromDirectory

▸ **getRelativePathFromDirectory**(`from`, `to`, `ignoreCase`): `string`

Gets a relative path that can be used to traverse between `from` and `to`.

#### Parameters

| Name | Type |
| :------ | :------ |
| `from` | `string` |
| `to` | `string` |
| `ignoreCase` | `boolean` |

#### Returns

`string`

▸ **getRelativePathFromDirectory**(`fromDirectory`, `to`, `getCanonicalFileName`): `string`

Gets a relative path that can be used to traverse between `from` and `to`.

#### Parameters

| Name | Type |
| :------ | :------ |
| `fromDirectory` | `string` |
| `to` | `string` |
| `getCanonicalFileName` | `GetCanonicalFileName` |

#### Returns

`string`

___

### getRootLength

▸ **getRootLength**(`path`): `number`

Returns length of the root part of a path or URL (i.e. length of "/", "x:/", "//server/share/, file:///user/files").

For example:
```ts
getRootLength("a") === 0                   // ""
getRootLength("/") === 1                   // "/"
getRootLength("c:") === 2                  // "c:"
getRootLength("c:d") === 0                 // ""
getRootLength("c:/") === 3                 // "c:/"
getRootLength("c:\\") === 3                // "c:\\"
getRootLength("//server") === 7            // "//server"
getRootLength("//server/share") === 8      // "//server/"
getRootLength("\\\\server") === 7          // "\\\\server"
getRootLength("\\\\server\\share") === 8   // "\\\\server\\"
getRootLength("file:///path") === 8        // "file:///"
getRootLength("file:///c:") === 10         // "file:///c:"
getRootLength("file:///c:d") === 8         // "file:///"
getRootLength("file:///c:/path") === 11    // "file:///c:/"
getRootLength("file://server") === 13      // "file://server"
getRootLength("file://server/path") === 14 // "file://server/"
getRootLength("http://server") === 13      // "http://server"
getRootLength("http://server/path") === 14 // "http://server/"
```

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |

#### Returns

`number`

___

### getSourceFileKindFromExt

▸ **getSourceFileKindFromExt**(`path`): [`SourceFileKind`](index.md#sourcefilekind) \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |

#### Returns

[`SourceFileKind`](index.md#sourcefilekind) \| `undefined`

___

### getSourceLocation

▸ **getSourceLocation**(`target`): [`SourceLocation`](interfaces/SourceLocation.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `target` | [`DiagnosticTarget`](index.md#diagnostictarget) |

#### Returns

[`SourceLocation`](interfaces/SourceLocation.md)

▸ **getSourceLocation**(`target`): `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `target` | `undefined` \| typeof [`NoTarget`](index.md#notarget) |

#### Returns

`undefined`

▸ **getSourceLocation**(`target`): [`SourceLocation`](interfaces/SourceLocation.md) \| `undefined`

#### Parameters

| Name | Type |
| :------ | :------ |
| `target` | `undefined` \| typeof [`NoTarget`](index.md#notarget) \| [`DiagnosticTarget`](index.md#diagnostictarget) |

#### Returns

[`SourceLocation`](interfaces/SourceLocation.md) \| `undefined`

___

### getTypeName

▸ **getTypeName**(`type`, `options?`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `type` | [`Type`](index.md#type) \| [`ValueType`](interfaces/ValueType.md) |
| `options?` | [`TypeNameOptions`](interfaces/TypeNameOptions.md) |

#### Returns

`string`

___

### hasParseError

▸ **hasParseError**(`node`): `number` \| ``true``

#### Parameters

| Name | Type |
| :------ | :------ |
| `node` | [`Node`](index.md#node) |

#### Returns

`number` \| ``true``

___

### hasTrailingDirectorySeparator

▸ **hasTrailingDirectorySeparator**(`path`): `boolean`

Determines whether a path has a trailing separator (`/` or `\\`).

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |

#### Returns

`boolean`

___

### ignoreDiagnostics

▸ **ignoreDiagnostics**<`T`\>(`result`): `T`

Ignore the diagnostics emitted by the diagnostic accessor pattern and just return the actual result.

#### Type parameters

| Name |
| :------ |
| `T` |

#### Parameters

| Name | Type |
| :------ | :------ |
| `result` | [`DiagnosticResult`](index.md#diagnosticresult)<`T`\> |

#### Returns

`T`

Actual result.

___

### interpolatePath

▸ **interpolatePath**(`pathTemplate`, `predefinedVariables`): `string`

Interpolate a path template

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `pathTemplate` | `string` | Path template |
| `predefinedVariables` | `Record`<`string`, `undefined` \| `string`\> | Variables that can be used in the path template. |

#### Returns

`string`

___

### isAnyDirectorySeparator

▸ **isAnyDirectorySeparator**(`charCode`): `boolean`

Determines whether a charCode corresponds to `/` or ``.

#### Parameters

| Name | Type |
| :------ | :------ |
| `charCode` | `number` |

#### Returns

`boolean`

___

### isCadlValueTypeOf

▸ **isCadlValueTypeOf**<`K`\>(`target`, `expectedType`): target is InferredTypeSpecValue<K\>

**`Deprecated`**

use isTypeSpecValueTypeOf

#### Type parameters

| Name | Type |
| :------ | :------ |
| `K` | extends [`TypeKind`](index.md#typekind) |

#### Parameters

| Name | Type |
| :------ | :------ |
| `target` | [`TypeSpecValue`](index.md#typespecvalue) |
| `expectedType` | `K` \| readonly `K`[] |

#### Returns

target is InferredTypeSpecValue<K\>

___

### isComment

▸ **isComment**(`token`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `token` | [`Token`](enums/Token.md) |

#### Returns

`boolean`

___

### isDeclaredInNamespace

▸ **isDeclaredInNamespace**(`type`, `namespace`, `options?`): `boolean`

Check if the given type is declared in the specified namespace or, optionally, its child namespaces.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `type` | [`Model`](interfaces/Model.md) \| [`Interface`](interfaces/Interface.md) \| [`Enum`](interfaces/Enum.md) \| [`Namespace`](interfaces/Namespace.md) \| [`Operation`](interfaces/Operation.md) | Type |
| `namespace` | [`Namespace`](interfaces/Namespace.md) | Namespace |
| `options` | `Object` | - |
| `options.recursive?` | `boolean` | - |

#### Returns

`boolean`

___

### isDeclaredType

▸ **isDeclaredType**(`type`): `boolean`

Check if the type is a declared type. This include:
- non templated type
- template declaration

#### Parameters

| Name | Type |
| :------ | :------ |
| `type` | [`Type`](index.md#type) |

#### Returns

`boolean`

___

### isErrorType

▸ **isErrorType**(`type`): type is ErrorType

#### Parameters

| Name | Type |
| :------ | :------ |
| `type` | [`Type`](index.md#type) |

#### Returns

type is ErrorType

___

### isGlobalNamespace

▸ **isGlobalNamespace**(`program`, `namespace`): namespace is Namespace & Object

Check if the given namespace is the global namespace

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | Program |
| `namespace` | [`Namespace`](interfaces/Namespace.md) | Namespace |

#### Returns

namespace is Namespace & Object

___

### isImportStatement

▸ **isImportStatement**(`node`): node is ImportStatementNode

#### Parameters

| Name | Type |
| :------ | :------ |
| `node` | [`Node`](index.md#node) |

#### Returns

node is ImportStatementNode

___

### isIntrinsicType

▸ **isIntrinsicType**(`program`, `type`, `kind`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `type` | [`Scalar`](interfaces/Scalar.md) |
| `kind` | [`IntrinsicScalarName`](index.md#intrinsicscalarname) |

#### Returns

`boolean`

___

### isKeyword

▸ **isKeyword**(`token`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `token` | [`Token`](enums/Token.md) |

#### Returns

`boolean`

___

### isModifier

▸ **isModifier**(`token`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `token` | [`Token`](enums/Token.md) |

#### Returns

`boolean`

___

### isNeverType

▸ **isNeverType**(`type`): type is NeverType

#### Parameters

| Name | Type |
| :------ | :------ |
| `type` | [`Type`](index.md#type) |

#### Returns

type is NeverType

___

### isNullType

▸ **isNullType**(`type`): type is NullType

#### Parameters

| Name | Type |
| :------ | :------ |
| `type` | [`Type`](index.md#type) |

#### Returns

type is NullType

___

### isPathAbsolute

▸ **isPathAbsolute**(`path`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |

#### Returns

`boolean`

___

### isProjectedProgram

▸ **isProjectedProgram**(`program`): program is ProjectedProgram

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) \| [`ProjectedProgram`](interfaces/ProjectedProgram.md) |

#### Returns

program is ProjectedProgram

___

### isPunctuation

▸ **isPunctuation**(`token`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `token` | [`Token`](enums/Token.md) |

#### Returns

`boolean`

___

### isStatementKeyword

▸ **isStatementKeyword**(`token`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `token` | [`Token`](enums/Token.md) |

#### Returns

`boolean`

___

### isStdNamespace

▸ **isStdNamespace**(`namespace`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `namespace` | [`Namespace`](interfaces/Namespace.md) |

#### Returns

`boolean`

___

### isTemplateDeclaration

▸ **isTemplateDeclaration**(`type`): type is Object

Resolve if the type is a template type declaration(Non initialized template type).

#### Parameters

| Name | Type |
| :------ | :------ |
| `type` | [`TemplatedType`](index.md#templatedtype) |

#### Returns

type is Object

___

### isTemplateDeclarationOrInstance

▸ **isTemplateDeclarationOrInstance**(`type`): `boolean`

Resolve if the type was created from a template type or is a template type declaration.

#### Parameters

| Name | Type |
| :------ | :------ |
| `type` | [`TemplatedType`](index.md#templatedtype) |

#### Returns

`boolean`

___

### isTemplateInstance

▸ **isTemplateInstance**(`type`): type is Object

Check the given type is a finished template instance.

#### Parameters

| Name | Type |
| :------ | :------ |
| `type` | [`Type`](index.md#type) |

#### Returns

type is Object

___

### isTrivia

▸ **isTrivia**(`token`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `token` | [`Token`](enums/Token.md) |

#### Returns

`boolean`

___

### isTypeSpecValueTypeOf

▸ **isTypeSpecValueTypeOf**<`K`\>(`target`, `expectedType`): target is InferredTypeSpecValue<K\>

Check if the given target is of any of the typespec types.

#### Type parameters

| Name | Type |
| :------ | :------ |
| `K` | extends [`TypeKind`](index.md#typekind) |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `target` | [`TypeSpecValue`](index.md#typespecvalue) | Target to validate. |
| `expectedType` | `K` \| readonly `K`[] | One or multiple allowed typespec types. |

#### Returns

target is InferredTypeSpecValue<K\>

boolean if the target is of one of the allowed types.

___

### isUnknownType

▸ **isUnknownType**(`type`): type is UnknownType

#### Parameters

| Name | Type |
| :------ | :------ |
| `type` | [`Type`](index.md#type) |

#### Returns

type is UnknownType

___

### isUrl

▸ **isUrl**(`path`): `boolean`

Determines whether a path starts with a URL scheme (e.g. starts with `http://`, `ftp://`, `file://`, etc.).

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |

#### Returns

`boolean`

___

### isVoidType

▸ **isVoidType**(`type`): type is VoidType

#### Parameters

| Name | Type |
| :------ | :------ |
| `type` | [`Type`](index.md#type) |

#### Returns

type is VoidType

___

### joinPaths

▸ **joinPaths**(`path`, `...paths`): `string`

Combines paths. If a path is absolute, it replaces any previous path. Relative paths are not simplified.

```ts
// Non-rooted
joinPaths("path", "to", "file.ext") === "path/to/file.ext"
joinPaths("path", "dir", "..", "to", "file.ext") === "path/dir/../to/file.ext"
// POSIX
joinPaths("/path", "to", "file.ext") === "/path/to/file.ext"
joinPaths("/path", "/to", "file.ext") === "/to/file.ext"
// DOS
joinPaths("c:/path", "to", "file.ext") === "c:/path/to/file.ext"
joinPaths("c:/path", "c:/to", "file.ext") === "c:/to/file.ext"
// URL
joinPaths("file:///path", "to", "file.ext") === "file:///path/to/file.ext"
joinPaths("file:///path", "file:///to", "file.ext") === "file:///to/file.ext"
```

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |
| `...paths` | (`undefined` \| `string`)[] |

#### Returns

`string`

___

### listOperationsIn

▸ **listOperationsIn**(`container`, `options?`): [`Operation`](interfaces/Operation.md)[]

List operations in the given container. Will list operation recursively by default(Check subnamespaces.)

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `container` | [`Interface`](interfaces/Interface.md) \| [`Namespace`](interfaces/Namespace.md) | Container. |
| `options` | [`ListOperationOptions`](interfaces/ListOperationOptions.md) | Options. |

#### Returns

[`Operation`](interfaces/Operation.md)[]

___

### logDiagnostics

▸ **logDiagnostics**(`diagnostics`, `logger`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `diagnostics` | readonly [`Diagnostic`](interfaces/Diagnostic.md)[] |
| `logger` | [`LogSink`](interfaces/LogSink.md) |

#### Returns

`void`

___

### logVerboseTestOutput

▸ **logVerboseTestOutput**(`messageOrCallback`): `void`

Verbose output is enabled by default for runs in mocha explorer in VS Code,
where the output is nicely associated with the individual test, and disabled
by default for command line runs where we don't want to spam the console.

If the steps taken to produce the message are expensive, pass a callback
instead of producing the message then passing it here only to be dropped
when verbose output is disabled.

#### Parameters

| Name | Type |
| :------ | :------ |
| `messageOrCallback` | `string` \| (`log`: (`message`: `string`) => `void`) => `void` |

#### Returns

`void`

___

### mapEventEmitterToNodeListener

▸ **mapEventEmitterToNodeListener**(`eventEmitter`): [`SemanticNodeListener`](index.md#semanticnodelistener)

Create a Semantic node listener from an event emitter.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `eventEmitter` | [`EventEmitter`](classes/EventEmitter.md)<[`SemanticNodeListener`](index.md#semanticnodelistener)\> | Event emitter. |

#### Returns

[`SemanticNodeListener`](index.md#semanticnodelistener)

Semantic node listener.

___

### navigateProgram

▸ **navigateProgram**(`program`, `listeners`, `options?`): `void`

Navigate all types in the program.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | Program to navigate. |
| `listeners` | [`SemanticNodeListener`](index.md#semanticnodelistener) | Listener called when visiting types. |
| `options` | [`NavigationOptions`](interfaces/NavigationOptions.md) | Navigation options. |

#### Returns

`void`

___

### navigateType

▸ **navigateType**(`type`, `listeners`, `options`): `void`

Navigate the given type and all the types that are used in it.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `type` | [`Type`](index.md#type) | Type to navigate. |
| `listeners` | [`SemanticNodeListener`](index.md#semanticnodelistener) | Listener for the types found. |
| `options` | [`NavigationOptions`](interfaces/NavigationOptions.md) | Navigation options |

#### Returns

`void`

___

### navigateTypesInNamespace

▸ **navigateTypesInNamespace**(`namespace`, `listeners`, `options?`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `namespace` | [`Namespace`](interfaces/Namespace.md) |
| `listeners` | { `exitModel`: `undefined` \| `TypeListener`<[`Model`](interfaces/Model.md)\> ; `model`: `undefined` \| `TypeListener`<[`Model`](interfaces/Model.md)\>  } & { `exitModelProperty`: `undefined` \| `TypeListener`<[`ModelProperty`](interfaces/ModelProperty.md)\> ; `modelProperty`: `undefined` \| `TypeListener`<[`ModelProperty`](interfaces/ModelProperty.md)\>  } & { `exitScalar`: `undefined` \| `TypeListener`<[`Scalar`](interfaces/Scalar.md)\> ; `scalar`: `undefined` \| `TypeListener`<[`Scalar`](interfaces/Scalar.md)\>  } & { `exitInterface`: `undefined` \| `TypeListener`<[`Interface`](interfaces/Interface.md)\> ; `interface`: `undefined` \| `TypeListener`<[`Interface`](interfaces/Interface.md)\>  } & { `enum`: `undefined` \| `TypeListener`<[`Enum`](interfaces/Enum.md)\> ; `exitEnum`: `undefined` \| `TypeListener`<[`Enum`](interfaces/Enum.md)\>  } & { `enumMember`: `undefined` \| `TypeListener`<[`EnumMember`](interfaces/EnumMember.md)\> ; `exitEnumMember`: `undefined` \| `TypeListener`<[`EnumMember`](interfaces/EnumMember.md)\>  } & { `exitTemplateParameter`: `undefined` \| `TypeListener`<[`TemplateParameter`](interfaces/TemplateParameter.md)\> ; `templateParameter`: `undefined` \| `TypeListener`<[`TemplateParameter`](interfaces/TemplateParameter.md)\>  } & { `exitNamespace`: `undefined` \| `TypeListener`<[`Namespace`](interfaces/Namespace.md)\> ; `namespace`: `undefined` \| `TypeListener`<[`Namespace`](interfaces/Namespace.md)\>  } & { `exitOperation`: `undefined` \| `TypeListener`<[`Operation`](interfaces/Operation.md)\> ; `operation`: `undefined` \| `TypeListener`<[`Operation`](interfaces/Operation.md)\>  } & { `exitString`: `undefined` \| `TypeListener`<[`StringLiteral`](interfaces/StringLiteral.md)\> ; `string`: `undefined` \| `TypeListener`<[`StringLiteral`](interfaces/StringLiteral.md)\>  } & { `exitNumber`: `undefined` \| `TypeListener`<[`NumericLiteral`](interfaces/NumericLiteral.md)\> ; `number`: `undefined` \| `TypeListener`<[`NumericLiteral`](interfaces/NumericLiteral.md)\>  } & { `boolean`: `undefined` \| `TypeListener`<[`BooleanLiteral`](interfaces/BooleanLiteral.md)\> ; `exitBoolean`: `undefined` \| `TypeListener`<[`BooleanLiteral`](interfaces/BooleanLiteral.md)\>  } & { `exitTuple`: `undefined` \| `TypeListener`<[`Tuple`](interfaces/Tuple.md)\> ; `tuple`: `undefined` \| `TypeListener`<[`Tuple`](interfaces/Tuple.md)\>  } & { `exitUnion`: `undefined` \| `TypeListener`<[`Union`](interfaces/Union.md)\> ; `union`: `undefined` \| `TypeListener`<[`Union`](interfaces/Union.md)\>  } & { `exitUnionVariant`: `undefined` \| `TypeListener`<[`UnionVariant`](interfaces/UnionVariant.md)\> ; `unionVariant`: `undefined` \| `TypeListener`<[`UnionVariant`](interfaces/UnionVariant.md)\>  } & { `exitIntrinsic`: `undefined` \| `TypeListener`<[`IntrinsicType`](interfaces/IntrinsicType.md)\> ; `intrinsic`: `undefined` \| `TypeListener`<[`IntrinsicType`](interfaces/IntrinsicType.md)\>  } & { `exitFunction`: `undefined` \| `TypeListener`<[`FunctionType`](interfaces/FunctionType.md)\> ; `function`: `undefined` \| `TypeListener`<[`FunctionType`](interfaces/FunctionType.md)\>  } & { `decorator`: `undefined` \| `TypeListener`<[`Decorator`](interfaces/Decorator.md)\> ; `exitDecorator`: `undefined` \| `TypeListener`<[`Decorator`](interfaces/Decorator.md)\>  } & { `exitFunctionParameter`: `undefined` \| `TypeListener`<[`FunctionParameter`](interfaces/FunctionParameter.md)\> ; `functionParameter`: `undefined` \| `TypeListener`<[`FunctionParameter`](interfaces/FunctionParameter.md)\>  } & { `exitObject`: `undefined` \| `TypeListener`<[`ObjectType`](interfaces/ObjectType.md)\> ; `object`: `undefined` \| `TypeListener`<[`ObjectType`](interfaces/ObjectType.md)\>  } & { `exitProjection`: `undefined` \| `TypeListener`<[`Projection`](interfaces/Projection.md)\> ; `projection`: `undefined` \| `TypeListener`<[`Projection`](interfaces/Projection.md)\>  } |
| `options` | [`NamespaceNavigationOptions`](interfaces/NamespaceNavigationOptions.md) & [`NavigationOptions`](interfaces/NavigationOptions.md) |

#### Returns

`void`

___

### normalizePath

▸ **normalizePath**(`path`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |

#### Returns

`string`

___

### normalizeSlashes

▸ **normalizeSlashes**(`path`): `string`

Normalize path separators, converting `\` into `/`.

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |

#### Returns

`string`

___

### paramMessage

▸ **paramMessage**<`T`\>(`strings`, `...keys`): [`CallableMessage`](interfaces/CallableMessage.md)<`T`\>

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends `string`[] |

#### Parameters

| Name | Type |
| :------ | :------ |
| `strings` | readonly `string`[] |
| `...keys` | `T` |

#### Returns

[`CallableMessage`](interfaces/CallableMessage.md)<`T`\>

___

### parse

▸ **parse**(`code`, `options?`): [`TypeSpecScriptNode`](interfaces/TypeSpecScriptNode.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `code` | `string` \| [`SourceFile`](interfaces/SourceFile.md) |
| `options` | [`ParseOptions`](interfaces/ParseOptions.md) |

#### Returns

[`TypeSpecScriptNode`](interfaces/TypeSpecScriptNode.md)

___

### parseStandaloneTypeReference

▸ **parseStandaloneTypeReference**(`code`): [[`TypeReferenceNode`](interfaces/TypeReferenceNode.md), readonly [`Diagnostic`](interfaces/Diagnostic.md)[]]

#### Parameters

| Name | Type |
| :------ | :------ |
| `code` | `string` \| [`SourceFile`](interfaces/SourceFile.md) |

#### Returns

[[`TypeReferenceNode`](interfaces/TypeReferenceNode.md), readonly [`Diagnostic`](interfaces/Diagnostic.md)[]]

___

### projectProgram

▸ **projectProgram**(`program`, `projections`, `startNode?`): [`ProjectedProgram`](interfaces/ProjectedProgram.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) |
| `projections` | [`ProjectionApplication`](interfaces/ProjectionApplication.md)[] |
| `startNode?` | [`Type`](index.md#type) |

#### Returns

[`ProjectedProgram`](interfaces/ProjectedProgram.md)

___

### reducePathComponents

▸ **reducePathComponents**(`components`): `string`[]

Reduce an array of path components to a more simplified path by navigating any
`"."` or `".."` entries in the path.

#### Parameters

| Name | Type |
| :------ | :------ |
| `components` | readonly `string`[] |

#### Returns

`string`[]

___

### removeTrailingDirectorySeparator

▸ **removeTrailingDirectorySeparator**(`path`): `string`

Removes a trailing directory separator from a path, if it does not already have one.

```ts
removeTrailingDirectorySeparator("/path/to/file.ext") === "/path/to/file.ext"
removeTrailingDirectorySeparator("/path/to/file.ext/") === "/path/to/file.ext"
```

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |

#### Returns

`string`

___

### reportDeprecated

▸ **reportDeprecated**(`program`, `message`, `target`): `void`

Report a deprecated diagnostic.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | TypeSpec Program. |
| `message` | `string` | Message describing the deprecation. |
| `target` | typeof [`NoTarget`](index.md#notarget) \| [`DiagnosticTarget`](index.md#diagnostictarget) | Target of the deprecation. |

#### Returns

`void`

___

### resolveModule

▸ **resolveModule**(`host`, `name`, `options`): `Promise`<[`ModuleResolutionResult`](index.md#moduleresolutionresult)\>

Resolve a module

#### Parameters

| Name | Type |
| :------ | :------ |
| `host` | [`ResolveModuleHost`](interfaces/ResolveModuleHost.md) |
| `name` | `string` |
| `options` | [`ResolveModuleOptions`](interfaces/ResolveModuleOptions.md) |

#### Returns

`Promise`<[`ModuleResolutionResult`](index.md#moduleresolutionresult)\>

___

### resolvePath

▸ **resolvePath**(`path`, `...paths`): `string`

Combines and resolves paths. If a path is absolute, it replaces any previous path. Any
`.` and `..` path components are resolved. Trailing directory separators are preserved.

```ts
resolvePath("/path", "to", "file.ext") === "path/to/file.ext"
resolvePath("/path", "to", "file.ext/") === "path/to/file.ext/"
resolvePath("/path", "dir", "..", "to", "file.ext") === "path/to/file.ext"
```

#### Parameters

| Name | Type |
| :------ | :------ |
| `path` | `string` |
| `...paths` | (`undefined` \| `string`)[] |

#### Returns

`string`

___

### resolveUsages

▸ **resolveUsages**(`types`): [`UsageTracker`](interfaces/UsageTracker.md)

Resolve usage(input, output or both) of various types in the given namespace.
Will recursively scan all namespace, interfaces and operations contained inside the namespace.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `types` | [`OperationContainer`](index.md#operationcontainer) \| [`OperationContainer`](index.md#operationcontainer)[] | Entrypoint(s) namespace, interface or operations to get usage from. |

#### Returns

[`UsageTracker`](interfaces/UsageTracker.md)

Map of types to usage.

___

### scopeNavigationToNamespace

▸ **scopeNavigationToNamespace**<`T`\>(`namespace`, `listeners`, `options?`): `T`

Scope the current navigation to the given namespace.

#### Type parameters

| Name | Type |
| :------ | :------ |
| `T` | extends { `exitModel`: `undefined` \| `TypeListener`<[`Model`](interfaces/Model.md)\> ; `model`: `undefined` \| `TypeListener`<[`Model`](interfaces/Model.md)\>  } & { `exitModelProperty`: `undefined` \| `TypeListener`<[`ModelProperty`](interfaces/ModelProperty.md)\> ; `modelProperty`: `undefined` \| `TypeListener`<[`ModelProperty`](interfaces/ModelProperty.md)\>  } & { `exitScalar`: `undefined` \| `TypeListener`<[`Scalar`](interfaces/Scalar.md)\> ; `scalar`: `undefined` \| `TypeListener`<[`Scalar`](interfaces/Scalar.md)\>  } & { `exitInterface`: `undefined` \| `TypeListener`<[`Interface`](interfaces/Interface.md)\> ; `interface`: `undefined` \| `TypeListener`<[`Interface`](interfaces/Interface.md)\>  } & { `enum`: `undefined` \| `TypeListener`<[`Enum`](interfaces/Enum.md)\> ; `exitEnum`: `undefined` \| `TypeListener`<[`Enum`](interfaces/Enum.md)\>  } & { `enumMember`: `undefined` \| `TypeListener`<[`EnumMember`](interfaces/EnumMember.md)\> ; `exitEnumMember`: `undefined` \| `TypeListener`<[`EnumMember`](interfaces/EnumMember.md)\>  } & { `exitTemplateParameter`: `undefined` \| `TypeListener`<[`TemplateParameter`](interfaces/TemplateParameter.md)\> ; `templateParameter`: `undefined` \| `TypeListener`<[`TemplateParameter`](interfaces/TemplateParameter.md)\>  } & { `exitNamespace`: `undefined` \| `TypeListener`<[`Namespace`](interfaces/Namespace.md)\> ; `namespace`: `undefined` \| `TypeListener`<[`Namespace`](interfaces/Namespace.md)\>  } & { `exitOperation`: `undefined` \| `TypeListener`<[`Operation`](interfaces/Operation.md)\> ; `operation`: `undefined` \| `TypeListener`<[`Operation`](interfaces/Operation.md)\>  } & { `exitString`: `undefined` \| `TypeListener`<[`StringLiteral`](interfaces/StringLiteral.md)\> ; `string`: `undefined` \| `TypeListener`<[`StringLiteral`](interfaces/StringLiteral.md)\>  } & { `exitNumber`: `undefined` \| `TypeListener`<[`NumericLiteral`](interfaces/NumericLiteral.md)\> ; `number`: `undefined` \| `TypeListener`<[`NumericLiteral`](interfaces/NumericLiteral.md)\>  } & { `boolean`: `undefined` \| `TypeListener`<[`BooleanLiteral`](interfaces/BooleanLiteral.md)\> ; `exitBoolean`: `undefined` \| `TypeListener`<[`BooleanLiteral`](interfaces/BooleanLiteral.md)\>  } & { `exitTuple`: `undefined` \| `TypeListener`<[`Tuple`](interfaces/Tuple.md)\> ; `tuple`: `undefined` \| `TypeListener`<[`Tuple`](interfaces/Tuple.md)\>  } & { `exitUnion`: `undefined` \| `TypeListener`<[`Union`](interfaces/Union.md)\> ; `union`: `undefined` \| `TypeListener`<[`Union`](interfaces/Union.md)\>  } & { `exitUnionVariant`: `undefined` \| `TypeListener`<[`UnionVariant`](interfaces/UnionVariant.md)\> ; `unionVariant`: `undefined` \| `TypeListener`<[`UnionVariant`](interfaces/UnionVariant.md)\>  } & { `exitIntrinsic`: `undefined` \| `TypeListener`<[`IntrinsicType`](interfaces/IntrinsicType.md)\> ; `intrinsic`: `undefined` \| `TypeListener`<[`IntrinsicType`](interfaces/IntrinsicType.md)\>  } & { `exitFunction`: `undefined` \| `TypeListener`<[`FunctionType`](interfaces/FunctionType.md)\> ; `function`: `undefined` \| `TypeListener`<[`FunctionType`](interfaces/FunctionType.md)\>  } & { `decorator`: `undefined` \| `TypeListener`<[`Decorator`](interfaces/Decorator.md)\> ; `exitDecorator`: `undefined` \| `TypeListener`<[`Decorator`](interfaces/Decorator.md)\>  } & { `exitFunctionParameter`: `undefined` \| `TypeListener`<[`FunctionParameter`](interfaces/FunctionParameter.md)\> ; `functionParameter`: `undefined` \| `TypeListener`<[`FunctionParameter`](interfaces/FunctionParameter.md)\>  } & { `exitObject`: `undefined` \| `TypeListener`<[`ObjectType`](interfaces/ObjectType.md)\> ; `object`: `undefined` \| `TypeListener`<[`ObjectType`](interfaces/ObjectType.md)\>  } & { `exitProjection`: `undefined` \| `TypeListener`<[`Projection`](interfaces/Projection.md)\> ; `projection`: `undefined` \| `TypeListener`<[`Projection`](interfaces/Projection.md)\>  } |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `namespace` | [`Namespace`](interfaces/Namespace.md) | Namespace the traversal shouldn't leave. |
| `listeners` | `T` | Type listeners. |
| `options` | [`NamespaceNavigationOptions`](interfaces/NamespaceNavigationOptions.md) | Scope options |

#### Returns

`T`

wrapped listeners that that can be used with `navigateType`

___

### setCadlNamespace

▸ **setCadlNamespace**(`namespace`, `...functions`): `void`

**`Deprecated`**

use setTypeSpecNamespace

#### Parameters

| Name | Type |
| :------ | :------ |
| `namespace` | `string` |
| `...functions` | (...`args`: `any`[]) => `any`[] |

#### Returns

`void`

___

### setTypeSpecNamespace

▸ **setTypeSpecNamespace**(`namespace`, `...functions`): `void`

Set the TypeSpec namespace for that function.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `namespace` | `string` | Namespace string (e.g. "Foo.Bar") |
| `...functions` | (...`args`: `any`[]) => `any`[] | Functions |

#### Returns

`void`

___

### skipTrivia

▸ **skipTrivia**(`input`, `position`, `endPosition?`): `number`

#### Parameters

| Name | Type | Default value |
| :------ | :------ | :------ |
| `input` | `string` | `undefined` |
| `position` | `number` | `undefined` |
| `endPosition` | `number` | `input.length` |

#### Returns

`number`

___

### skipWhiteSpace

▸ **skipWhiteSpace**(`input`, `position`, `endPosition?`): `number`

#### Parameters

| Name | Type | Default value |
| :------ | :------ | :------ |
| `input` | `string` | `undefined` |
| `position` | `number` | `undefined` |
| `endPosition` | `number` | `input.length` |

#### Returns

`number`

___

### typespecTypeToJson

▸ **typespecTypeToJson**<`T`\>(`typespecType`, `target`): [`T` \| `undefined`, [`Diagnostic`](interfaces/Diagnostic.md)[]]

Convert a typespec type to a serializable Json object.
Emits diagnostics if the given type is invalid

#### Type parameters

| Name |
| :------ |
| `T` |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `typespecType` | [`TypeSpecValue`](index.md#typespecvalue) | The type to convert to Json data |
| `target` | [`DiagnosticTarget`](index.md#diagnostictarget) | The diagnostic target in case of errors. |

#### Returns

[`T` \| `undefined`, [`Diagnostic`](interfaces/Diagnostic.md)[]]

___

### validateDecoratorNotOnType

▸ **validateDecoratorNotOnType**(`context`, `type`, `badDecorator`, `givenDecorator`): `boolean`

Validate that a given decorator is not on a type or any of its base types.
Useful to check for decorator usage that conflicts with another decorator.

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) | Decorator context |
| `type` | [`Type`](index.md#type) | The type to check |
| `badDecorator` | [`DecoratorFunction`](interfaces/DecoratorFunction.md) | The decorator we don't want present |
| `givenDecorator` | [`DecoratorFunction`](interfaces/DecoratorFunction.md) | The decorator that is the reason why we don't want the bad decorator present |

#### Returns

`boolean`

Whether the decorator application is valid

___

### validateDecoratorParamCount

▸ **validateDecoratorParamCount**(`context`, `min`, `max`, `parameters`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `min` | `number` |
| `max` | `undefined` \| `number` |
| `parameters` | `unknown`[] |

#### Returns

`boolean`

___

### validateDecoratorParamType

▸ **validateDecoratorParamType**<`K`\>(`program`, `target`, `value`, `expectedType`): value is InferredTypeSpecValue<K\>

Validate a decorator parameter has the correct type.

**`Deprecated`**

use

**`See`**

createDecoratorDefinition#validate instead.

#### Type parameters

| Name | Type |
| :------ | :------ |
| `K` | extends ``"Model"`` \| ``"Scalar"`` \| ``"Interface"`` \| ``"Enum"`` \| ``"Operation"`` \| ``"Union"`` \| ``"Intrinsic"`` \| ``"ModelProperty"`` \| ``"EnumMember"`` \| ``"TemplateParameter"`` \| ``"Namespace"`` \| ``"String"`` \| ``"Number"`` \| ``"Boolean"`` \| ``"Tuple"`` \| ``"UnionVariant"`` \| ``"Function"`` \| ``"Decorator"`` \| ``"FunctionParameter"`` \| ``"Object"`` \| ``"Projection"`` |

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `program` | [`Program`](interfaces/Program.md) | Program |
| `target` | [`Type`](index.md#type) | Decorator target |
| `value` | [`TypeSpecValue`](index.md#typespecvalue) | Value of the parameter. |
| `expectedType` | `K` \| `K`[] | Expected type or list of expected type |

#### Returns

value is InferredTypeSpecValue<K\>

true if the value is of one of the type in the list of expected types. If not emit a diagnostic.

___

### validateDecoratorTarget

▸ **validateDecoratorTarget**<`K`\>(`context`, `target`, `decoratorName`, `expectedType`): target is K extends "Any" ? Type : Object

Validate the decorator target is matching the expected value.

#### Type parameters

| Name | Type |
| :------ | :------ |
| `K` | extends [`TypeKind`](index.md#typekind) |

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`Type`](index.md#type) |
| `decoratorName` | `string` |
| `expectedType` | `K` \| readonly `K`[] |

#### Returns

target is K extends "Any" ? Type : Object

___

### validateDecoratorTargetIntrinsic

▸ **validateDecoratorTargetIntrinsic**(`context`, `target`, `decoratorName`, `expectedType`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `target` | [`ModelProperty`](interfaces/ModelProperty.md) \| [`Scalar`](interfaces/Scalar.md) |
| `decoratorName` | `string` |
| `expectedType` | [`IntrinsicScalarName`](index.md#intrinsicscalarname) \| [`IntrinsicScalarName`](index.md#intrinsicscalarname)[] |

#### Returns

`boolean`

___

### validateDecoratorUniqueOnNode

▸ **validateDecoratorUniqueOnNode**(`context`, `type`, `decorator`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `context` | [`DecoratorContext`](interfaces/DecoratorContext.md) |
| `type` | [`Type`](index.md#type) |
| `decorator` | [`DecoratorFunction`](interfaces/DecoratorFunction.md) |

#### Returns

`boolean`

___

### visitChildren

▸ **visitChildren**<`T`\>(`node`, `cb`): `T` \| `undefined`

#### Type parameters

| Name |
| :------ |
| `T` |

#### Parameters

| Name | Type |
| :------ | :------ |
| `node` | [`Node`](index.md#node) |
| `cb` | [`NodeCallback`](index.md#nodecallback)<`T`\> |

#### Returns

`T` \| `undefined`

___

### walkPropertiesInherited

▸ **walkPropertiesInherited**(`model`): `Generator`<[`ModelProperty`](interfaces/ModelProperty.md), `void`, `unknown`\>

Enumerates the properties declared by model or inherited from its base.

Properties declared by more derived types are enumerated before properties
of less derived types.

Properties that are overridden are not enumerated.

#### Parameters

| Name | Type |
| :------ | :------ |
| `model` | [`Model`](interfaces/Model.md) |

#### Returns

`Generator`<[`ModelProperty`](interfaces/ModelProperty.md), `void`, `unknown`\>
