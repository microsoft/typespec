trigger:
  branches:
    include:
      - main
  paths:
    include:
      - packages/http-client-csharp/

pr: none

parameters:
  - name: CreateUpdatePR
    displayName: 'Create PR to azure-sdk-for-net'
    type: boolean
    default: false

extends:
  template: /eng/common/pipelines/templates/1es-redirect.yml

  parameters:
    stages:
      - template: /eng/emitters/pipelines/templates/stages/emitter-stages.yml
        parameters:
          BuildPrereleaseVersion: true
          UseTypeSpecNext: false
          Publish: ${{replace(replace('True',eq(variables['Build.SourceBranchName'], 'main'), 'public'),'True','internal')}}
          PublishDependsOnTest: true
          PackagePath: /packages/http-client-csharp
          EmitterPackageJsonPath: packages/http-client-csharp/package.json
          Packages:
            - name: typespec-http-client-csharp
              file: typespec-http-client-csharp-*.tgz
              type: npm
            - name: Microsoft.TypeSpec.Generator
              file: Microsoft.TypeSpec.Generator.*.nupkg
              type: nuget
            - name: Microsoft.TypeSpec.Generator.ClientModel
              file: Microsoft.TypeSpec.Generator.ClientModel.*.nupkg
              type: nuget
            - name: Microsoft.TypeSpec.Generator.Input
              file: Microsoft.TypeSpec.Generator.Input.*.nupkg
              type: nuget
            - name: Microsoft.TypeSpec.Generator.Customization
              file: Microsoft.TypeSpec.Generator.Customization.*.nupkg
              type: nuget
          UnitTestArgs: -UnitTests
          StagePrefix: "CSharp"
          LanguageShortName: "csharp"
          HasNugetPackages: true
          CadlRanchName: "@typespec/http-client-csharp"
          AdditionalInitializeSteps:
            - task: UseDotNet@2
              inputs:
                useGlobalJson: true
                workingDirectory: $(Build.SourcesDirectory)/packages/http-client-csharp

      - stage: CreateAzureSdkForNetPR
        displayName: Create PR for azure-sdk-for-net
        dependsOn: 
          - CSharp_Publish
          - CSharp_Build
        condition: and(succeeded(), or(and(ne(variables['Build.Reason'], 'Manual'), eq(variables['Build.SourceBranchName'], 'main')), eq('${{ parameters.CreateUpdatePR }}', 'true')))
        variables:
          PackageVersion: $[ stageDependencies.CSharp_Build.outputs['Build_linux_20.ci_build.emitterVersion'] ]
          # Try alternative references in case the primary one doesn't work
          PackageVersionAlt1: $[ dependencies.CSharp_Build.outputs['Build_linux_20.ci_build.emitterVersion'] ]  
          PackageVersionAlt2: $[ stageDependencies.CSharp_Build.outputs['Build_linux_20.Build_Packages.emitterVersion'] ]
          PackageVersionAlt3: $[ stageDependencies.CSharp_Build.outputs['Build_linux_20.ci_build.mgcClientModelVersion'] ]
          PackageVersionAlt4: $[ stageDependencies.CSharp_Build.outputs['Build_linux_20.ci_build.packageVersion'] ]
          PackageVersionAlt5: $[ stageDependencies.CSharp_Build.Build_linux_20.outputs['ci_build.emitterVersion'] ]
        pool:
          name: $(LINUXPOOL)
          image: $(LINUXVMIMAGE)
          os: linux
        jobs:
          - job: CreatePR
            steps:
              - checkout: self
              - pwsh: |
                  Write-Host "Package version: $(PackageVersion)"
                  Write-Host "Package version Alt1: $(PackageVersionAlt1)"
                  Write-Host "Package version Alt2: $(PackageVersionAlt2)"
                  Write-Host "Package version Alt3: $(PackageVersionAlt3)"
                  Write-Host "Package version Alt4: $(PackageVersionAlt4)"
                  Write-Host "Package version Alt5: $(PackageVersionAlt5)"
                  Write-Host "Debugging stage dependencies and outputs:"
                  
                  # Try different possible references as strings to see their literal values
                  Write-Host "Raw values to help debug:"
                  Write-Host "PackageVersion variable: '$(PackageVersion)'"
                  Write-Host "PackageVersionAlt1 variable: '$(PackageVersionAlt1)'"
                  Write-Host "PackageVersionAlt2 variable: '$(PackageVersionAlt2)'"
                  Write-Host "PackageVersionAlt3 variable: '$(PackageVersionAlt3)'"
                  Write-Host "PackageVersionAlt4 variable: '$(PackageVersionAlt4)'"
                  Write-Host "PackageVersionAlt5 variable: '$(PackageVersionAlt5)'"
                  # If all the above variables are empty, try to extract version from the repository 
                  if ([string]::IsNullOrEmpty('$(PackageVersion)') -and [string]::IsNullOrEmpty('$(PackageVersionAlt1)') -and [string]::IsNullOrEmpty('$(PackageVersionAlt2)') -and [string]::IsNullOrEmpty('$(PackageVersionAlt3)') -and [string]::IsNullOrEmpty('$(PackageVersionAlt4)') -and [string]::IsNullOrEmpty('$(PackageVersionAlt5)')) {
                    Write-Host "All version variables are empty, trying to extract from package.json"
                    $packageJsonPath = "$(Build.SourcesDirectory)/packages/http-client-csharp/package.json"
                    if (Test-Path $packageJsonPath) {
                      $packageJson = Get-Content $packageJsonPath | ConvertFrom-Json
                      $fallbackVersion = $packageJson.version
                      Write-Host "Fallback version from package.json: $fallbackVersion"
                      Write-Host "##vso[task.setvariable variable=FallbackPackageVersion]$fallbackVersion"
                    }
                  } else {
                    Write-Host "At least one version variable has a value, using the first non-empty one"
                    $selectedVersion = '$(PackageVersion)'
                    if ([string]::IsNullOrEmpty($selectedVersion)) { $selectedVersion = '$(PackageVersionAlt1)' }
                    if ([string]::IsNullOrEmpty($selectedVersion)) { $selectedVersion = '$(PackageVersionAlt2)' }
                    if ([string]::IsNullOrEmpty($selectedVersion)) { $selectedVersion = '$(PackageVersionAlt3)' }
                    if ([string]::IsNullOrEmpty($selectedVersion)) { $selectedVersion = '$(PackageVersionAlt4)' }
                    if ([string]::IsNullOrEmpty($selectedVersion)) { $selectedVersion = '$(PackageVersionAlt5)' }
                    Write-Host "Selected version: $selectedVersion"
                    Write-Host "##vso[task.setvariable variable=FinalPackageVersion]$selectedVersion"
                  }

                  # Determine the TypeSpec PR URL 
                  $sourceBranch = '$(Build.SourceBranch)'
                  $repoUrl = '$(Build.Repository.Uri)'
                  $buildReason = '$(Build.Reason)'
                  
                  if ($sourceBranch -match "^refs/pull/(\d+)/(head|merge)$") {
                    $typeSpecPRUrl = "$repoUrl/pull/$($Matches[1])"
                  } elseif ($sourceBranch -match "^refs/heads/(.+)$") {
                    $typeSpecPRUrl = "$repoUrl/tree/$($Matches[1])"
                  } else {
                    $typeSpecPRUrl = "$repoUrl/tree/$sourceBranch"
                  }
                  Write-Host "TypeSpec PR URL: $typeSpecPRUrl"
                  Write-Host "##vso[task.setvariable variable=TypeSpecPRUrl]$typeSpecPRUrl"
                displayName: Set variables for PR creation and debug outputs

              - task: PowerShell@2
                displayName: Create PR in azure-sdk-for-net
                inputs:
                  pwsh: true
                  filePath: $(Build.SourcesDirectory)/packages/http-client-csharp/eng/scripts/Submit-AzureSdkForNetPr.ps1
                  arguments: >
                    -PackageVersion '$(FinalPackageVersion)$(FallbackPackageVersion)'
                    -TypeSpecPRUrl '$(TypeSpecPRUrl)'
                    -AuthToken '$(azuresdk-github-pat)'
