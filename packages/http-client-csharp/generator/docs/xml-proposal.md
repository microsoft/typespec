# XML Serialization Support for Generated Models

## Table of Contents

1. [Motivation](#motivation)
2. [Design Overview](#design-overview)
3. [Sample TypeSpec](#sample-typespec)
4. [High Level Implementation Additions](#high-level-implementation-additions)
5. [Generated Code](#generated-code)
6. [Usage Examples](#usage-examples)

## Motivation

Some Azure services use XML as their wire format instead of JSON. Currently, the C# generator (MTG) only supports JSON serialization for models via the `IJsonModel<T>` and `IPersistableModel<T>` interfaces. To support services that use XML payloads, we need to add XML serialization capabilities to generated models.

The goal is to enable models to be serialized to and deserialized from XML using the existing `ModelReaderWriter` infrastructure, allowing seamless round-tripping of models in XML format.

## Design Overview

### Approach

The XML serialization support follows the same patterns established for JSON serialization:

1. **Format Support**: Extend the model's `IPersistableModel<T>` implementation to handle the `"X"` format for XML
2. **Parallel Structure**: Mirror the JSON serialization methods with XML equivalents

## Sample TypeSpec

The following TypeSpec defines a simple PetStore service that uses XML for request/response payloads:

```tsp
import "@typespec/rest";
import "@typespec/http";
import "@typespec/xml";

using TypeSpec.Http;

@service(#{ title: "Pet Store" })
@doc("Test for xml")
namespace PetStore;

model Dog {
  id: string;
  name: string;
  breed?: string;
}

model Address {
  city: string;
  street?: string;
  zipCode?: string;
}

model PetDetails {
  id: string;
  ownerName: string;
  petName: string;
  address: Address;
}

@post
@route("/dogs")
op uploadDog(@header contentType: "application/xml", @body body: Dog): NoContentResponse;

@get
@route("/petDetails/{id}")
op getPetDetails(@path id: string, @header accept: "application/xml"): PetDetails;
```

## High Level Implementation Additions

### XML Serialization Methods

Two new methods handle XML writing:

```csharp
// Private method that writes the root element wrapper
private void WriteXml(XmlWriter writer, ModelReaderWriterOptions options, string nameHint = null)
{
    writer.WriteStartElement(nameHint ?? "Dog");
    WriteXmlContentCore(writer, options);
    writer.WriteEndElement();
}

// Protected virtual method for writing inner content - extensibility point for derived types
protected virtual void WriteXmlContentCore(XmlWriter writer, ModelReaderWriterOptions options)
{
    string format = options.Format == "W" ? ((IPersistableModel<Dog>)this).GetFormatFromOptions(options) : options.Format;
    if (format != "X")
    {
        throw new FormatException($"The model {nameof(Dog)} does not support writing '{format}' format.");
    }
    writer.WriteStartElement("id");
    writer.WriteValue(Id);
    writer.WriteEndElement();
    writer.WriteStartElement("name");
    writer.WriteValue(Name);
    writer.WriteEndElement();
    if (Optional.IsDefined(Breed))
    {
        writer.WriteStartElement("breed");
        writer.WriteValue(Breed);
        writer.WriteEndElement();
    }
}
```

### XML Deserialization Method

A new overload of the `Deserialize` method handles XML:

```csharp
internal static Dog DeserializeDog(XElement element, ModelReaderWriterOptions options)
{
    if (element == null)
    {
        return null;
    }

    string id = default;
    string name = default;
    string breed = default;

    foreach (var child in element.Elements())
    {
        var localName = child.Name.LocalName;
        if (localName == "id")
        {
            id = (string)child;
            continue;
        }
        if (localName == "name")
        {
            name = (string)child;
            continue;
        }
        if (localName == "breed")
        {
            breed = (string)child;
            continue;
        }
    }

    return new Dog(id, name, breed, additionalBinaryDataProperties: default);
}
```

### Azure Branded Implementation

For Azure branded libraries, models that support XML will also implement Azure Core's `IXmlSerializable` and the existing `IJsonModel<T>`:

```csharp
public partial class Dog : IXmlSerializable, IJsonModel<Dog>
{
    // ...
    void IXmlSerializable.Write(XmlWriter writer, string nameHint) => WriteXml(writer, ModelSerializationExtensions.WireOptions, nameHint);
    // ...
}
```

## Generated Code

This section shows the complete generated serialization code for each model in the PetStore library.

### Dog.Serialization.cs

<details>
<summary>Click to expand</summary>

```csharp
// <auto-generated/>

#nullable disable

using System;
using System.ClientModel;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.IO;
using System.Text.Json;
using System.Xml;
using System.Xml.Linq;

namespace PetStore
{
    /// <summary> The Dog. </summary>
    public partial class Dog : IJsonModel<Dog>
    {
        /// <summary> Initializes a new instance of <see cref="Dog"/> for deserialization. </summary>
        internal Dog()
        {
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        void IJsonModel<Dog>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<Dog>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(Dog)} does not support writing '{format}' format.");
            }
            writer.WritePropertyName("id"u8);
            writer.WriteStringValue(Id);
            writer.WritePropertyName("name"u8);
            writer.WriteStringValue(Name);
            if (Optional.IsDefined(Breed))
            {
                writer.WritePropertyName("breed"u8);
                writer.WriteStringValue(Breed);
            }
            if (options.Format != "W" && _additionalBinaryDataProperties != null)
            {
                foreach (var item in _additionalBinaryDataProperties)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
                    writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        private void WriteXml(XmlWriter writer, ModelReaderWriterOptions options, string nameHint = null)
        {
            writer.WriteStartElement(nameHint ?? "Dog");
            WriteXmlContentCore(writer, options);
            writer.WriteEndElement();
        }

        /// <summary> Writes the XML content of this model without the root element wrapper. </summary>
        /// <param name="writer"> The XML writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void WriteXmlContentCore(XmlWriter writer, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<Dog>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "X")
            {
                throw new FormatException($"The model {nameof(Dog)} does not support writing '{format}' format.");
            }
            writer.WriteStartElement("id");
            writer.WriteValue(Id);
            writer.WriteEndElement();
            writer.WriteStartElement("name");
            writer.WriteValue(Name);
            writer.WriteEndElement();
            if (Optional.IsDefined(Breed))
            {
                writer.WriteStartElement("breed");
                writer.WriteValue(Breed);
                writer.WriteEndElement();
            }
        }

        /// <param name="reader"> The JSON reader. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        Dog IJsonModel<Dog>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => JsonModelCreateCore(ref reader, options);

        /// <param name="reader"> The JSON reader. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual Dog JsonModelCreateCore(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<Dog>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(Dog)} does not support reading '{format}' format.");
            }
            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeDog(document.RootElement, options);
        }

        /// <param name="element"> The JSON element to deserialize. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        internal static Dog DeserializeDog(JsonElement element, ModelReaderWriterOptions options)
        {
            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string id = default;
            string name = default;
            string breed = default;
            IDictionary<string, BinaryData> additionalBinaryDataProperties = new ChangeTrackingDictionary<string, BinaryData>();
            foreach (var prop in element.EnumerateObject())
            {
                if (prop.NameEquals("id"u8))
                {
                    id = prop.Value.GetString();
                    continue;
                }
                if (prop.NameEquals("name"u8))
                {
                    name = prop.Value.GetString();
                    continue;
                }
                if (prop.NameEquals("breed"u8))
                {
                    breed = prop.Value.GetString();
                    continue;
                }
                if (options.Format != "W")
                {
                    additionalBinaryDataProperties.Add(prop.Name, BinaryData.FromString(prop.Value.GetRawText()));
                }
            }
            return new Dog(id, name, breed, additionalBinaryDataProperties);
        }

        internal static Dog DeserializeDog(XElement element, ModelReaderWriterOptions options)
        {
            if (element == null)
            {
                return null;
            }

            string id = default;
            string name = default;
            string breed = default;

            foreach (var child in element.Elements())
            {
                var localName = child.Name.LocalName;
                if (localName == "id")
                {
                    id = (string)child;
                    continue;
                }
                if (localName == "name")
                {
                    name = (string)child;
                    continue;
                }
                if (localName == "breed")
                {
                    breed = (string)child;
                    continue;
                }
            }

            return new Dog(id, name, breed, additionalBinaryDataProperties: default);
        }

        /// <param name="options"> The client options for reading and writing models. </param>
        BinaryData IPersistableModel<Dog>.Write(ModelReaderWriterOptions options) => PersistableModelWriteCore(options);

        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual BinaryData PersistableModelWriteCore(ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<Dog>)this).GetFormatFromOptions(options) : options.Format;
            switch (format)
            {
                case "X":
                    {
                        using MemoryStream stream = new MemoryStream(256);
                        using (XmlWriter writer = XmlWriter.Create(stream))
                        {
                            WriteXml(writer, options);
                        }
                        return new BinaryData(stream.ToArray());
                    }
                case "J":
                    return ModelReaderWriter.Write(this, options, PetStoreContext.Default);
                default:
                    throw new FormatException($"The model {nameof(Dog)} does not support writing '{options.Format}' format.");
            }
        }

        /// <param name="data"> The data to parse. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        Dog IPersistableModel<Dog>.Create(BinaryData data, ModelReaderWriterOptions options) => PersistableModelCreateCore(data, options);

        /// <param name="data"> The data to parse. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual Dog PersistableModelCreateCore(BinaryData data, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<Dog>)this).GetFormatFromOptions(options) : options.Format;
            switch (format)
            {
                case "X":
                    using (var dataStream = data.ToStream())
                    {
                        return DeserializeDog(XElement.Load(dataStream, LoadOptions.None), options);
                    }
                case "J":
                    using (JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        return DeserializeDog(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(Dog)} does not support reading '{options.Format}' format.");
            }
        }

        /// <param name="options"> The client options for reading and writing models. </param>
        string IPersistableModel<Dog>.GetFormatFromOptions(ModelReaderWriterOptions options) => "X";

        /// <param name="dog"> The <see cref="Dog"/> to serialize into <see cref="BinaryContent"/>. </param>
        public static implicit operator BinaryContent(Dog dog)
        {
            if (dog == null)
            {
                return null;
            }
            return BinaryContent.Create(dog, ModelSerializationExtensions.WireOptions);
        }
    }
}
```

</details>

### Address.Serialization.cs

<details>
<summary>Click to expand</summary>

```csharp
// <auto-generated/>

#nullable disable

using System;
using System.ClientModel;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.IO;
using System.Text.Json;
using System.Xml;
using System.Xml.Linq;

namespace PetStore
{
    /// <summary> The Address. </summary>
    public partial class Address : IJsonModel<Address>
    {
        /// <summary> Initializes a new instance of <see cref="Address"/> for deserialization. </summary>
        internal Address()
        {
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        void IJsonModel<Address>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<Address>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(Address)} does not support writing '{format}' format.");
            }
            writer.WritePropertyName("city"u8);
            writer.WriteStringValue(City);
            if (Optional.IsDefined(Street))
            {
                writer.WritePropertyName("street"u8);
                writer.WriteStringValue(Street);
            }
            if (Optional.IsDefined(ZipCode))
            {
                writer.WritePropertyName("zipCode"u8);
                writer.WriteStringValue(ZipCode);
            }
            if (options.Format != "W" && _additionalBinaryDataProperties != null)
            {
                foreach (var item in _additionalBinaryDataProperties)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
                    writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        private void WriteXml(XmlWriter writer, ModelReaderWriterOptions options, string nameHint = null)
        {
            writer.WriteStartElement(nameHint ?? "Address");
            WriteXmlContentCore(writer, options);
            writer.WriteEndElement();
        }

        /// <summary> Writes the XML content of this model without the root element wrapper. </summary>
        /// <param name="writer"> The XML writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void WriteXmlContentCore(XmlWriter writer, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<Address>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "X")
            {
                throw new FormatException($"The model {nameof(Address)} does not support writing '{format}' format.");
            }
            writer.WriteStartElement("city");
            writer.WriteValue(City);
            writer.WriteEndElement();
            if (Optional.IsDefined(Street))
            {
                writer.WriteStartElement("street");
                writer.WriteValue(Street);
                writer.WriteEndElement();
            }
            if (Optional.IsDefined(ZipCode))
            {
                writer.WriteStartElement("zipCode");
                writer.WriteValue(ZipCode);
                writer.WriteEndElement();
            }
        }

        /// <param name="reader"> The JSON reader. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        Address IJsonModel<Address>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => JsonModelCreateCore(ref reader, options);

        /// <param name="reader"> The JSON reader. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual Address JsonModelCreateCore(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<Address>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(Address)} does not support reading '{format}' format.");
            }
            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeAddress(document.RootElement, options);
        }

        /// <param name="element"> The JSON element to deserialize. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        internal static Address DeserializeAddress(JsonElement element, ModelReaderWriterOptions options)
        {
            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string city = default;
            string street = default;
            string zipCode = default;
            IDictionary<string, BinaryData> additionalBinaryDataProperties = new ChangeTrackingDictionary<string, BinaryData>();
            foreach (var prop in element.EnumerateObject())
            {
                if (prop.NameEquals("city"u8))
                {
                    city = prop.Value.GetString();
                    continue;
                }
                if (prop.NameEquals("street"u8))
                {
                    street = prop.Value.GetString();
                    continue;
                }
                if (prop.NameEquals("zipCode"u8))
                {
                    zipCode = prop.Value.GetString();
                    continue;
                }
                if (options.Format != "W")
                {
                    additionalBinaryDataProperties.Add(prop.Name, BinaryData.FromString(prop.Value.GetRawText()));
                }
            }
            return new Address(city, street, zipCode, additionalBinaryDataProperties);
        }

        internal static Address DeserializeAddress(XElement element, ModelReaderWriterOptions options)
        {
            if (element == null)
            {
                return null;
            }

            string city = default;
            string street = default;
            string zipCode = default;

            foreach (var child in element.Elements())
            {
                var localName = child.Name.LocalName;
                if (localName == "city")
                {
                    city = (string)child;
                    continue;
                }
                if (localName == "street")
                {
                    street = (string)child;
                    continue;
                }
                if (localName == "zipCode")
                {
                    zipCode = (string)child;
                    continue;
                }
            }

            return new Address(city, street, zipCode, additionalBinaryDataProperties: default);
        }

        /// <param name="options"> The client options for reading and writing models. </param>
        BinaryData IPersistableModel<Address>.Write(ModelReaderWriterOptions options) => PersistableModelWriteCore(options);

        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual BinaryData PersistableModelWriteCore(ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<Address>)this).GetFormatFromOptions(options) : options.Format;
            switch (format)
            {
                case "X":
                    {
                        using MemoryStream stream = new MemoryStream(256);
                        using (XmlWriter writer = XmlWriter.Create(stream))
                        {
                            WriteXml(writer, options);
                        }
                        return new BinaryData(stream.ToArray());
                    }
                case "J":
                    return ModelReaderWriter.Write(this, options, PetStoreContext.Default);
                default:
                    throw new FormatException($"The model {nameof(Address)} does not support writing '{options.Format}' format.");
            }
        }

        /// <param name="data"> The data to parse. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        Address IPersistableModel<Address>.Create(BinaryData data, ModelReaderWriterOptions options) => PersistableModelCreateCore(data, options);

        /// <param name="data"> The data to parse. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual Address PersistableModelCreateCore(BinaryData data, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<Address>)this).GetFormatFromOptions(options) : options.Format;
            switch (format)
            {
                case "X":
                    using (var dataStream = data.ToStream())
                    {
                        return DeserializeAddress(XElement.Load(dataStream, LoadOptions.None), options);
                    }
                case "J":
                    using (JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        return DeserializeAddress(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(Address)} does not support reading '{options.Format}' format.");
            }
        }

        /// <param name="options"> The client options for reading and writing models. </param>
        string IPersistableModel<Address>.GetFormatFromOptions(ModelReaderWriterOptions options) => "X";
    }
}
```

</details>

### PetDetails.Serialization.cs

<details>
<summary>Click to expand</summary>

```csharp
// <auto-generated/>

#nullable disable

using System;
using System.ClientModel;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.IO;
using System.Text.Json;
using System.Xml;
using System.Xml.Linq;

namespace PetStore
{
    /// <summary> The PetDetails. </summary>
    public partial class PetDetails : IJsonModel<PetDetails>
    {
        /// <summary> Initializes a new instance of <see cref="PetDetails"/> for deserialization. </summary>
        internal PetDetails()
        {
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        void IJsonModel<PetDetails>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<PetDetails>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(PetDetails)} does not support writing '{format}' format.");
            }
            writer.WritePropertyName("id"u8);
            writer.WriteStringValue(Id);
            writer.WritePropertyName("ownerName"u8);
            writer.WriteStringValue(OwnerName);
            writer.WritePropertyName("petName"u8);
            writer.WriteStringValue(PetName);
            writer.WritePropertyName("address"u8);
            writer.WriteObjectValue(Address, options);
            if (options.Format != "W" && _additionalBinaryDataProperties != null)
            {
                foreach (var item in _additionalBinaryDataProperties)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
                    writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        private void WriteXml(XmlWriter writer, ModelReaderWriterOptions options, string nameHint = null)
        {
            writer.WriteStartElement(nameHint ?? "PetDetails");
            WriteXmlContentCore(writer, options);
            writer.WriteEndElement();
        }

        /// <summary> Writes the XML content of this model without the root element wrapper. </summary>
        /// <param name="writer"> The XML writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void WriteXmlContentCore(XmlWriter writer, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<PetDetails>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "X")
            {
                throw new FormatException($"The model {nameof(PetDetails)} does not support writing '{format}' format.");
            }
            writer.WriteStartElement("id");
            writer.WriteValue(Id);
            writer.WriteEndElement();
            writer.WriteStartElement("ownerName");
            writer.WriteValue(OwnerName);
            writer.WriteEndElement();
            writer.WriteStartElement("petName");
            writer.WriteValue(PetName);
            writer.WriteEndElement();
            writer.WriteObjectValue(Address, options, "address");
        }

        /// <param name="reader"> The JSON reader. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        PetDetails IJsonModel<PetDetails>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => JsonModelCreateCore(ref reader, options);

        /// <param name="reader"> The JSON reader. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual PetDetails JsonModelCreateCore(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<PetDetails>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(PetDetails)} does not support reading '{format}' format.");
            }
            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializePetDetails(document.RootElement, options);
        }

        /// <param name="element"> The JSON element to deserialize. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        internal static PetDetails DeserializePetDetails(JsonElement element, ModelReaderWriterOptions options)
        {
            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string id = default;
            string ownerName = default;
            string petName = default;
            Address address = default;
            IDictionary<string, BinaryData> additionalBinaryDataProperties = new ChangeTrackingDictionary<string, BinaryData>();
            foreach (var prop in element.EnumerateObject())
            {
                if (prop.NameEquals("id"u8))
                {
                    id = prop.Value.GetString();
                    continue;
                }
                if (prop.NameEquals("ownerName"u8))
                {
                    ownerName = prop.Value.GetString();
                    continue;
                }
                if (prop.NameEquals("petName"u8))
                {
                    petName = prop.Value.GetString();
                    continue;
                }
                if (prop.NameEquals("address"u8))
                {
                    address = Address.DeserializeAddress(prop.Value, options);
                    continue;
                }
                if (options.Format != "W")
                {
                    additionalBinaryDataProperties.Add(prop.Name, BinaryData.FromString(prop.Value.GetRawText()));
                }
            }
            return new PetDetails(id, ownerName, petName, address, additionalBinaryDataProperties);
        }

        internal static PetDetails DeserializePetDetails(XElement element, ModelReaderWriterOptions options)
        {
            if (element == null)
            {
                return null;
            }

            string id = default;
            string ownerName = default;
            string petName = default;
            Address address = default;

            foreach (var child in element.Elements())
            {
                var localName = child.Name.LocalName;
                if (localName == "id")
                {
                    id = (string)child;
                    continue;
                }
                if (localName == "ownerName")
                {
                    ownerName = (string)child;
                    continue;
                }
                if (localName == "petName")
                {
                    petName = (string)child;
                    continue;
                }
                if (localName == "address")
                {
                    address = Address.DeserializeAddress(child, options);
                    continue;
                }
            }

            return new PetDetails(id, ownerName, petName, address, additionalBinaryDataProperties: default);
        }

        /// <param name="options"> The client options for reading and writing models. </param>
        BinaryData IPersistableModel<PetDetails>.Write(ModelReaderWriterOptions options) => PersistableModelWriteCore(options);

        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual BinaryData PersistableModelWriteCore(ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<PetDetails>)this).GetFormatFromOptions(options) : options.Format;
            switch (format)
            {
                case "X":
                    {
                        using MemoryStream stream = new MemoryStream(256);
                        using (XmlWriter writer = XmlWriter.Create(stream))
                        {
                            WriteXml(writer, options);
                        }
                        return new BinaryData(stream.ToArray());
                    }
                case "J":
                    return ModelReaderWriter.Write(this, options, PetStoreContext.Default);
                default:
                    throw new FormatException($"The model {nameof(PetDetails)} does not support writing '{options.Format}' format.");
            }
        }

        /// <param name="data"> The data to parse. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        PetDetails IPersistableModel<PetDetails>.Create(BinaryData data, ModelReaderWriterOptions options) => PersistableModelCreateCore(data, options);

        /// <param name="data"> The data to parse. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual PetDetails PersistableModelCreateCore(BinaryData data, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<PetDetails>)this).GetFormatFromOptions(options) : options.Format;
            switch (format)
            {
                case "X":
                    using (var dataStream = data.ToStream())
                    {
                        return DeserializePetDetails(XElement.Load(dataStream, LoadOptions.None), options);
                    }
                case "J":
                    using (JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        return DeserializePetDetails(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(PetDetails)} does not support reading '{options.Format}' format.");
            }
        }

        /// <param name="options"> The client options for reading and writing models. </param>
        string IPersistableModel<PetDetails>.GetFormatFromOptions(ModelReaderWriterOptions options) => "X";

        /// <param name="result"> The <see cref="ClientResult"/> to deserialize the <see cref="PetDetails"/> from. </param>
        public static explicit operator PetDetails(ClientResult result)
        {
            PipelineResponse response = result.GetRawResponse();
            using (var dataStream = response.Content.ToStream())
            {
                return DeserializePetDetails(XElement.Load(dataStream, LoadOptions.None), ModelSerializationExtensions.WireOptions);
            }
        }
    }
}
```

</details>

## Usage Examples

### Round-Tripping a Model with ModelReaderWriter

The `ModelReaderWriter` class provides a simple API for serializing and deserializing models. With XML support, users can easily round-trip models in XML format:

#### Serializing to XML

```csharp
// Create a Dog model instance
var dog = new Dog("dog-123", "Buddy", "Golden Retriever");

// Serialize to XML using ModelReaderWriter
var xmlOptions = new ModelReaderWriterOptions("X");
BinaryData xmlData = ModelReaderWriter.Write(dog, xmlOptions);

// Get the XML string
string xml = xmlData.ToString();
// Output: <?xml version="1.0" encoding="utf-8"?><Dog><id>dog-123</id><name>Buddy</name><breed>Golden Retriever</breed></Dog>
```

#### Deserializing from XML

```csharp
// XML data received from a service
string xml = @"<?xml version=""1.0"" encoding=""utf-8""?><Dog><id>dog-456</id><name>Max</name><breed>Labrador</breed></Dog>";
BinaryData xmlData = BinaryData.FromString(xml);

// Deserialize from XML using ModelReaderWriter
var xmlOptions = new ModelReaderWriterOptions("X");
Dog dog = ModelReaderWriter.Read<Dog>(xmlData, xmlOptions);

Console.WriteLine($"Id: {dog.Id}, Name: {dog.Name}, Breed: {dog.Breed}");
// Output: Id: dog-456, Name: Max, Breed: Labrador
```

#### Complete Round-Trip Example

```csharp
using System.ClientModel.Primitives;

// Create original model
var original = new Dog("dog-789", "Charlie", "Beagle");

// Define XML format options
var xmlOptions = new ModelReaderWriterOptions("X");

// Serialize to XML
BinaryData xmlData = ModelReaderWriter.Write(original, xmlOptions);
Console.WriteLine($"Serialized XML: {xmlData}");

// Deserialize back to model
Dog roundTripped = ModelReaderWriter.Read<Dog>(xmlData, xmlOptions);

// Verify the round-trip
Console.WriteLine($"Original: Id={original.Id}, Name={original.Name}, Breed={original.Breed}");
Console.WriteLine($"Round-tripped: Id={roundTripped.Id}, Name={roundTripped.Name}, Breed={roundTripped.Breed}");
```
