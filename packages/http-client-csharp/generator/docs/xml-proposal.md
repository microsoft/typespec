# XML Serialization Support for Generated Models

## Table of Contents

1. [Motivation](#motivation)
2. [Design Overview](#design-overview)
3. [Sample TypeSpec](#sample-typespec)
4. [High Level Implementation Additions](#high-level-implementation-additions)
5. [Generated Code](#generated-code)
6. [Usage Examples](#usage-examples)

## Motivation

Some Azure services use XML as their wire format instead of JSON. Currently, the C# generator (MTG) only supports JSON serialization for models via the `IJsonModel<T>` and `IPersistableModel<T>` interfaces. To support services that use XML payloads, we need to add XML serialization capabilities to generated models.

The goal is to enable models to be serialized to and deserialized from XML using the existing `ModelReaderWriter` infrastructure, allowing seamless round-tripping of models in XML format.

## Design Overview

### Approach

The XML serialization support leverages the `IPersistableModel<T>` infrastructure:

1. **Format Support**: Models implement `IPersistableModel<T>` to handle the `"X"` format for XML
2. **XML Methods**: Provide XML-specific serialization and deserialization methods using `XmlWriter` and `XElement`

## Sample TypeSpec

The following TypeSpec defines a simple PetStore service that uses XML for request/response payloads:

```tsp
import "@typespec/rest";
import "@typespec/http";
import "@typespec/xml";

using TypeSpec.Http;

@service(#{ title: "Pet Store" })
@doc("Test for xml")
namespace PetStore;

model Dog {
  id: string;
  name: string;
  breed?: string;
}

model Address {
  city: string;
  street?: string;
  zipCode?: string;
}

model PetDetails {
  id: string;
  ownerName: string;
  petName: string;
  address: Address;
}

@post
@route("/dogs")
op uploadDog(@header contentType: "application/xml", @body body: Dog): NoContentResponse;

@get
@route("/petDetails/{id}")
op getPetDetails(@path id: string, @header accept: "application/xml"): PetDetails;
```

## High Level Implementation Additions

### XML Serialization Methods

Two new methods handle XML writing:

```csharp
// Private method that writes the root element wrapper
private void Write(XmlWriter writer, ModelReaderWriterOptions options, string nameHint = null)
{
    writer.WriteStartElement(nameHint ?? "Dog");
    XmlModelWriteCore(writer, options);
    writer.WriteEndElement();
}

// Protected virtual method for writing inner content - extensibility point for derived types
protected virtual void XmlModelWriteCore(XmlWriter writer, ModelReaderWriterOptions options)
{
    string format = options.Format == "W" ? ((IPersistableModel<Dog>)this).GetFormatFromOptions(options) : options.Format;
    if (format != "X")
    {
        throw new FormatException($"The model {nameof(Dog)} does not support writing '{format}' format.");
    }
    writer.WriteStartElement("id");
    writer.WriteValue(Id);
    writer.WriteEndElement();
    writer.WriteStartElement("name");
    writer.WriteValue(Name);
    writer.WriteEndElement();
    if (Optional.IsDefined(Breed))
    {
        writer.WriteStartElement("breed");
        writer.WriteValue(Breed);
        writer.WriteEndElement();
    }
}
```

### XML Deserialization Method

A new overload of the `Deserialize` method handles XML:

```csharp
internal static Dog DeserializeDog(XElement element, ModelReaderWriterOptions options)
{
    if (element == null)
    {
        return null;
    }

    string id = default;
    string name = default;
    string breed = default;

    foreach (var child in element.Elements())
    {
        var localName = child.Name.LocalName;
        if (localName == "id")
        {
            id = (string)child;
            continue;
        }
        if (localName == "name")
        {
            name = (string)child;
            continue;
        }
        if (localName == "breed")
        {
            breed = (string)child;
            continue;
        }
    }

    return new Dog(id, name, breed, additionalBinaryDataProperties: default);
}
```

### Azure Branded Implementation

For Azure branded libraries, models that support XML will implement Azure Core's `IXmlSerializable`:

```csharp
public partial class Dog : IXmlSerializable, IPersistableModel<Dog>
{
    // ...
    void IXmlSerializable.Write(XmlWriter writer, string nameHint) => Write(writer, ModelSerializationExtensions.WireOptions, nameHint);
    // ...
}
```

## Generated Code

This section shows the complete generated serialization code for each model in the PetStore library.

### Dog.Serialization.cs

<details>
<summary>Click to expand</summary>

```csharp
// <auto-generated/>

#nullable disable

using System;
using System.ClientModel;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using System.Xml.Linq;

namespace PetStore
{
    /// <summary> The Dog. </summary>
    public partial class Dog : IPersistableModel<Dog>
    {
        /// <summary> Initializes a new instance of <see cref="Dog"/> for deserialization. </summary>
        internal Dog()
        {
        }

        private void Write(XmlWriter writer, ModelReaderWriterOptions options, string nameHint = null)
        {
            writer.WriteStartElement(nameHint ?? "Dog");
            XmlModelWriteCore(writer, options);
            writer.WriteEndElement();
        }

        /// <summary> Writes the XML content of this model without the root element wrapper. </summary>
        /// <param name="writer"> The XML writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void XmlModelWriteCore(XmlWriter writer, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<Dog>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "X")
            {
                throw new FormatException($"The model {nameof(Dog)} does not support writing '{format}' format.");
            }
            writer.WriteStartElement("id");
            writer.WriteValue(Id);
            writer.WriteEndElement();
            writer.WriteStartElement("name");
            writer.WriteValue(Name);
            writer.WriteEndElement();
            if (Optional.IsDefined(Breed))
            {
                writer.WriteStartElement("breed");
                writer.WriteValue(Breed);
                writer.WriteEndElement();
            }
        }

        internal static Dog DeserializeDog(XElement element, ModelReaderWriterOptions options)
        {
            if (element == null)
            {
                return null;
            }

            string id = default;
            string name = default;
            string breed = default;

            foreach (var child in element.Elements())
            {
                var localName = child.Name.LocalName;
                if (localName == "id")
                {
                    id = (string)child;
                    continue;
                }
                if (localName == "name")
                {
                    name = (string)child;
                    continue;
                }
                if (localName == "breed")
                {
                    breed = (string)child;
                    continue;
                }
            }

            return new Dog(id, name, breed, additionalBinaryDataProperties: default);
        }

        /// <param name="options"> The client options for reading and writing models. </param>
        BinaryData IPersistableModel<Dog>.Write(ModelReaderWriterOptions options) => PersistableModelWriteCore(options);

        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual BinaryData PersistableModelWriteCore(ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<Dog>)this).GetFormatFromOptions(options) : options.Format;
            switch (format)
            {
                case "X":
                    using (MemoryStream stream = new MemoryStream(256))
                    {
                        using (XmlWriter writer = XmlWriter.Create(stream))
                        {
                            Write(writer, options);
                        }
                        return new BinaryData(stream.ToArray());
                    }
                default:
                    throw new FormatException($"The model {nameof(Dog)} does not support writing '{format}' format.");
            }
        }

        /// <param name="data"> The data to parse. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        Dog IPersistableModel<Dog>.Create(BinaryData data, ModelReaderWriterOptions options) => PersistableModelCreateCore(data, options);

        /// <param name="data"> The data to parse. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual Dog PersistableModelCreateCore(BinaryData data, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<Dog>)this).GetFormatFromOptions(options) : options.Format;
            switch (format)
            {
                case "X":
                    using (var dataStream = data.ToStream())
                    {
                        return DeserializeDog(XElement.Load(dataStream, LoadOptions.None), options);
                    }
                default:
                    throw new FormatException($"The model {nameof(Dog)} does not support reading '{format}' format.");
            }
        }

        /// <param name="options"> The client options for reading and writing models. </param>
        string IPersistableModel<Dog>.GetFormatFromOptions(ModelReaderWriterOptions options) => "X";

        /// <param name="dog"> The <see cref="Dog"/> to serialize into <see cref="BinaryContent"/>. </param>
        public static implicit operator BinaryContent(Dog dog)
        {
            if (dog == null)
            {
                return null;
            }
            return BinaryContent.Create(dog, ModelSerializationExtensions.WireOptions);
        }
    }
}
```

</details>

### Address.Serialization.cs

<details>
<summary>Click to expand</summary>

```csharp
// <auto-generated/>

#nullable disable

using System;
using System.ClientModel;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using System.Xml.Linq;

namespace PetStore
{
    /// <summary> The Address. </summary>
    public partial class Address : IPersistableModel<Address>
    {
        /// <summary> Initializes a new instance of <see cref="Address"/> for deserialization. </summary>
        internal Address()
        {
        }

        private void Write(XmlWriter writer, ModelReaderWriterOptions options, string nameHint = null)
        {
            writer.WriteStartElement(nameHint ?? "Address");
            XmlModelWriteCore(writer, options);
            writer.WriteEndElement();
        }

        /// <summary> Writes the XML content of this model without the root element wrapper. </summary>
        /// <param name="writer"> The XML writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void XmlModelWriteCore(XmlWriter writer, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<Address>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "X")
            {
                throw new FormatException($"The model {nameof(Address)} does not support writing '{format}' format.");
            }
            writer.WriteStartElement("city");
            writer.WriteValue(City);
            writer.WriteEndElement();
            if (Optional.IsDefined(Street))
            {
                writer.WriteStartElement("street");
                writer.WriteValue(Street);
                writer.WriteEndElement();
            }
            if (Optional.IsDefined(ZipCode))
            {
                writer.WriteStartElement("zipCode");
                writer.WriteValue(ZipCode);
                writer.WriteEndElement();
            }
        }

        internal static Address DeserializeAddress(XElement element, ModelReaderWriterOptions options)
        {
            if (element == null)
            {
                return null;
            }

            string city = default;
            string street = default;
            string zipCode = default;

            foreach (var child in element.Elements())
            {
                var localName = child.Name.LocalName;
                if (localName == "city")
                {
                    city = (string)child;
                    continue;
                }
                if (localName == "street")
                {
                    street = (string)child;
                    continue;
                }
                if (localName == "zipCode")
                {
                    zipCode = (string)child;
                    continue;
                }
            }

            return new Address(city, street, zipCode, additionalBinaryDataProperties: default);
        }

        /// <param name="options"> The client options for reading and writing models. </param>
        BinaryData IPersistableModel<Address>.Write(ModelReaderWriterOptions options) => PersistableModelWriteCore(options);

        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual BinaryData PersistableModelWriteCore(ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<Address>)this).GetFormatFromOptions(options) : options.Format;
            switch (format)
            {
                case "X":
                    using (MemoryStream stream = new MemoryStream(256))
                    {
                        using (XmlWriter writer = XmlWriter.Create(stream))
                        {
                            Write(writer, options);
                        }
                        return new BinaryData(stream.ToArray());
                    }
                default:
                    throw new FormatException($"The model {nameof(Address)} does not support writing '{format}' format.");
            }
        }

        /// <param name="data"> The data to parse. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        Address IPersistableModel<Address>.Create(BinaryData data, ModelReaderWriterOptions options) => PersistableModelCreateCore(data, options);

        /// <param name="data"> The data to parse. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual Address PersistableModelCreateCore(BinaryData data, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<Address>)this).GetFormatFromOptions(options) : options.Format;
            switch (format)
            {
                case "X":
                    using (var dataStream = data.ToStream())
                    {
                        return DeserializeAddress(XElement.Load(dataStream, LoadOptions.None), options);
                    }
                default:
                    throw new FormatException($"The model {nameof(Address)} does not support reading '{format}' format.");
            }
        }

        /// <param name="options"> The client options for reading and writing models. </param>
        string IPersistableModel<Address>.GetFormatFromOptions(ModelReaderWriterOptions options) => "X";
    }
}
```

</details>

### PetDetails.Serialization.cs

<details>
<summary>Click to expand</summary>

```csharp
// <auto-generated/>

#nullable disable

using System;
using System.ClientModel;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using System.Xml.Linq;

namespace PetStore
{
    /// <summary> The PetDetails. </summary>
    public partial class PetDetails : IPersistableModel<PetDetails>
    {
        /// <summary> Initializes a new instance of <see cref="PetDetails"/> for deserialization. </summary>
        internal PetDetails()
        {
        }

        private void Write(XmlWriter writer, ModelReaderWriterOptions options, string nameHint = null)
        {
            writer.WriteStartElement(nameHint ?? "PetDetails");
            XmlModelWriteCore(writer, options);
            writer.WriteEndElement();
        }

        /// <summary> Writes the XML content of this model without the root element wrapper. </summary>
        /// <param name="writer"> The XML writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void XmlModelWriteCore(XmlWriter writer, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<PetDetails>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "X")
            {
                throw new FormatException($"The model {nameof(PetDetails)} does not support writing '{format}' format.");
            }
            writer.WriteStartElement("id");
            writer.WriteValue(Id);
            writer.WriteEndElement();
            writer.WriteStartElement("ownerName");
            writer.WriteValue(OwnerName);
            writer.WriteEndElement();
            writer.WriteStartElement("petName");
            writer.WriteValue(PetName);
            writer.WriteEndElement();
            writer.WriteObjectValue(Address, options, "address");
        }

        internal static PetDetails DeserializePetDetails(XElement element, ModelReaderWriterOptions options)
        {
            if (element == null)
            {
                return null;
            }

            string id = default;
            string ownerName = default;
            string petName = default;
            Address address = default;

            foreach (var child in element.Elements())
            {
                var localName = child.Name.LocalName;
                if (localName == "id")
                {
                    id = (string)child;
                    continue;
                }
                if (localName == "ownerName")
                {
                    ownerName = (string)child;
                    continue;
                }
                if (localName == "petName")
                {
                    petName = (string)child;
                    continue;
                }
                if (localName == "address")
                {
                    address = Address.DeserializeAddress(child, options);
                    continue;
                }
            }

            return new PetDetails(id, ownerName, petName, address, additionalBinaryDataProperties: default);
        }

        /// <param name="options"> The client options for reading and writing models. </param>
        BinaryData IPersistableModel<PetDetails>.Write(ModelReaderWriterOptions options) => PersistableModelWriteCore(options);

        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual BinaryData PersistableModelWriteCore(ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<PetDetails>)this).GetFormatFromOptions(options) : options.Format;
            switch (format)
            {
                case "X":
                    using (MemoryStream stream = new MemoryStream(256))
                    {
                        using (XmlWriter writer = XmlWriter.Create(stream))
                        {
                            Write(writer, options);
                        }
                        return new BinaryData(stream.ToArray());
                    }
                default:
                    throw new FormatException($"The model {nameof(PetDetails)} does not support writing '{format}' format.");
            }
        }

        /// <param name="data"> The data to parse. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        PetDetails IPersistableModel<PetDetails>.Create(BinaryData data, ModelReaderWriterOptions options) => PersistableModelCreateCore(data, options);

        /// <param name="data"> The data to parse. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual PetDetails PersistableModelCreateCore(BinaryData data, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<PetDetails>)this).GetFormatFromOptions(options) : options.Format;
            switch (format)
            {
                case "X":
                    using (var dataStream = data.ToStream())
                    {
                        return DeserializePetDetails(XElement.Load(dataStream, LoadOptions.None), options);
                    }
                default:
                    throw new FormatException($"The model {nameof(PetDetails)} does not support reading '{format}' format.");
            }
        }

        /// <param name="options"> The client options for reading and writing models. </param>
        string IPersistableModel<PetDetails>.GetFormatFromOptions(ModelReaderWriterOptions options) => "X";

        /// <param name="result"> The <see cref="ClientResult"/> to deserialize the <see cref="PetDetails"/> from. </param>
        public static explicit operator PetDetails(ClientResult result)
        {
            PipelineResponse response = result.GetRawResponse();
            using (var dataStream = response.Content.ToStream())
            {
                return DeserializePetDetails(XElement.Load(dataStream, LoadOptions.None), ModelSerializationExtensions.WireOptions);
            }
        }
    }
}
```

</details>

## Usage Examples

### Round-Tripping a Model with ModelReaderWriter

The `ModelReaderWriter` class provides a simple API for serializing and deserializing models. With XML support, users can easily round-trip models in XML format:

#### Serializing to XML

```csharp
// Create a Dog model instance
var dog = new Dog("dog-123", "Buddy", "Golden Retriever");

// Serialize to XML using ModelReaderWriter
var xmlOptions = new ModelReaderWriterOptions("X");
BinaryData xmlData = ModelReaderWriter.Write(dog, xmlOptions);

// Get the XML string
string xml = xmlData.ToString();
// Output: <?xml version="1.0" encoding="utf-8"?><Dog><id>dog-123</id><name>Buddy</name><breed>Golden Retriever</breed></Dog>
```

#### Deserializing from XML

```csharp
// XML data received from a service
string xml = @"<?xml version=""1.0"" encoding=""utf-8""?><Dog><id>dog-456</id><name>Max</name><breed>Labrador</breed></Dog>";
BinaryData xmlData = BinaryData.FromString(xml);

// Deserialize from XML using ModelReaderWriter
var xmlOptions = new ModelReaderWriterOptions("X");
Dog dog = ModelReaderWriter.Read<Dog>(xmlData, xmlOptions);

Console.WriteLine($"Id: {dog.Id}, Name: {dog.Name}, Breed: {dog.Breed}");
// Output: Id: dog-456, Name: Max, Breed: Labrador
```

#### Complete Round-Trip Example

```csharp
using System.ClientModel.Primitives;

// Create original model
var original = new Dog("dog-789", "Charlie", "Beagle");

// Define XML format options
var xmlOptions = new ModelReaderWriterOptions("X");

// Serialize to XML
BinaryData xmlData = ModelReaderWriter.Write(original, xmlOptions);
Console.WriteLine($"Serialized XML: {xmlData}");

// Deserialize back to model
Dog roundTripped = ModelReaderWriter.Read<Dog>(xmlData, xmlOptions);

// Verify the round-trip
Console.WriteLine($"Original: Id={original.Id}, Name={original.Name}, Breed={original.Breed}");
Console.WriteLine($"Round-tripped: Id={roundTripped.Id}, Name={roundTripped.Name}, Breed={roundTripped.Breed}");
```
