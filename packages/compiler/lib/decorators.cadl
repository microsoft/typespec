import "../dist/lib/decorators.js";

using Cadl.Reflection;

namespace Cadl;

/**
 * Typically a short, single-line description.
 * @param summary Summary string.
 *
 * @example
 * ```cadl
 * @summary("This is a pet")
 * model Pet {}
 * ```
 */
extern dec summary(target: unknown, summary: string);

/**
 * Attach a documentation string.
 * @param doc Documentation string
 * @param formatArgs Record with key value pair that can be interpolated in the doc.
 *
 * @example
 * ```cadl
 * @doc("Represent a Pet available in the PetStore")
 * model Pet {}
 * ```
 */
extern dec doc(target: unknown, doc: string, formatArgs?: object);

/**
 * Mark this type as deprecated
 * @param message Deprecation message.
 *
 * ```cadl
 * @deprecated("Use ActionV2")
 * op Action<T>(): T;
 * ```
 */
extern dec deprecated(target: unknown, message: string);

/**
 * Service options.
 */
model ServiceOptions {
  /**
   * Title of the service.
   */
  title?: string;
  /**
   * Version of the service.
   */
  version?: string;
}

/**
 * Mark this namespace as describing a service and configure service properties.
 * @param options Optional configuration for the service.
 *
 * @example
 * ```cadl
 * @service
 * namespace PetStore;
 * ```
 *
 * @example Setting service title
 * ```cadl
 * @service({title: "Pet store"})
 * namespace PetStore;
 * ```
 *
 * @example Setting service version
 * ```cadl
 * @service({version: "1.0"})
 * namespace PetStore;
 * ```
 */
extern dec service(target: Namespace, options?: ServiceOptions);

/**
 * Specify that this model is an error type. Operations return error types when the operation has failed.
 *
 * @example
 * ```cadl
 * @error
 * model PetStoreError {
 *   code: string;
 *   message: string;
 * }
 * ```
 */
extern dec error(target: object);

/**
 * Specify a known data format hint for this string type. For example `uuid`, `uri`, etc.
 * This differ from the @pattern decorator that is meant to specify a regular expression while @format takes in a known format name.
 * The format names are open ended and are left to emitter to interpret.
 *
 * @param format format name.
 *
 * @example
 * ```cadl
 * @format("uuid")
 * scalar uuid extends string;
 * ```
 */
extern dec format(target: string | bytes | ModelProperty, format: string);

/**
 * Specify the the pattern this string should respect using simple regular expression syntax.
 * The following syntax is allowed: alternations (`|`), quantifiers (`?`, `*`, `+`, and `{ }`), wildcard (`.`), and grouping parentheses.
 * Advanced features like look-around, capture groups, and references are not supported.
 *
 * @param pattern Regular expression.
 *
 * @example
 * ```cadl
 * @pattern("[a-z]+")
 * scalar LowerAlpha extends string;
 * ```
 */
extern dec pattern(target: string | bytes | ModelProperty, pattern: string);

/**
 * Specify the minimum length this string type should be.
 * @param value Minimum length
 *
 * @example
 * ```cadl
 * @minLength(2)
 * scalar Username extends string;
 * ```
 */
extern dec minLength(target: string | ModelProperty, value: integer);

/**
 * Specify the maximum length this string type should be.
 * @param value Maximum length
 *
 * @example
 * ```cadl
 * @maxLength(20)
 * scalar Username extends string;
 * ```
 */
extern dec maxLength(target: string | ModelProperty, value: integer);

/**
 * Specify the minimum number of items this array should have.
 * @param value Minimum number
 *
 * @example
 * ```cadl
 * @minItems(1)
 * model Endpoints is string[];
 * ```
 */
extern dec minItems(target: unknown[] | ModelProperty, value: integer);

/**
 * Specify the maximum number of items this array should have.
 * @param value Maximum number
 *
 * @example
 * ```cadl
 * @maxItems(5)
 * model Endpoints is string[];
 * ```
 */
extern dec maxItems(target: unknown[] | ModelProperty, value: integer);

/**
 * Specific the minimum value this numeric type should be.
 * @param value Minimum value
 *
 * @example
 * ```cadl
 * @maxValue(18)
 * scalar Age is int32;
 * ```
 */
extern dec minValue(target: numeric | ModelProperty, value: numeric);

/**
 * Specific the maximum value this numeric type should be.
 * @param value Maximum value
 *
 * @example
 * ```cadl
 * @maxValue(200)
 * scalar Age is int32;
 * ```
 */
extern dec maxValue(target: numeric | ModelProperty, value: numeric);

/**
 * Mark this string as a secret value that should be treated carefully to avoid exposure
 *
 * @example
 * ```cadl
 * @secret
 * scalar Password is string;
 * ```
 */
extern dec secret(target: string | ModelProperty);

/**
 * Attaches a tag to an operation, interface, or namespace. Multiple `@tag` decorators can be specified to attach multiple tags to a Cadl element.
 * @param tag Tag value
 */
extern dec tag(target: Namespace | Interface | Operation, tag: string);

/**
 * Specifies how a templated type should name their instances.
 * @param name name the template instance should take
 * @formatArgs Model with key value used to interpolate the name
 *
 * @example
 * ```cadl
 * @friendlyName("{name}List", T)
 * model List<T> {
 *   value: T[];
 *   nextLink: string;
 * }
 * ```
 */
extern dec friendlyName(target: unknown, name: string, formatArgs?: unknown);

/**
 * Provide a set of known values to a string type.
 * @param values Known values enum.
 *
 * @example
 * ```cadl
 * @knownValues(KnownErrorCode)
 * scalar ErrorCode extends string;
 *
 * enum KnownErrorCode {
 *   NotFound,
 *   Invalid,
 * }
 * ```
 */
extern dec knownValues(target: string | numeric | ModelProperty, values: Enum);

/**
 * Mark a model property as the key to identify instances of that type
 *
 * @example
 * ```cadl
 * model Pet {
 *   @key id: string;
 * }
 * ```
 */
extern dec key(target: ModelProperty, altName?: string);

/**
 * Specify this operation is an overload of the given operation.
 * @param overloadbase Base operation that should be a union of all overloads
 *
 * @example
 * ```cadl
 * op upload(data: string | bytes, @header contentType: "text/plain" | "application/octet-stream"): void;
 * @overload(upload)
 * op uploadString(data: string, @header contentType: "text/plain" ): void;
 * @overload(upload)
 * op uploadBytes(data: bytes, @header contentType: "application/octet-stream"): void;
 * ```
 */
extern dec overload(target: Operation, overloadbase: Operation);

/**
 * Provide an alternative name for this type.
 * @param targetName Projection target
 * @param projectedName Alternative name
 *
 * @example
 * ```cadl
 * model Certificate {
 *   @projectedName("json", "exp")
 *   expireAt: int32;
 * }
 * ```
 */
extern dec projectedName(target: unknown, targetName: string, projectedName: string);

/**
 * Specify the property to be used to discriminate this type.
 *
 * @example
 *
 * ```cadl
 * @discriminator("kind")
 * union Pet{ cat: Cat, dog: Dog }
 *
 * model Cat {kind: "cat", meow: boolean}
 * model Dog {kind: "dog", bark: boolean}
 * ```
 *
 * ```cadl
 * @discriminator("kind")
 * model Pet{ kind: string }
 *
 * model Cat extends Pet {kind: "cat", meow: boolean}
 * model Dog extends Pet  {kind: "dog", bark: boolean}
 * ```
 */
extern dec discriminator(target: object | Union, propertyName: string);

/**
 * Provide an extensible visibility framework that allows for defining a canonical model with fine-grained visibility flags and derived models that apply those flags.
 * Flags can be any string value and so can be customized to your application.
 * @param visibilities Visibilities that applies to the target properties.
 */
extern dec visibility(target: ModelProperty, ...visibilities: string[]);

/**
 * Will only select properties with the matching visibilities.
 */
extern dec withVisibility(target: object, ...visibilities: string[]);
extern dec withDefaultKeyVisibility(target: object, visibility: unknown);
extern dec withUpdateableProperties(target: object);
extern dec withoutDefaultValues(target: object);
extern dec withoutOmittedProperties(target: object, omit: string | Union);

//---------------------------------------------------------------------------
// Debugging
//---------------------------------------------------------------------------
extern dec inspectType(target: unknown, text: string);
extern dec inspectTypeName(target: unknown, text: string);
