// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace lro_LowLevel
{
    /// <summary> The LROs service client. </summary>
    public partial class LROsClient
    {
        /// <summary> Add the convenience method for testing. </summary>
        ///  When protocol method returns a response without content, it will return Operation. The convienience method is to verify no break occurs in asyncronous convienience methods.
        public virtual async Task<Operation> DeleteValue204SucceededAsync(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            var requestContext = new RequestContext { CancellationToken = cancellationToken };
            using var scope = ClientDiagnostics.CreateScope("LROsClient.Delete204Succeeded");
            scope.Start();
            try
            {
                var delOperation = await Delete204SucceededAsync(waitUntil, requestContext).ConfigureAwait(false);
                return delOperation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add the convenience method for testing. </summary>
        ///  When protocol method returns a response without content, it will return Operation. The convienience method is to verify no break occurs in synchronous convienience methods.
        public virtual Operation DeleteValue204Succeeded(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            var requestContext = new RequestContext { CancellationToken = cancellationToken };
            using var scope = ClientDiagnostics.CreateScope("LROsClient.Delete204Succeeded");
            scope.Start();
            try
            {
                var delOperation = Delete204Succeeded(waitUntil, requestContext);
                return delOperation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}
