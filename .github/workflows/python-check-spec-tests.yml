name: "[Python] Check Spec Test Cases"

on:
  # schedule:
  #   - cron: "0 0 * * *" # Daily at midnight UTC
  workflow_dispatch:

permissions:
  issues: write

concurrency:
  group: python-check-spec-tests
  cancel-in-progress: true

jobs:
  check-and-create-issues:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Check for new spec changes and create issues
        env:
          GH_TOKEN: ${{ secrets.ISSUE_CREATE_GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          PACKAGE_JSON_URL="https://raw.githubusercontent.com/microsoft/typespec/main/packages/http-client-python/package.json"
          SKILL_URL="https://github.com/microsoft/typespec/blob/main/.github/skills/python-sdk-spector-mock-api-tests/SKILL.md"
          ISSUE_REPO="microsoft/typespec"

          # Fetch package.json from main branch once
          PACKAGE_JSON_CONTENT=$(curl -fsSL "$PACKAGE_JSON_URL")
          if [ -z "$PACKAGE_JSON_CONTENT" ]; then
            echo "ERROR: Could not fetch package.json from main branch"
            exit 1
          fi

          check_package() {
            local pkg_name="$1"
            local repo="$2"
            local specs_path="$3"

            echo "=============================="
            echo "Checking package: $pkg_name"
            echo "=============================="

            # Step 1: Extract version A from package.json devDependencies (main branch)
            local version_a
            version_a=$(echo "$PACKAGE_JSON_CONTENT" | jq -r ".devDependencies[\"$pkg_name\"]")
            if [ -z "$version_a" ] || [ "$version_a" = "null" ]; then
              echo "WARNING: Could not find $pkg_name in devDependencies, skipping"
              return
            fi
            echo "Version A (from main branch package.json): $version_a"

            # Step 2: Get publish dates and find the most recently published version (including dev/prerelease)
            local time_data
            time_data=$(npm view "$pkg_name" time --json 2>/dev/null || true)
            if [ -z "$time_data" ]; then
              echo "WARNING: Could not get time data for $pkg_name from npm, skipping"
              return
            fi

            # Find the most recently published version (excluding "created" and "modified" metadata keys)
            local version_b
            version_b=$(echo "$time_data" | jq -r 'to_entries | map(select(.key != "created" and .key != "modified")) | sort_by(.value) | last | .key')
            if [ -z "$version_b" ] || [ "$version_b" = "null" ]; then
              echo "WARNING: Could not determine latest version from npm time data, skipping"
              return
            fi
            echo "Version B (most recently published): $version_b"

            local date_a
            date_a=$(echo "$time_data" | jq -r ".[\"$version_a\"]")
            local date_b
            date_b=$(echo "$time_data" | jq -r ".[\"$version_b\"]")

            if [ "$date_a" = "null" ] || [ -z "$date_a" ]; then
              echo "WARNING: Could not find publish date for version $version_a, skipping"
              return
            fi
            if [ "$date_b" = "null" ] || [ -z "$date_b" ]; then
              echo "WARNING: Could not find publish date for version $version_b, skipping"
              return
            fi

            echo "Date A ($version_a): $date_a"
            echo "Date B ($version_b): $date_b"

            # Compare dates - if B (latest) is newer than A (pinned), there are new specs to check
            if [[ "$date_b" > "$date_a" ]]; then
              echo "Latest version is newer than pinned, proceeding to check for PRs..."
            else
              echo "Pinned version is up-to-date, skipping $pkg_name"
              return
            fi

            # Step 3: Adjust since date using git commit time instead of npm publish time.
            # npm publish dates lag behind actual commit times due to CI/CD pipeline delays,
            # which can cause recently-merged commits to be missed when the GitHub Commits API
            # filters by author date. We find the last commit on the specs path before version A
            # was published, and use that commit's author date as the since boundary.
            local last_commit_date
            last_commit_date=$(gh api "repos/${repo}/commits" \
              -f path="${specs_path}" \
              -f until="${date_a}" \
              -f per_page=1 \
              --jq '.[0].commit.author.date' 2>/dev/null || true)
            if [ -n "$last_commit_date" ] && [ "$last_commit_date" != "null" ]; then
              echo "Adjusted since date from npm publish ($date_a) to last spec commit ($last_commit_date)"
              date_a="$last_commit_date"
            fi

            # Step 4: Use GitHub commits API (supports path filtering, unlike gh search prs)
            echo "Searching for commits between $date_a and $date_b in $repo affecting $specs_path"

            local pr_numbers
            pr_numbers=$(gh api "repos/${repo}/commits" \
              --paginate \
              -f path="${specs_path}" \
              -f since="${date_a}" \
              -f until="${date_b}" \
              --jq '.[].commit.message' 2>/dev/null \
              | grep -oP '\(#\K[0-9]+(?=\))' \
              | sort -un || true)

            if [ -z "$pr_numbers" ]; then
              echo "No PRs found affecting specs path in date range, skipping"
              return
            fi

            local pr_count
            pr_count=$(echo "$pr_numbers" | wc -l | tr -d ' ')
            echo "Found $pr_count PRs affecting specs in date range"

            # Step 5: Fetch existing issues once (across all states) to avoid duplicate creation
            local existing_issues
            existing_issues=$(gh issue list --repo "$ISSUE_REPO" --state all --search "in:title [python] add test case" --json title --limit 200 2>/dev/null || echo "[]")

            while IFS= read -r pr_number; do
              [ -z "$pr_number" ] && continue
              local pr_url="https://github.com/${repo}/pull/${pr_number}"

              echo "PR #$pr_number affects specs: $pr_url"

              local title="[python] add test case for ${pr_url}"
              local body="follow skill ${SKILL_URL} to write test case for ${pr_url}"

              # Check if an issue with the same title already exists (open or closed)
              local has_match
              has_match=$(echo "$existing_issues" | jq --arg t "$title" '[.[] | select(.title == $t)] | length')

              if [ "$has_match" -gt 0 ]; then
                echo "Issue already exists for PR $pr_url, skipping"
                continue
              fi

              # Create the issue
              gh issue create --repo "$ISSUE_REPO" \
                --title "$title" \
                --body "$body" \
                --label "emitter:client:python" \
                --assignee "copilot"

              echo "Created issue for PR $pr_url"
            done <<< "$pr_numbers"
          }

          # Check both packages
          check_package "@typespec/http-specs" "microsoft/typespec" "packages/http-specs/specs"
          check_package "@azure-tools/azure-http-specs" "Azure/typespec-azure" "packages/azure-http-specs/specs"

          echo "Done!"
